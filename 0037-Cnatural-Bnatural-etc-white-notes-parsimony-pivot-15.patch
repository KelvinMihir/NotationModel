From 66f5b1ca2fb505526fb1cc4d7a5cc524e5383869 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 4 Nov 2018 20:33:50 -0500
Subject: [PATCH 37/66] Cnatural, Bnatural, etc (white notes) parsimony pivot
 (#158)

---
 .../Wetherfield/FlowNetwork.swift             |   6 +
 .../Wetherfield/GraphSchemeProtocol.swift     |   8 +-
 .../Wetherfield/Pitch.Spelling.Category.swift |   4 +-
 .../UnweightedGraphSchemeProtocol.swift       |  11 ++
 .../Wetherfield/Wetherfield.swift             | 130 ++++++++++++++----
 5 files changed, 127 insertions(+), 32 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index faf9a3a..a90e690 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -59,6 +59,12 @@ extension FlowNetwork {
             if !adjacencyCarrying.contains(from: edge.a, to: edge.b) { remove(edge) }
         }
     }
+    
+    mutating func mask (_ adjacencyScheme: GraphScheme<Node>) {
+        for edge in edges where !adjacencyScheme.contains(GraphScheme<Node>.Edge(edge.a, edge.b)) {
+            remove(edge)
+        }
+    }
 }
 
 extension FlowNetwork {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
index 2b3a6c1..91d2899 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
@@ -13,9 +13,11 @@ public protocol GraphSchemeProtocol {
 }
 
 extension GraphProtocol {
-    func adjacencyScheme <G> (_ f: @escaping (G.Node) -> Node) -> AdjacencyCarrying<G> where
-        G: GraphProtocol
+    func adjacencyScheme <G> () -> G where
+        G: UnweightedGraphSchemeProtocol,
+        G.Edge == Edge,
+        G.Node == Node
     {
-        return AdjacencyCarrying.build(from: self).pullback(f)
+        return G.init(self.contains)
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 060a1f9..fe6ebd0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -220,7 +220,9 @@ extension Pitch.Spelling.Category.Five: TendencyConverting {
     static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
         return [
             .init(.down,.down): .down,
-            .init(.up,.down): .up
+            .init(.down,.up): .down,
+            .init(.up,.down): .up,
+            .init(.up,.up): .up
         ]
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 83bf759..1aae3f1 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -19,3 +19,14 @@ extension UnweightedGraphSchemeProtocol {
         return H.init { self.contains(Edge(f($0.a),f($0.b))) }
     }
 }
+
+extension UnweightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol {
+    
+    static func * (lhs: Self, rhs: Self) -> Self {
+        return Self.init { edge in lhs.contains(edge) && rhs.contains(edge) }
+    }
+    
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self.init { edge in lhs.contains(edge) || rhs.contains(edge) }
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index e1820d5..2b9e496 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -19,28 +19,17 @@ protocol PitchSpellingNode: Hashable {
     var index: Index { get }
 }
 
-struct PitchSpeller {
-
-    // FIXME: Flesh out for all tendencies
-    static let tendencyGraph: Graph<Tendency> = Graph(
-        [
-            .up,
-            .down
-        ],
-        [
-            UnorderedPair(.up,.up),
-            UnorderedPair(.down,.down)
-        ]
-    )
-
-    static let adjacencyCarrying = AdjacencyCarrying.build(from: PitchSpeller.tendencyGraph)
-    static let tendencyMask: AdjacencyCarrying<Graph<FlowNode<Cross<Int,Tendency>>>> = adjacencyCarrying.pullback { node in
-        switch node {
+extension FlowNode where Index == Cross<Int,Tendency> {
+    var tendency: Tendency {
+        switch self {
         case .source: return .down
-        case .sink: return .up
-        case .`internal`(let index): return index.b
+        case.sink: return .up
+        case.internal(let index): return index.b
         }
     }
+}
+
+struct PitchSpeller {
 
     struct UnassignedNode: PitchSpellingNode {
         let index: Index
@@ -63,12 +52,74 @@ struct PitchSpeller {
             self.assignment = assignment
         }
     }
+    
+    // FIXME: Flesh out for all tendencies
+    static let tendencyGraph: Graph<Tendency> = Graph(
+        [
+            .up,
+            .down
+        ],
+        [
+            UnorderedPair(.up,.up),
+            UnorderedPair(.down,.down)
+        ]
+    )
+    
+    // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
+    // be connected to `(8, .up)` in the spelling dependency model.
+    static let eightTendencyLink: [(Pitch.Class, Tendency)] = [
+        (00, .down),
+        (01, .up),
+        (03, .down),
+        (04, .up),
+        (05, .down),
+        (06, .up),
+        (07, .down),
+        (08, .up),
+        (09, .up),
+        (10, .down),
+        (11, .up)
+    ]
+    
+    // Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
+    static let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
+        PitchSpeller.eightTendencyLink.lazy
+            .map { pitchClass, tendency in
+                .init(pitchClass, tendency)
+            }.map { cross in
+                .init(cross, .init(8, .up))
+        }
+    )
+    
+    static let sameTendencyScheme: GraphScheme = tendencyGraph.adjacencyScheme()
+    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
+        = sameTendencyScheme.pullback { node in
+            switch node {
+            case .source: return .down
+            case .sink: return .up
+            case .internal(let index): return index.b
+            }
+    }
+    
+    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
+        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                edge.contains(pitchClass)
+            }
+        }
+        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                !edge.contains(pitchClass)
+            }
+        }
+        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
+    }
 
     /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
     /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
     /// the given `Pitch`.)
     private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-        return .`internal`(.init(offset, index))
+        return .internal(.init(offset, index))
     }
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
@@ -79,9 +130,6 @@ struct PitchSpeller {
 
     // MARK: - Instance Properties
 
-    /// The omnipresent, tie-breaking `Pitch.Spelling` value.
-    let parsimonyPivot: Pitch.Spelling
-
     /// The unspelled `Pitch` values to be spelled.
     let pitch: (PitchSpellingNode.Index) -> Pitch?
 
@@ -91,6 +139,9 @@ struct PitchSpeller {
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
     var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
+    
+    /// Getter for pitch class (from Index)
+    let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 
     // MARK: - Initializers
 
@@ -100,18 +151,31 @@ struct PitchSpeller {
             switch index {
             case .source, .sink:
                 return Pitch(value: parsimonyPivot.pitchClass.value)
-            case .`internal`(let cross):
+            case .internal(let cross):
                 return pitches[cross.a]
             }
         }
-        self.parsimonyPivot = parsimonyPivot
+        let getPitchClass: (FlowNode<Cross<Int,Tendency>>) -> Pitch.Class = { flowNode in
+            switch flowNode {
+            case .source, .sink:
+                return parsimonyPivot.pitchClass
+            case .internal(let cross):
+                return pitches[cross.a]!.class
+            }
+        }
+        self.getPitchClass = getPitchClass
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
             source: .source,
             sink: .sink,
             internalNodes: pitchNodes
         )
-        flowNetwork.mask(PitchSpeller.tendencyMask)
+        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(PitchSpeller.eightLookup.contains)
+        let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
+            .init(getPitchClass(flowNode), flowNode.tendency)
+        }
+        flowNetwork.mask((PitchSpeller.connectSameTendencies * whereEdge(contains: false)(8)) +
+            (connectToEight * whereEdge(contains: true)(8)) )
     }
 
     /// - Returns: An array of `SpelledPitch` values with the same indices as the original
@@ -130,7 +194,7 @@ struct PitchSpeller {
             .compactMap { (assignedNode) -> InternalAssignedNode? in
                 switch assignedNode.index {
                 case .source, .sink: return nil
-                case .`internal`(let index): return InternalAssignedNode(index, assignedNode.assignment)
+                case .internal(let index): return InternalAssignedNode(index, assignedNode.assignment)
                 }
             }
             .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
@@ -145,11 +209,21 @@ struct PitchSpeller {
     }
 
     private func spellPitch(_ up: InternalAssignedNode, _ down: InternalAssignedNode) -> SpelledPitch {
-        let pitch = self.pitch(.`internal`(up.index))!
+        let pitch = self.pitch(.internal(up.index))!
         let tendencies = TendencyPair(up.assignment, down.assignment)
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
+    
+    func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
+        func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
+            return PitchSpeller.adjacencyScheme(contains: true)(8).pullback(getPitchClass)
+        }
+        func doesNotContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
+            return PitchSpeller.adjacencyScheme(contains: false)(8).pullback(getPitchClass)
+        }
+        return contains ? doesContain : doesNotContain
+    }
 }
 
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
-- 
2.17.2 (Apple Git-113)

