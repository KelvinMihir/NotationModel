From 90a8dc30c23cdfeec4780716c486c09203ec5e65 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Tue, 18 Sep 2018 12:02:18 -0400
Subject: [PATCH 01/66] Remove redundant import

---
 .../PitchSpeller/Wetherfield/TendencyConverting.swift            | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
index 198be7e..40d8370 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
@@ -6,7 +6,6 @@
 //
 
 import Pitch
-import SpelledPitch
 
 /// Interface for `PitchSpellingCategoryProtocol` types which can convert a `TendencyPair` into a
 /// `ModifierDirection`.
-- 
2.17.2 (Apple Git-113)


From 7824924eb7b3822374af6daf2cbe426761a7bdb8 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Tue, 18 Sep 2018 16:59:29 -0400
Subject: [PATCH 02/66] Remove Bimap

---
 .../Wetherfield/Data Structures/Bimap.swift   | 119 ------------------
 1 file changed, 119 deletions(-)
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Bimap.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Bimap.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Bimap.swift
deleted file mode 100644
index 2559818..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Bimap.swift	
+++ /dev/null
@@ -1,119 +0,0 @@
-//
-//  Bimap.swift
-//  PitchSpeller
-//
-//  Created by James Bean on 6/9/18.
-//
-
-public struct Bimap <Key: Hashable, Value: Hashable>: Hashable {
-
-    // MARK: - Instance Properties
-
-    private var valueByKey = [Key: Value]()
-    private var keyByValue = [Value: Key]()
-
-    // MARK: - Initializers
-
-    public init() { }
-
-    public init(minimumCapacity: Int) {
-        valueByKey = [Key: Value](minimumCapacity: minimumCapacity)
-        keyByValue = [Value: Key](minimumCapacity: minimumCapacity)
-    }
-
-    public init(_ elements: Dictionary<Key, Value>) {
-        for (k, value) in elements {
-            self[key: k] = value
-        }
-    }
-
-    public init<S:Sequence>(_ elements: S) where S.Iterator.Element == (Key, Value) {
-        for (k, value) in elements {
-            self[key: k] = value
-        }
-    }
-
-    public var count: Int {
-        return valueByKey.count
-    }
-
-    public var isEmpty: Bool {
-        return valueByKey.isEmpty
-    }
-
-    public var keys: AnyCollection<Key> {
-        return AnyCollection(valueByKey.keys)
-    }
-
-    public var values: AnyCollection<Value> {
-        return AnyCollection(keyByValue.keys)
-    }
-
-    public subscript(value value: Value) -> Key? {
-        get {
-            return keyByValue[value]
-        }
-        set(newKey) {
-            let oldKey = keyByValue.removeValue(forKey: value)
-            if let oldKey = oldKey {
-                valueByKey.removeValue(forKey: oldKey)
-            }
-            keyByValue[value] = newKey
-            if let newKey = newKey {
-                valueByKey[newKey] = value
-            }
-        }
-    }
-
-    public subscript(key key: Key) -> Value? {
-        get {
-            return valueByKey[key]
-        }
-        set {
-            let oldValue = valueByKey.removeValue(forKey: key)
-            if let oldValue = oldValue {
-                keyByValue.removeValue(forKey: oldValue)
-            }
-            valueByKey[key] = newValue
-            if let newValue = newValue {
-                keyByValue[newValue] = key
-            }
-        }
-    }
-
-    @discardableResult
-    public mutating func updateValue(_ value: Value, forKey key: Key) -> Value? {
-        let previous = self[key: key]
-        self[key: key] = value
-        return previous
-    }
-
-    @discardableResult
-    public mutating func removeValueForKey(_ key: Key) -> Value? {
-        let previous = self[key: key]
-        self[key: key] = nil
-        return previous
-    }
-
-    @discardableResult
-    public mutating func removeKeyForValue(_ value: Value) -> Key? {
-        let previous = self[value: value]
-        self[value: value] = nil
-        return previous
-    }
-
-    public mutating func removeAll(keepCapacity keep: Bool = true) {
-        keyByValue.removeAll(keepingCapacity: keep)
-        valueByKey.removeAll(keepingCapacity: keep)
-    }
-}
-
-extension Bimap: ExpressibleByDictionaryLiteral {
-
-    // MARK: ExpressibleByDictionaryLiteral Protocol Conformance
-
-    /// Constructs a bimap using a dictionary literal.
-    public init(dictionaryLiteral elements: (Key, Value)...) {
-        self.init(elements)
-    }
-}
-- 
2.17.2 (Apple Git-113)


From 581733f8b48a45d3940c31e17466532bbe7fdd72 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:29:48 -0400
Subject: [PATCH 03/66] Whitespace, add period

---
 .../PitchSpeller/Wetherfield/Data Structures/Graph.swift    | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index eb4406f..2a75e8a 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -29,8 +29,10 @@ enum WithoutWeights: Unweighted {
     case unweighted
 }
 
-// Weightable, directable implementation of a Graph structure
-struct Graph<Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashable> where Pair.A: Hashable {
+// Weightable, directable implementation of a Graph structure.
+struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashable>
+    where Pair.A: Hashable
+{
     
     // MARK: - Typealiases
     
-- 
2.17.2 (Apple Git-113)


From 42941a5e0164626875b61267eaf1a13e68861c2b Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:31:33 -0400
Subject: [PATCH 04/66] Move Node and Path to extensions

---
 .../Wetherfield/Data Structures/Graph.swift   | 87 ++++++++++---------
 1 file changed, 47 insertions(+), 40 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index 2a75e8a..ad0492e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -33,46 +33,7 @@ enum WithoutWeights: Unweighted {
 struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashable>
     where Pair.A: Hashable
 {
-    
-    // MARK: - Typealiases
-    
-    typealias Node = Pair.A
-    
-    struct Edge {
-        
-        // MARK: - Instance Properties
-        
-        let nodes: Pair
-        let weight: Weight
-        
-        // MARK: - Initializers
-        
-        init (_ a: Graph.Node, _ b: Graph.Node, withWeight weight: Weight) {
-            self.nodes = Pair(a, b)
-            self.weight = weight
-        }
-        
-        init (_ nodes: Pair, withWeight weight: Weight) {
-            self.nodes = nodes
-            self.weight = weight
-        }
-    }
-    
-    struct Path {
-        
-        // MARK: - Instance Properties
-        
-        let nodes: [Node]
-        let weights: [Pair: Weight]
-        
-        // MARK: - Initializers
-        
-        init (_ nodes: [Node], _ weights: [Pair: Weight]) {
-            self.nodes = nodes
-            self.weights = weights
-        }
-    }
-    
+
     // MARK: - Instance Properties
      
     var nodes: Set<Node>
@@ -170,6 +131,52 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
     }
 }
 
+extension Graph {
+
+    // MARK: - Type Aliases
+
+    typealias Node = Pair.A
+}
+
+extension Graph {
+
+    // MARK: - Nested Types
+
+    struct Edge {
+
+        // MARK: - Instance Properties
+
+        let nodes: Pair
+        let weight: Weight
+
+        // MARK: - Initializers
+
+        init (_ a: Graph.Node, _ b: Graph.Node, withWeight weight: Weight) {
+            self.nodes = Pair(a, b)
+            self.weight = weight
+        }
+
+        init (_ nodes: Pair, withWeight weight: Weight) {
+            self.nodes = nodes
+            self.weight = weight
+        }
+    }
+
+    struct Path {
+
+        // MARK: - Instance Properties
+
+        let nodes: [Node]
+        let weights: [Pair: Weight]
+
+        // MARK: - Initializers
+
+        init (_ nodes: [Node], _ weights: [Pair: Weight]) {
+            self.nodes = nodes
+            self.weights = weights
+        }
+    }
+}
 
 extension Graph where Weight == WithoutWeights {
     
-- 
2.17.2 (Apple Git-113)


From 72a18bf1f5bedaef2fbc1f555ee969d2a687a7d3 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:32:58 -0400
Subject: [PATCH 05/66] Add doc comments

---
 .../PitchSpeller/Wetherfield/Data Structures/Graph.swift   | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index ad0492e..36d205b 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -119,12 +119,15 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
     }
     
     // MARK: - Initializers
-    
+
+    /// Creates a `Graph` without nodes.
     init () {
         nodes = []
         adjacents = [:]
     }
-    
+
+    /// Creates a `Graph` with the given `nodes` and `adjacents`, describing how the given `nodes`
+    /// are connected.
     init (_ nodes: Set<Node>, _ adjacents: [Pair: Weight]) {
         self.nodes = nodes
         self.adjacents = adjacents
-- 
2.17.2 (Apple Git-113)


From 7ea108fa6481853ca5a610332f343ff3d925efc9 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:33:30 -0400
Subject: [PATCH 06/66] Move Graph initializers to extension

---
 .../PitchSpeller/Wetherfield/Data Structures/Graph.swift     | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index 36d205b..f37d43e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -117,7 +117,10 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
             return Edge(source, $0, withWeight: weight)
         }
     }
-    
+}
+
+extension Graph {
+
     // MARK: - Initializers
 
     /// Creates a `Graph` without nodes.
-- 
2.17.2 (Apple Git-113)


From 05e53325ef1d3c2bee5e2a398779f7f8c2220d78 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:35:09 -0400
Subject: [PATCH 07/66] Move Graph computed properties and instance methods
 into extensions

---
 .../Wetherfield/Data Structures/Graph.swift   | 167 +++++++++---------
 1 file changed, 87 insertions(+), 80 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index f37d43e..16d1606 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -33,30 +33,102 @@ enum WithoutWeights: Unweighted {
 struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashable>
     where Pair.A: Hashable
 {
-
     // MARK: - Instance Properties
      
     var nodes: Set<Node>
     var adjacents: [Pair: Weight]
-    
+}
+
+extension Graph {
+
+    // MARK: - Type Aliases
+
+    typealias Node = Pair.A
+}
+
+extension Graph {
+
+    // MARK: - Nested Types
+
+    struct Edge {
+
+        // MARK: - Instance Properties
+
+        let nodes: Pair
+        let weight: Weight
+
+        // MARK: - Initializers
+
+        init (_ a: Graph.Node, _ b: Graph.Node, withWeight weight: Weight) {
+            self.nodes = Pair(a, b)
+            self.weight = weight
+        }
+
+        init (_ nodes: Pair, withWeight weight: Weight) {
+            self.nodes = nodes
+            self.weight = weight
+        }
+    }
+
+    struct Path {
+
+        // MARK: - Instance Properties
+
+        let nodes: [Node]
+        let weights: [Pair: Weight]
+
+        // MARK: - Initializers
+
+        init (_ nodes: [Node], _ weights: [Pair: Weight]) {
+            self.nodes = nodes
+            self.weights = weights
+        }
+    }
+}
+
+extension Graph {
+
+    // MARK: - Initializers
+
+    /// Creates a `Graph` without nodes.
+    init () {
+        nodes = []
+        adjacents = [:]
+    }
+
+    /// Creates a `Graph` with the given `nodes` and `adjacents`, describing how the given `nodes`
+    /// are connected.
+    init (_ nodes: Set<Node>, _ adjacents: [Pair: Weight]) {
+        self.nodes = nodes
+        self.adjacents = adjacents
+    }
+}
+
+extension Graph {
+
+    // MARK: - Computed Properties
+
     var edges: [Edge] {
         return adjacents.map(Edge.init)
     }
-    
+}
+
+extension Graph {
+
     // MARK: - Instance Methods
-    
+
     mutating func insertNode (_ node: Node) {
         nodes.insert(node)
     }
-    
+
     mutating func insertEdge (from source: Node, to destination: Node, withWeight weight: Weight) {
         adjacents[Pair(source, destination)] = weight
     }
-    
+
     mutating func insertEdge (_ keyValue: (Pair, Weight)) {
         insertEdge(from: keyValue.0.a, to: keyValue.0.b, withWeight: keyValue.1)
     }
-    
+
     mutating func insertEdge(_ pair: Pair, _ weight: Weight) {
         insertEdge(from: pair.a, to: pair.b, withWeight: weight)
     }
@@ -65,21 +137,21 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
         guard let weight = weight(pair) else { return }
         insertEdge(pair, transform(weight))
     }
-    
+
     mutating func insertPath (_ path: Path) {
         path.nodes.forEach { insertNode($0) }
         path.weights.forEach { insertEdge($0) }
     }
-    
+
     mutating func removeEdge (from source: Node, to destination: Node) {
         adjacents[Pair(source, destination)] = nil
     }
-    
+
     /// - Returns: `true` if the graph contains this `node`, else `false`
     func contains (_ node: Node) -> Bool {
         return nodes.contains(node)
     }
-    
+
     /// - Returns: `true` if `edge.nodes` are adjacent in the graph, else `false`
     func contains (_ edge: Pair) -> Bool {
         return adjacents.keys.contains(edge)
@@ -89,7 +161,7 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
     func weight (from source: Node, to destination: Node) -> Weight? {
         return weight(Pair(source, destination))
     }
-    
+
     /// - Returns: Weight of the edge containing this `pair` of nodes if it exists, else nil
     func weight (_ pair: Pair) -> Weight? {
         return adjacents[pair]
@@ -99,17 +171,17 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
     func neighbors (of source: Node) -> [Node] {
         return nodes.filter { adjacents.keys.contains(Pair(source, $0)) }
     }
-    
+
     /// - Returns: Array of nodes adjacent to `source` out of the supplied array of `nodes`.
     func neighbors (of source: Node, from nodes: [Node]) -> [Node] {
         return neighbors(of: source, from: Set(nodes))
     }
-    
+
     /// - Returns: Array of nodes adjacent to `source` out of the supplied set of `nodes`.
     func neighbors (of source: Node, from nodes: Set<Node>) -> [Node] {
         return nodes.filter { adjacents.keys.contains(Pair(source, $0)) }
     }
-    
+
     /// - Returns: Array of edges emanating from `source`
     func edges (from source: Node) -> [Edge] {
         return nodes.compactMap {
@@ -119,71 +191,6 @@ struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashabl
     }
 }
 
-extension Graph {
-
-    // MARK: - Initializers
-
-    /// Creates a `Graph` without nodes.
-    init () {
-        nodes = []
-        adjacents = [:]
-    }
-
-    /// Creates a `Graph` with the given `nodes` and `adjacents`, describing how the given `nodes`
-    /// are connected.
-    init (_ nodes: Set<Node>, _ adjacents: [Pair: Weight]) {
-        self.nodes = nodes
-        self.adjacents = adjacents
-    }
-}
-
-extension Graph {
-
-    // MARK: - Type Aliases
-
-    typealias Node = Pair.A
-}
-
-extension Graph {
-
-    // MARK: - Nested Types
-
-    struct Edge {
-
-        // MARK: - Instance Properties
-
-        let nodes: Pair
-        let weight: Weight
-
-        // MARK: - Initializers
-
-        init (_ a: Graph.Node, _ b: Graph.Node, withWeight weight: Weight) {
-            self.nodes = Pair(a, b)
-            self.weight = weight
-        }
-
-        init (_ nodes: Pair, withWeight weight: Weight) {
-            self.nodes = nodes
-            self.weight = weight
-        }
-    }
-
-    struct Path {
-
-        // MARK: - Instance Properties
-
-        let nodes: [Node]
-        let weights: [Pair: Weight]
-
-        // MARK: - Initializers
-
-        init (_ nodes: [Node], _ weights: [Pair: Weight]) {
-            self.nodes = nodes
-            self.weights = weights
-        }
-    }
-}
-
 extension Graph where Weight == WithoutWeights {
     
     // MARK: - Instance Methods
-- 
2.17.2 (Apple Git-113)


From 188f4c789649b6b125092809aad981450e7b0c97 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:36:50 -0400
Subject: [PATCH 08/66] Remove unused DirectedEdge and UndirectedEdge

---
 .../Data Structures/DirectedEdge.swift        | 30 -------------------
 .../Data Structures/UndirectedEdge.swift      | 30 -------------------
 2 files changed, 60 deletions(-)
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/DirectedEdge.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UndirectedEdge.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/DirectedEdge.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/DirectedEdge.swift
deleted file mode 100644
index d5ba60c..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/DirectedEdge.swift	
+++ /dev/null
@@ -1,30 +0,0 @@
-//
-//  DirectedEdge.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-public struct DirectedEdge <Node,Weight>: EdgeLike {
-
-    // MARK: - Associated Types
-
-    typealias Pair = OrderedPair<Node>
-
-    // MARK: - Instance Properties
-
-    var weight: Weight
-    let nodes: Pair
-
-    // MARK: - Initializers
-    
-    init (_ source: Node, _ destination: Node, _ weight: Weight) {
-        self.nodes = Pair(source, destination)
-        self.weight = weight
-    }
-    
-    init (_ nodes: Pair, _ weight: Weight) {
-        self.nodes = nodes
-        self.weight = weight
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UndirectedEdge.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UndirectedEdge.swift
deleted file mode 100644
index 8b10c70..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UndirectedEdge.swift	
+++ /dev/null
@@ -1,30 +0,0 @@
-//
-//  UndirectedEdge.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-public struct UndirectedEdge <Node,Weight>: EdgeLike {
-
-    // MARK: - Associated Types
-
-    typealias Pair = UnorderedPair<Node>
-
-    // MARK: - Instance Properties
-
-    var weight: Weight
-    let nodes: Pair
-
-    // MARK: - Initializers
-    
-    init (_ source: Node, _ destination: Node, _ weight: Weight) {
-        self.nodes = Pair(source, destination)
-        self.weight = weight
-    }
-    
-    init (_ nodes: Pair, _ weight: Weight) {
-        self.nodes = nodes
-        self.weight = weight
-    }
-}
-- 
2.17.2 (Apple Git-113)


From 7e28d4e50f032632ba0228b12682fd95b1c56b76 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:37:40 -0400
Subject: [PATCH 09/66] Add TODO

---
 .../PitchSpeller/Wetherfield/Data Structures/Cross.swift         | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift
index 206d7bb..982a5df 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift	
@@ -5,6 +5,7 @@
 //  Created by Benjamin Wetherfield on 6/30/18.
 //
 
+/// - TODO: Move to `dn-m/Structure/DataStructures`
 struct Cross<T,U>: Pair {
     
     typealias A = T
-- 
2.17.2 (Apple Git-113)


From fbaf2a03730420ee12359d1069c1a9ba139af913 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:37:55 -0400
Subject: [PATCH 10/66] Refine // MARK:

---
 .../PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift
index 1caec82..1df2a5b 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift	
@@ -5,7 +5,7 @@
 //  Created by James Bean on 5/24/18.
 //
 
-// MARK: typealiases
+// MARK: Type Aliases
 typealias DirectedGraph<Node: Hashable> = Graph<Double, DirectedOver<Node>>
 typealias UnweightedGraph<Node: Hashable> = Graph<WithoutWeights, DirectedOver<Node>>
 
-- 
2.17.2 (Apple Git-113)


From e7ea1d0afeb9f3b4f41b3c8da14193e94785f90c Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:53:11 -0400
Subject: [PATCH 11/66] Split up Graph modifying and querying methods

---
 .../PitchSpeller/Wetherfield/Data Structures/Graph.swift   | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index 16d1606..880cbc9 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -115,7 +115,7 @@ extension Graph {
 
 extension Graph {
 
-    // MARK: - Instance Methods
+    // MARK: - Modifying a `Graph`
 
     mutating func insertNode (_ node: Node) {
         nodes.insert(node)
@@ -146,6 +146,11 @@ extension Graph {
     mutating func removeEdge (from source: Node, to destination: Node) {
         adjacents[Pair(source, destination)] = nil
     }
+}
+
+extension Graph {
+
+    // MARK: - Querying a `Graph`
 
     /// - Returns: `true` if the graph contains this `node`, else `false`
     func contains (_ node: Node) -> Bool {
-- 
2.17.2 (Apple Git-113)


From 5321d016aa6982e0906d0ad3cf4c1de6aa88fc3e Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 16:54:25 -0400
Subject: [PATCH 12/66] Add doc comment

---
 .../PitchSpeller/Wetherfield/Data Structures/Graph.swift      | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index 880cbc9..cd7576e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -108,6 +108,10 @@ extension Graph {
 
     // MARK: - Computed Properties
 
+    /// - Returns: All of the `Edge` values contained herein.
+    ///
+    /// - TODO: Consider returning a `Set` instead of an `Array`, as order does not have
+    /// significance.
     var edges: [Edge] {
         return adjacents.map(Edge.init)
     }
-- 
2.17.2 (Apple Git-113)


From 6efe661a471d9c4593c2e1dc030ec8bd2ab32249 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Fri, 21 Sep 2018 17:03:25 -0400
Subject: [PATCH 13/66] Add doc comments, add tuple labels

---
 .../Wetherfield/Data Structures/Graph.swift   | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
index cd7576e..d6d5380 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
@@ -110,7 +110,7 @@ extension Graph {
 
     /// - Returns: All of the `Edge` values contained herein.
     ///
-    /// - TODO: Consider returning a `Set` instead of an `Array`, as order does not have
+    /// - Remark: Consider returning a `Set` instead of an `Array`, as order does not have
     /// significance.
     var edges: [Edge] {
         return adjacents.map(Edge.init)
@@ -121,32 +121,45 @@ extension Graph {
 
     // MARK: - Modifying a `Graph`
 
+    /// Inserts the given `node` into the `Graph`.
     mutating func insertNode (_ node: Node) {
         nodes.insert(node)
     }
 
+    /// Connects the `source` node to the `destination` with the given `weight`.
+    ///
+    /// - Remark: We should consider only exposing this for weighted graphs.
     mutating func insertEdge (from source: Node, to destination: Node, withWeight weight: Weight) {
         adjacents[Pair(source, destination)] = weight
     }
 
-    mutating func insertEdge (_ keyValue: (Pair, Weight)) {
-        insertEdge(from: keyValue.0.a, to: keyValue.0.b, withWeight: keyValue.1)
+    /// Inserts the given pair-value pair into the `Graph`.
+    mutating func insertEdge (_ pairAndWeight: (pair: Pair, weight: Weight)) {
+        insertEdge(pairAndWeight.pair, pairAndWeight.weight)
     }
 
+    /// Insert an `Edge` between the given `pair` with the given `weight`.
+    ///
+    /// - Remark: We should consider only exposing this for weighted graphs.
     mutating func insertEdge(_ pair: Pair, _ weight: Weight) {
         insertEdge(from: pair.a, to: pair.b, withWeight: weight)
     }
 
+    /// Updates the weight of the edge connecting the given `pair`.
+    ///
+    /// > If the nodes in the given `pair` do not exist, or are no connected, no action is taken.
     mutating func updateEdge(_ pair: Pair, with transform: (Weight) -> Weight) {
         guard let weight = weight(pair) else { return }
         insertEdge(pair, transform(weight))
     }
 
+    /// Inserts the given `path` into the `Graph`.
     mutating func insertPath (_ path: Path) {
         path.nodes.forEach { insertNode($0) }
         path.weights.forEach { insertEdge($0) }
     }
 
+    /// Removes the edge between the given `source` and `destination` nodes.
     mutating func removeEdge (from source: Node, to destination: Node) {
         adjacents[Pair(source, destination)] = nil
     }
-- 
2.17.2 (Apple Git-113)


From 2159971541e52ba3f6b018e8772046dbea985963 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sat, 29 Sep 2018 13:50:57 -0700
Subject: [PATCH 14/66] Push down Graph to dn-m/Structure/DataStructures

Push down Graph to dn-m/Structure/DataStructures
---
 .../Wetherfield/Data Structures/Cross.swift   |  29 --
 .../Data Structures/EdgeLike.swift            |  14 -
 .../Data Structures/FlowNetwork.swift         | 111 ------
 .../Wetherfield/Data Structures/Graph.swift   | 348 ------------------
 .../Data Structures/NodePair.swift            |  21 --
 .../Data Structures/OrderedPair.swift         |  34 --
 .../Wetherfield/Data Structures/Pair.swift    |  23 --
 .../Wetherfield/Data Structures/Queue.swift   |  45 ---
 .../Data Structures/SwappablePair.swift       |  14 -
 .../Data Structures/SymmetricPair.swift       |   8 -
 .../Data Structures/UnorderedPair.swift       |  45 ---
 .../Data Structures/Weighted.swift            |  17 -
 .../Wetherfield/FlowNetwork.swift             | 135 +++++++
 .../Wetherfield/Wetherfield.swift             |  25 +-
 14 files changed, 150 insertions(+), 719 deletions(-)
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift
deleted file mode 100644
index 982a5df..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift	
+++ /dev/null
@@ -1,29 +0,0 @@
-//
-//  Cross.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-/// - TODO: Move to `dn-m/Structure/DataStructures`
-struct Cross<T,U>: Pair {
-    
-    typealias A = T
-    typealias B = U
-    
-    let a: T
-    let b: U
-    
-    init(_ a: A, _ b: B) {
-        self.a = a
-        self.b = b
-    }
-    
-    init(_ pair: (A, B)) {
-        self.a = pair.0
-        self.b = pair.1
-    }
-}
-
-extension Cross: Equatable where T: Equatable, U: Equatable { }
-extension Cross: Hashable where T: Hashable, U: Hashable { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift
deleted file mode 100644
index fc345cb..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift	
+++ /dev/null
@@ -1,14 +0,0 @@
-//
-//  EdgeLike.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-protocol EdgeLike: Weighted & NodePair {
-    init(_ nodes: Pair, _ weight: Weight)
-}
-
-extension EdgeLike where Pair: SwappablePair {
-    var reversed: Self { return Self(nodes.swapped, weight) }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift
deleted file mode 100644
index 1df2a5b..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift	
+++ /dev/null
@@ -1,111 +0,0 @@
-//
-//  FlowNetwork.swift
-//  PitchSpeller
-//
-//  Created by James Bean on 5/24/18.
-//
-
-// MARK: Type Aliases
-typealias DirectedGraph<Node: Hashable> = Graph<Double, DirectedOver<Node>>
-typealias UnweightedGraph<Node: Hashable> = Graph<WithoutWeights, DirectedOver<Node>>
-
-/// Directed Graph with several properties:
-/// - Each edge has a capacity for flow
-/// - A "source" node, which is only emanates flow outward
-/// - A "sink" node, which only receives flow
-public struct FlowNetwork <Node: Hashable> {
-    
-    typealias DirectedPath = DirectedGraph<Node>.Path
-    typealias DirectedEdge = DirectedGraph<Node>.Edge
-
-    /// - Returns: All of the `Node` values contained herein which are neither the `source` nor
-    /// the `sink`.
-    public var internalNodes: [Node] {
-        return directedGraph.nodes.filter { $0 != source && $0 != sink }
-    }
-    
-    /// - Returns: (0) The maximum flow of the network and (1) the residual network produced after
-    /// pushing all possible flow from source to sink (while satisfying flow constraints) - with
-    /// saturated edges flipped and all weights removed.
-    var solvedForMaximumFlow: (flow: Double, network: UnweightedGraph<Node>) {
-        var residualNetwork = directedGraph
-        
-        func findAugmentingPath () -> Bool {
-            guard let path = residualNetwork.shortestUnweightedPath(from: source, to: sink) else {
-                return false
-            }
-            pushFlow(through: path)
-            return true
-        }
-            
-        func pushFlow (through path: UnweightedGraph<Node>.Path) {
-            let minimumEdge = (path.adjacents.compactMap(residualNetwork.weight).min())!
-            path.adjacents.forEach { edge in
-                residualNetwork.updateEdge(edge, with: { capacity in capacity - minimumEdge })
-                if residualNetwork.weight(edge)! == 0.0 {
-                    residualNetwork.removeEdge(from: edge.a, to: edge.b)
-                }
-                if residualNetwork.contains(edge.swapped) {
-                    residualNetwork.updateEdge(edge.swapped, with: { capacity in capacity + minimumEdge })
-                }
-                else { residualNetwork.insertEdge(edge.swapped, minimumEdge) }
-            }
-        }
-        
-        func computeFlow () -> Double {
-            let sourceEdges = directedGraph.neighbors(of: source).lazy
-                .map { OrderedPair(self.source, $0) }
-                .partition(residualNetwork.contains)
-            let edgesPresent = sourceEdges.whereTrue.lazy
-                .map { self.directedGraph.weight($0)! - residualNetwork.weight($0)! }
-                .reduce(0.0, +)
-            let edgesAbsent = sourceEdges.whereFalse.lazy
-                .compactMap(directedGraph.weight)
-                .reduce(0.0, +)
-            return edgesPresent + edgesAbsent
-        }
-        
-        while findAugmentingPath() { continue }
-        return (computeFlow(), residualNetwork.unweighted)
-    }
-    
-    /// - Returns: A minimum cut with nodes included on the `sink` side in case of a
-    /// tiebreak (in- and out- edges saturated).
-    public var minimumCut: (Set<Node>, Set<Node>) {
-        return (sourceSideNodes, notSourceSideNodes)
-    }
-    
-    /// - Returns: Nodes in residual network reachable from the `source`
-    private var sourceSideNodes: Set<Node> {
-        return Set(solvedForMaximumFlow.network.breadthFirstSearch(from: source))
-    }
-    
-    /// - Returns: Nodes in residual network *not* reachable from the `source`
-    private var notSourceSideNodes: Set<Node> {
-        return solvedForMaximumFlow.network.nodes.subtracting(sourceSideNodes)
-    }
-
-    // TODO: Consider more (space-)efficient storage of Nodes.
-    internal var directedGraph: DirectedGraph<Node>
-    internal var source: Node
-    internal var sink: Node
-
-    // MARK: - Initializers
-    
-    /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
-    init(_ directedGraph: DirectedGraph<Node>, source: Node, sink: Node) {
-        self.directedGraph = directedGraph
-        self.source = source
-        self.sink = sink
-    }
-}
-
-extension Sequence {
-    func filterComplement (_ predicate: (Element) -> Bool) -> [Element] {
-        return filter { !predicate($0) }
-    }
-    
-    func partition (_ predicate: (Element) -> Bool) -> (whereFalse: [Element], whereTrue: [Element]) {
-        return (filterComplement(predicate), filter(predicate))
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
deleted file mode 100644
index d6d5380..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ /dev/null
@@ -1,348 +0,0 @@
-//
-//  Graph.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/14/18.
-//
-
-// MARK: - Directedness Flags
-
-protocol Directedness { }
-protocol Directed: Directedness { }
-protocol Undirected: Directedness { }
-
-typealias DirectedOver = OrderedPair
-extension DirectedOver: Directed { }
-
-typealias UndirectedOver = UnorderedPair
-extension UndirectedOver: Undirected { }
-
-// MARK: - Weightedness Flags
-
-protocol Weightedness { }
-protocol Unweighted: Weightedness { }
-protocol AsWeight: Weightedness { }
-
-// Allows Double to be used as an edge weight
-extension Double: AsWeight { }
-enum WithoutWeights: Unweighted {
-    case unweighted
-}
-
-// Weightable, directable implementation of a Graph structure.
-struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashable>
-    where Pair.A: Hashable
-{
-    // MARK: - Instance Properties
-     
-    var nodes: Set<Node>
-    var adjacents: [Pair: Weight]
-}
-
-extension Graph {
-
-    // MARK: - Type Aliases
-
-    typealias Node = Pair.A
-}
-
-extension Graph {
-
-    // MARK: - Nested Types
-
-    struct Edge {
-
-        // MARK: - Instance Properties
-
-        let nodes: Pair
-        let weight: Weight
-
-        // MARK: - Initializers
-
-        init (_ a: Graph.Node, _ b: Graph.Node, withWeight weight: Weight) {
-            self.nodes = Pair(a, b)
-            self.weight = weight
-        }
-
-        init (_ nodes: Pair, withWeight weight: Weight) {
-            self.nodes = nodes
-            self.weight = weight
-        }
-    }
-
-    struct Path {
-
-        // MARK: - Instance Properties
-
-        let nodes: [Node]
-        let weights: [Pair: Weight]
-
-        // MARK: - Initializers
-
-        init (_ nodes: [Node], _ weights: [Pair: Weight]) {
-            self.nodes = nodes
-            self.weights = weights
-        }
-    }
-}
-
-extension Graph {
-
-    // MARK: - Initializers
-
-    /// Creates a `Graph` without nodes.
-    init () {
-        nodes = []
-        adjacents = [:]
-    }
-
-    /// Creates a `Graph` with the given `nodes` and `adjacents`, describing how the given `nodes`
-    /// are connected.
-    init (_ nodes: Set<Node>, _ adjacents: [Pair: Weight]) {
-        self.nodes = nodes
-        self.adjacents = adjacents
-    }
-}
-
-extension Graph {
-
-    // MARK: - Computed Properties
-
-    /// - Returns: All of the `Edge` values contained herein.
-    ///
-    /// - Remark: Consider returning a `Set` instead of an `Array`, as order does not have
-    /// significance.
-    var edges: [Edge] {
-        return adjacents.map(Edge.init)
-    }
-}
-
-extension Graph {
-
-    // MARK: - Modifying a `Graph`
-
-    /// Inserts the given `node` into the `Graph`.
-    mutating func insertNode (_ node: Node) {
-        nodes.insert(node)
-    }
-
-    /// Connects the `source` node to the `destination` with the given `weight`.
-    ///
-    /// - Remark: We should consider only exposing this for weighted graphs.
-    mutating func insertEdge (from source: Node, to destination: Node, withWeight weight: Weight) {
-        adjacents[Pair(source, destination)] = weight
-    }
-
-    /// Inserts the given pair-value pair into the `Graph`.
-    mutating func insertEdge (_ pairAndWeight: (pair: Pair, weight: Weight)) {
-        insertEdge(pairAndWeight.pair, pairAndWeight.weight)
-    }
-
-    /// Insert an `Edge` between the given `pair` with the given `weight`.
-    ///
-    /// - Remark: We should consider only exposing this for weighted graphs.
-    mutating func insertEdge(_ pair: Pair, _ weight: Weight) {
-        insertEdge(from: pair.a, to: pair.b, withWeight: weight)
-    }
-
-    /// Updates the weight of the edge connecting the given `pair`.
-    ///
-    /// > If the nodes in the given `pair` do not exist, or are no connected, no action is taken.
-    mutating func updateEdge(_ pair: Pair, with transform: (Weight) -> Weight) {
-        guard let weight = weight(pair) else { return }
-        insertEdge(pair, transform(weight))
-    }
-
-    /// Inserts the given `path` into the `Graph`.
-    mutating func insertPath (_ path: Path) {
-        path.nodes.forEach { insertNode($0) }
-        path.weights.forEach { insertEdge($0) }
-    }
-
-    /// Removes the edge between the given `source` and `destination` nodes.
-    mutating func removeEdge (from source: Node, to destination: Node) {
-        adjacents[Pair(source, destination)] = nil
-    }
-}
-
-extension Graph {
-
-    // MARK: - Querying a `Graph`
-
-    /// - Returns: `true` if the graph contains this `node`, else `false`
-    func contains (_ node: Node) -> Bool {
-        return nodes.contains(node)
-    }
-
-    /// - Returns: `true` if `edge.nodes` are adjacent in the graph, else `false`
-    func contains (_ edge: Pair) -> Bool {
-        return adjacents.keys.contains(edge)
-    }
-
-    /// - Returns: Weight of the edge from `source` to `destination` if it exists, else nil
-    func weight (from source: Node, to destination: Node) -> Weight? {
-        return weight(Pair(source, destination))
-    }
-
-    /// - Returns: Weight of the edge containing this `pair` of nodes if it exists, else nil
-    func weight (_ pair: Pair) -> Weight? {
-        return adjacents[pair]
-    }
-
-    /// - Returns: Array of nodes adjacent to `source`
-    func neighbors (of source: Node) -> [Node] {
-        return nodes.filter { adjacents.keys.contains(Pair(source, $0)) }
-    }
-
-    /// - Returns: Array of nodes adjacent to `source` out of the supplied array of `nodes`.
-    func neighbors (of source: Node, from nodes: [Node]) -> [Node] {
-        return neighbors(of: source, from: Set(nodes))
-    }
-
-    /// - Returns: Array of nodes adjacent to `source` out of the supplied set of `nodes`.
-    func neighbors (of source: Node, from nodes: Set<Node>) -> [Node] {
-        return nodes.filter { adjacents.keys.contains(Pair(source, $0)) }
-    }
-
-    /// - Returns: Array of edges emanating from `source`
-    func edges (from source: Node) -> [Edge] {
-        return nodes.compactMap {
-            guard let weight = adjacents[Pair(source, $0)] else { return nil }
-            return Edge(source, $0, withWeight: weight)
-        }
-    }
-}
-
-extension Graph where Weight == WithoutWeights {
-    
-    // MARK: - Instance Methods
-    
-    mutating func insertEdge (from source: Node, to destination: Node) {
-        insertEdge(from: source, to: destination, withWeight: .unweighted)
-    }
-    
-    mutating func insertPath (_ nodes: [Graph.Node]) {
-        insertPath(Path(nodes))
-    }
-}
-
-extension Graph where Weight: AsWeight {
-    
-    // MARK: - Instance Methods
-    
-    static func unWeightedVersion (of weightedGraph: Graph) -> Graph<WithoutWeights, Pair> {
-        let adjacents: [Pair: WithoutWeights] = weightedGraph.adjacents.mapValues { _ in .unweighted }
-        return Graph<WithoutWeights, Pair>(weightedGraph.nodes, adjacents)
-    }
-    
-    var unweighted: Graph<WithoutWeights,Pair> {
-        return .init(nodes, adjacents.mapValues { _ in .unweighted })
-    }
-}
-
-extension Graph.Edge where Weight == WithoutWeights {
-    
-    // MARK: - Initializers
-    
-    init (_ a: Graph.Node, _ b: Graph.Node) {
-        self.nodes = Pair(a, b)
-        self.weight = .unweighted
-    }
-}
-
-extension Graph where Pair: SwappablePair {
-    
-    // MARK: - Instance Methods
-    
-    mutating func flipEdge (containing nodes: Pair) {
-        adjacents[nodes.swapped] = adjacents[nodes]
-        adjacents[nodes] = nil
-    }
-}
-
-extension Graph.Path where Weight == WithoutWeights {
-    
-    // MARK: - Instance properties
-    
-    var adjacents: Set<Pair> {
-        return Set(weights.keys)
-    }
-    
-    // MARK: - Initializers
-    
-    init (_ nodes: [Graph.Node]) {
-        let count = nodes.count
-        var weights: [Pair: Weight] = [:]
-        nodes.enumerated().forEach { index, currentNode in
-            if index <= count - 2 {
-                let nextNode = nodes[index + 1]
-                weights[Pair(currentNode, nextNode)] = .unweighted
-            }
-        }
-        self.init(nodes, weights)
-    }
-}
-
-extension Graph.Edge where Pair: Directed {
-    
-    // MARK: - Instance Properties
-    
-    var source: Graph.Node { return nodes.a }
-    var destination: Graph.Node { return nodes.b }
-}
-
-extension Graph {
-    
-    // MARK: = Typealiases
-    
-    typealias UnweightedPath = Graph<WithoutWeights, DirectedOver<Node>>.Path
-    
-    // MARK: - Instance Methods
-    
-    func shortestUnweightedPath (from source: Node, to destination: Node) -> UnweightedPath? {
-        
-        var breadcrumbs: [Node: Node] = [:]
-        
-        func backtrace () -> UnweightedPath {
-            var path = [destination]
-            var cursor = destination
-            while cursor != source {
-                path.insert(breadcrumbs[cursor]!, at: 0)
-                cursor = breadcrumbs[cursor]!
-            }
-            return UnweightedPath(path)
-        }
-        
-        if source == destination { return UnweightedPath([destination]) }
-        
-        var unvisited = nodes
-        var queue: Queue<Node> = []
-        
-        queue.push(source)
-        while !queue.isEmpty {
-            let node = queue.pop()
-            for neighbor in neighbors(of: node, from: unvisited) {
-                queue.push(neighbor)
-                unvisited.remove(neighbor)
-                breadcrumbs[neighbor] = node
-                if neighbor == destination { return backtrace() }
-            }
-        }
-        return nil
-    }
-    
-    internal func breadthFirstSearch(from source: Node) -> [Node] {
-        var visited: [Node] = []
-        var queue: Queue<Node> = []
-        queue.push(source)
-        visited.append(source)
-        while !queue.isEmpty {
-            let node = queue.pop()
-            for neighbor in neighbors(of: node) where !visited.contains(neighbor) {
-                queue.push(neighbor)
-                visited.append(neighbor)
-            }
-        }
-        return visited
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift
deleted file mode 100644
index 55b3f4f..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift	
+++ /dev/null
@@ -1,21 +0,0 @@
-//
-//  NodePair.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-protocol NodePair {
-    
-    // MARK: - Associated Types
-    
-    associatedtype Pair: SymmetricPair
-    
-    // MARK: - Typealiases
-    
-    typealias Node = Pair.A
-    
-    // MARK: - Instance Properties
-    
-    var nodes: Pair { get }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift
deleted file mode 100644
index b42d5cd..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift	
+++ /dev/null
@@ -1,34 +0,0 @@
-//
-//  OrderedPair.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-/// Pair of values for which the order matters.
-struct OrderedPair <T>: SwappablePair {
-
-    // MARK: - Instance Properties
-
-    let a: T
-    let b: T
-
-    // MARK: - Initializers
-
-    init(_ pair: (T, T)) {
-        self.a = pair.0
-        self.b = pair.1
-    }
-    
-    init(_ a: T, _ b: T) {
-        self.a = a
-        self.b = b
-    }
-}
-
-// MARK: - Equatable
-extension OrderedPair: Equatable where T: Equatable { }
-
-// MARK: - Hashable
-extension OrderedPair: Hashable where T: Hashable { }
-
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift
deleted file mode 100644
index 33172fd..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift	
+++ /dev/null
@@ -1,23 +0,0 @@
-//
-//  Pairable.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-protocol Pair {
-    
-    // MARK: - Associated Types
-    
-    associatedtype A
-    associatedtype B
-    
-    // MARK: - Instance Properties
-    
-    var a: A { get }
-    var b: B { get }
-    
-    // MARK: - Initializers
-    
-    init(_ a: A, _ b: B)
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift
deleted file mode 100644
index 604a62d..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift	
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-//  Queue.swift
-//  PitchSpeller
-//
-//  Created by James Bean on 5/29/18.
-//
-
-/// Queue.
-///
-/// - TODO: Move to dn-m/Structure/DataStructures
-public struct Queue <Element: Equatable> {
-
-    private var storage: [Element] = []
-
-    public var isEmpty: Bool {
-        return storage.isEmpty
-    }
-
-    public var count: Int {
-        return storage.count
-    }
-
-    public mutating func push(_ value: Element) {
-        storage.append(value)
-    }
-
-    public mutating func pop() -> Element {
-        return storage.remove(at: 0)
-    }
-
-    public func contains(_ value: Element) -> Bool {
-        if storage.index(of: value) != nil {
-            return true
-        }
-        return false
-    }
-}
-
-extension Queue: ExpressibleByArrayLiteral {
-
-    /// Create a `Queue` with an `ArrayLiteral`.
-    public init(arrayLiteral elements: Element...) {
-        self.storage = elements
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift
deleted file mode 100644
index aa409e7..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift	
+++ /dev/null
@@ -1,14 +0,0 @@
-//
-//  Swappable.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-protocol SwappablePair: SymmetricPair {
-    var swapped: Self { get }
-}
-
-extension SwappablePair {
-    var swapped: Self { return .init(b, a) }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift
deleted file mode 100644
index 61abe21..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift	
+++ /dev/null
@@ -1,8 +0,0 @@
-//
-//  Symmetric.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-protocol SymmetricPair: Pair where A == B { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift
deleted file mode 100644
index ac8584a..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift	
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-//  UnorderedPair.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-struct UnorderedPair<T>: SymmetricPair {
-    
-    typealias A = T
-    
-    let a: T
-    let b: T
-    
-    init(_ pair: (T, T)) {
-        self.a = pair.0
-        self.b = pair.1
-    }
-    
-    init(_ a: T, _ b: T) {
-        self.a = a
-        self.b = b
-    }
-}
-
-extension UnorderedPair: Equatable where T: Equatable {
-
-    // MARK: - Equatable
-
-    /// - Returns: `true` if both values contained by the given `UnorderedPair` values are
-    /// equivalent, regardless of order. Otherwise, `false`.
-    static func == (_ lhs: UnorderedPair, _ rhs: UnorderedPair) -> Bool {
-        return (lhs.a == rhs.a && lhs.b == rhs.b) || (lhs.a == rhs.b && lhs.b == rhs.a)
-    }
-}
-
-extension UnorderedPair: Hashable where T: Hashable {
-
-    // MARK: - Hashable
-
-    /// Implements hashable requirement.
-    func hash(into hasher: inout Hasher) {
-        return Set([a,b]).hash(into: &hasher)
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift
deleted file mode 100644
index 595772e..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift	
+++ /dev/null
@@ -1,17 +0,0 @@
-//
-//  Weighted.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-protocol Weighted {
-    
-    // MARK: - Associated Types
-    
-    associatedtype Weight
-    
-    // MARK: - Instance Properties
-    
-    var weight: Weight { get set }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
new file mode 100644
index 0000000..cf246c2
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -0,0 +1,135 @@
+//
+//  FlowNetwork.swift
+//  PitchSpeller
+//
+//  Created by James Bean on 5/24/18.
+//
+
+import DataStructures
+
+/// Directed graph with several properties:
+/// - Each edge has a capacity for flow
+/// - A "source" node, which is only emanates flow outward
+/// - A "sink" node, which only receives flow
+public struct FlowNetwork <Node: Hashable, Weight: Numeric & Comparable> {
+
+    // MARK: - Instance Properties
+
+    var directedGraph: WeightedDirectedGraph<Node,Weight>
+    var source: Node
+    var sink: Node
+}
+
+extension FlowNetwork {
+
+    // MARK: - Initializers
+
+    /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
+    init(_ directedGraph: WeightedDirectedGraph<Node,Weight>, source: Node, sink: Node) {
+        self.directedGraph = directedGraph
+        self.source = source
+        self.sink = sink
+    }
+}
+
+extension WeightedDirectedGraph where Weight: Comparable {
+    // TODO: Make throw
+    mutating func reduceFlow(through edge: Edge, by amount: Weight) {
+        updateEdge(edge) { weight in weight - amount }
+    }
+
+    /// Removes the given edge if its weight is `0`. This happens after an edge, which has the
+    /// minimum flow of an augmenting path, is reduced by the minimum flow (which is its previous
+    /// value).
+    mutating func removeEdgeIfFlowless(_ edge: Edge) {
+        if weight(edge) == 0 {
+            removeEdge(edge)
+        }
+    }
+
+    /// Inserts an edge in the opposite direction of the given `edge` with the minimum flow
+    mutating func updateBackEdge(_ edge: Edge, by minimumFlow: Weight) {
+        let reversedEdge = edge.swapped
+        if contains(reversedEdge) {
+            updateEdge(reversedEdge) { capacity in capacity + minimumFlow }
+        } else {
+            insertEdge(reversedEdge, weight: minimumFlow)
+        }
+    }
+
+    /// Reduces the flow of the given `edge` by the given `minimumFlow`. If the new flow through
+    /// the `edge` is now `0`, removes the `edge` from the network. Updates the reverse of the given
+    /// `edge` by the given `minimumFlow`.
+    mutating func pushFlow(through edge: Edge, by minimumFlow: Weight) {
+        reduceFlow(through: edge, by: minimumFlow)
+        removeEdgeIfFlowless(edge)
+        updateBackEdge(edge, by: minimumFlow)
+    }
+
+    /// Pushes flow through the given `path` in this `graph`.
+    mutating func pushFlow(through path: [Node]) {
+        let edges = path.pairs.map(OrderedPair.init)
+        let minimumFlow = edges.compactMap(weight).min() ?? 0
+        edges.forEach { edge in pushFlow(through: edge, by: minimumFlow) }
+    }
+}
+
+extension FlowNetwork {
+
+    // MARK: - Computed Properties
+
+    /// - Returns: All of the `Node` values contained herein which are neither the `source` nor
+    /// the `sink`.
+    public var internalNodes: [Node] {
+        return directedGraph.nodes.filter { $0 != source && $0 != sink }
+    }
+
+    /// - Returns: A minimum cut with nodes included on the `sink` side in case of a
+    /// tiebreak (in- and out- edges saturated).
+    public var minimumCut: (Set<Node>, Set<Node>) {
+        let (_, residualNetwork) = maximumFlowAndResidualNetwork
+        let sourceSideNodes = Set(residualNetwork.breadthFirstSearch(from: source))
+        let notSourceSideNodes = residualNetwork.nodes.subtracting(sourceSideNodes)
+        return (sourceSideNodes, notSourceSideNodes)
+    }
+
+    /// - Returns: (0) The maximum flow of the network and (1) the residual network produced after
+    /// pushing all possible flow from source to sink (while satisfying flow constraints) - with
+    /// saturated edges flipped and all weights removed.
+    var maximumFlowAndResidualNetwork: (flow: Weight, network: DirectedGraph<Node>) {
+        // Make a copy of the directed representation of the network to be mutated by pushing flow
+        // through it.
+        var residualNetwork = directedGraph
+        // While an augmenting path (a path emanating directionally from the source node) can be
+        // found, push flow through the path, mutating the residual network
+        while let augmentingPath = residualNetwork.shortestUnweightedPath(from: source, to: sink) {
+            residualNetwork.pushFlow(through: augmentingPath)
+        }
+        // Compares the edges in the mutated residual network against the original directed
+        // graph.
+        let flow: Weight = {
+            let sourceEdges = directedGraph.neighbors(of: source).lazy
+                .map { OrderedPair(self.source, $0) }
+                .partition(residualNetwork.contains)
+            let edgesPresent = sourceEdges.whereTrue.lazy
+                .map { edge in self.directedGraph.weight(edge)! - residualNetwork.weight(edge)! }
+                .reduce(0,+)
+            let edgesAbsent = sourceEdges.whereFalse.lazy
+                .compactMap(directedGraph.weight)
+                .reduce(0,+)
+            return edgesPresent + edgesAbsent
+        }()
+        return (flow: flow, network: residualNetwork.unweighted())
+    }
+}
+
+extension Sequence {
+
+    func filterComplement (_ predicate: (Element) -> Bool) -> [Element] {
+        return filter { !predicate($0) }
+    }
+    
+    func partition (_ predicate: (Element) -> Bool) -> (whereFalse: [Element], whereTrue: [Element]) {
+        return (filterComplement(predicate), filter(predicate))
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 3e46d38..c61a1d5 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -5,6 +5,7 @@
 //  Created by James Bean on 5/23/18.
 //
 
+import DataStructures
 import Pitch
 
 protocol PitchSpellingNode: Hashable {
@@ -58,7 +59,7 @@ struct PitchSpeller {
     let pitchNodes: [Int]
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
-    let flowNetwork: FlowNetwork<Int>
+    let flowNetwork: FlowNetwork<Int,Double>
 
     // MARK: - Initializers
 
@@ -101,24 +102,28 @@ struct PitchSpeller {
     }
 }
 
-extension FlowNetwork where Node == Int {
+extension FlowNetwork where Node == Int, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
     init(source: Int, sink: Int, internalNodes: [Int]) {
-        let graph = DirectedGraph(source: source, sink: sink, internalNodes: internalNodes)
-        self.init(graph, source: -2, sink: -1)
+        let graph = WeightedDirectedGraph<Int,Double>(
+            source: source,
+            sink: sink,
+            internalNodes: internalNodes
+        )
+        self.init(graph, source: source, sink: sink)
     }
 }
 
-extension DirectedGraph where Pair.A == Int, Weight == Double {
+extension WeightedDirectedGraph {
     /// Create a `DirectedGraph` which is hooked up as necessary for the Wetherfield pitch-spelling process.
-    init (source: Int, sink: Int, internalNodes: [Int]) {
-        self.init(Set([source, sink] + internalNodes), [:])
+    init(source: Node, sink: Node, internalNodes: [Node]) {
+        self.init(Set([source,sink] + internalNodes))
         for node in internalNodes {
-            insertEdge(from: source, to: node, withWeight: 1)
-            insertEdge(from: node, to: sink, withWeight: 1)
+            insertEdge(from: source, to: node, weight: 1)
+            insertEdge(from: node, to: sink, weight: 1)
             for other in internalNodes.lazy.filter({ $0 != node }) {
-                insertEdge(from: node, to: other, withWeight: 1)
+                insertEdge(from: node, to: other, weight: 1)
             }
         }
     }
-- 
2.17.2 (Apple Git-113)


From 8dbb5fd137f070fb6947276daf6c417a0e8c42a8 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sun, 30 Sep 2018 22:53:07 -0400
Subject: [PATCH 15/66] Fix typo in doc comment

---
 Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index cf246c2..9d9efca 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -9,7 +9,7 @@ import DataStructures
 
 /// Directed graph with several properties:
 /// - Each edge has a capacity for flow
-/// - A "source" node, which is only emanates flow outward
+/// - A "source" node, which only emanates flow outward
 /// - A "sink" node, which only receives flow
 public struct FlowNetwork <Node: Hashable, Weight: Numeric & Comparable> {
 
-- 
2.17.2 (Apple Git-113)


From a4bf47b93b40e73800bc22f070309d5c1a5fab9a Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Mon, 1 Oct 2018 15:50:03 -0400
Subject: [PATCH 16/66]  Flow tests (#116)

---
 Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 9d9efca..9cb5a46 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -27,6 +27,8 @@ extension FlowNetwork {
     /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
     init(_ directedGraph: WeightedDirectedGraph<Node,Weight>, source: Node, sink: Node) {
         self.directedGraph = directedGraph
+        self.directedGraph.insert(source)
+        self.directedGraph.insert(sink)
         self.source = source
         self.sink = sink
     }
-- 
2.17.2 (Apple Git-113)


From e942dd4161a7a521fa0a87a00d00b777ad84f3ea Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Thu, 18 Oct 2018 10:39:56 -0400
Subject: [PATCH 17/66] Rename .sharp(Int) -> .sharp(count: Int)

---
 .../Wetherfield/Pitch.Spelling.Category.swift        | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 9e249f6..1513197 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -23,42 +23,42 @@ extension Pitch.Spelling {
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(2), .neutral: .natural, .up: .sharp(1)]
+                return [.down: .flat(2), .neutral: .natural, .up: .sharp(count: 1)]
             }
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(1), .neutral: .sharp(1), .up: .sharp(2)]
+                return [.down: .flat(1), .neutral: .sharp(count: 1), .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(2), .neutral: .natural, .up: .sharp(2)]
+                return [.down: .flat(2), .neutral: .natural, .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(2), .neutral: .flat(1), .up: .sharp(1)]
+                return [.down: .flat(2), .neutral: .flat(1), .up: .sharp(count: 1)]
             }
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(1), .neutral: .natural, .up: .sharp(2)]
+                return [.down: .flat(1), .neutral: .natural, .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(1), .up: .sharp(1)]
+                return [.down: .flat(1), .up: .sharp(count: 1)]
             }
         }
 
-- 
2.17.2 (Apple Git-113)


From 9ed2fa3bf3b4e79f23e4abcee41fb8eba7a99dba Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Thu, 18 Oct 2018 10:49:29 -0400
Subject: [PATCH 18/66] Rename .flat(Int) -> .flat(count: Int)

---
 .../Wetherfield/Pitch.Spelling.Category.swift        | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 1513197..29ccf06 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -23,42 +23,42 @@ extension Pitch.Spelling {
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(2), .neutral: .natural, .up: .sharp(count: 1)]
+                return [.down: .flat(count: 1), .neutral: .natural, .up: .sharp(count: 1)]
             }
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(1), .neutral: .sharp(count: 1), .up: .sharp(count: 2)]
+                return [.down: .flat(count: 1), .neutral: .sharp(count: 1), .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(2), .neutral: .natural, .up: .sharp(count: 2)]
+                return [.down: .flat(count: 1), .neutral: .natural, .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(2), .neutral: .flat(1), .up: .sharp(count: 1)]
+                return [.down: .flat(count: 1), .neutral: .flat(count: 1), .up: .sharp(count: 1)]
             }
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(1), .neutral: .natural, .up: .sharp(count: 2)]
+                return [.down: .flat(count: 1), .neutral: .natural, .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(1), .up: .sharp(count: 1)]
+                return [.down: .flat(count: 1), .up: .sharp(count: 1)]
             }
         }
 
-- 
2.17.2 (Apple Git-113)


From c080d27f075f2e41720ca0df1fe55ded34edea09 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Thu, 18 Oct 2018 10:51:42 -0400
Subject: [PATCH 19/66] Use .flat convenience static let

---
 .../Wetherfield/Pitch.Spelling.Category.swift        | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 29ccf06..2d2e4a0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -23,42 +23,42 @@ extension Pitch.Spelling {
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(count: 1), .neutral: .natural, .up: .sharp(count: 1)]
+                return [.down: .flat, .neutral: .natural, .up: .sharp(count: 1)]
             }
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(count: 1), .neutral: .sharp(count: 1), .up: .sharp(count: 2)]
+                return [.down: .flat, .neutral: .sharp(count: 1), .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(count: 1), .neutral: .natural, .up: .sharp(count: 2)]
+                return [.down: .flat, .neutral: .natural, .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(count: 1), .neutral: .flat(count: 1), .up: .sharp(count: 1)]
+                return [.down: .flat, .neutral: .flat, .up: .sharp(count: 1)]
             }
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(count: 1), .neutral: .natural, .up: .sharp(count: 2)]
+                return [.down: .flat, .neutral: .natural, .up: .sharp(count: 2)]
             }
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat(count: 1), .up: .sharp(count: 1)]
+                return [.down: .flat, .up: .sharp(count: 1)]
             }
         }
 
-- 
2.17.2 (Apple Git-113)


From 5925a378941a78aaec3def47e1269625f1d92f06 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Thu, 18 Oct 2018 11:03:10 -0400
Subject: [PATCH 20/66] Use .sharp / .flat in tests

---
 .../Wetherfield/Pitch.Spelling.Category.swift        | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 2d2e4a0..0eb47b2 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -23,42 +23,42 @@ extension Pitch.Spelling {
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharp(count: 1)]
+                return [.down: .flat, .neutral: .natural, .up: .sharp]
             }
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .sharp(count: 1), .up: .sharp(count: 2)]
+                return [.down: .flat, .neutral: .sharp, .up: .sharps(count: 2)]
             }
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharp(count: 2)]
+                return [.down: .flat, .neutral: .natural, .up: .sharps(count: 2)]
             }
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .flat, .up: .sharp(count: 1)]
+                return [.down: .flat, .neutral: .flat, .up: .sharp]
             }
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharp(count: 2)]
+                return [.down: .flat, .neutral: .natural, .up: .sharps(count: 2)]
             }
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .up: .sharp(count: 1)]
+                return [.down: .flat, .up: .sharp]
             }
         }
 
-- 
2.17.2 (Apple Git-113)


From 7c979acf6099789e068d2d87efea4df4ba739892 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Sat, 20 Oct 2018 12:40:21 -0400
Subject: [PATCH 21/66] Replace Pitch.Spelling implementation

---
 .../Wetherfield/Pitch.Spelling.Category.swift        | 12 ++++++------
 .../PitchSpeller/Wetherfield/Tendency.swift          |  4 ++--
 .../PitchSpeller/Wetherfield/Wetherfield.swift       | 12 ++++++------
 3 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 0eb47b2..2df7b20 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -10,9 +10,9 @@ import Pitch
 
 /// Interface for the six pitch spelling categories.
 protocol PitchSpellingCategoryProtocol {
-    typealias ModifierMap = [ModifierDirection: EDO12.Modifier]
+    typealias ModifierMap = [ModifierDirection: Pitch.Spelling.Modifier]
     /// The available `QuarterStepModifier` value by the given `ModifierDirection`.
-    static var modifiers: [ModifierDirection: EDO12.Modifier] { get }
+    static var modifiers: ModifierMap { get }
 }
 
 extension Pitch.Spelling {
@@ -30,14 +30,14 @@ extension Pitch.Spelling {
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .sharp, .up: .sharps(count: 2)]
+                return [.down: .flat, .neutral: .sharp, .up: .doubleSharp]
             }
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharps(count: 2)]
+                return [.down: .flat, .neutral: .natural, .up: .doubleSharp]
             }
         }
 
@@ -51,7 +51,7 @@ extension Pitch.Spelling {
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharps(count: 2)]
+                return [.down: .flat, .neutral: .natural, .up: .doubleSharp]
             }
         }
 
@@ -78,7 +78,7 @@ extension Pitch.Spelling {
     }
 }
 
-extension Pitch.Spelling where Tuning == EDO12 {
+extension Pitch.Spelling {
 
     /// - Returns: The `Pitch.Spelling` value for the given `pitchClass` with the given
     /// `modifierDirection`, if the `pitchClass` is an integral value, and if the
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
index 8695193..4022646 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
@@ -32,14 +32,14 @@ struct TendencyPair: Hashable {
     }
 }
 
-extension Pitch.Spelling where Tuning == EDO12 {
+extension Pitch.Spelling {
 
     /// Creates a `Pitch.Spelling` value with the given `pitchClass` and the given `tendencies`,
     /// which are resultant from the Wetherfield-encoded and -decoded `FlowNetwork`, if it is
     /// possible. Otherwise, returns `nil`.
     init?(pitchClass: Pitch.Class, tendencies: TendencyPair) {
         guard
-            let category = Pitch.Spelling<EDO12>.Category.category(for: pitchClass),
+            let category = Pitch.Spelling.Category.category(for: pitchClass),
             let tendencyConverter = category as? TendencyConverting.Type,
             let modifierDirection = tendencyConverter.modifierDirection(for: tendencies)
         else {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index c61a1d5..1955b49 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -49,7 +49,7 @@ struct PitchSpeller {
     // MARK: - Instance Properties
 
     /// The omnipresent, tie-breaking `Pitch.Spelling` value.
-    let parsimonyPivot: Pitch.Spelling<EDO12>
+    let parsimonyPivot: Pitch.Spelling
 
     /// The unspelled `Pitch` values to be spelled.
     let pitches: [Pitch]
@@ -64,7 +64,7 @@ struct PitchSpeller {
     // MARK: - Initializers
 
     /// Create a `PitchSpeller` to spell the given `pitches`, with the given `parsimonyPivot`.
-    init(pitches: [Pitch], parsimonyPivot: Pitch.Spelling<EDO12> = .init(.d)) {
+    init(pitches: [Pitch], parsimonyPivot: Pitch.Spelling = .init(.d)) {
         self.pitches = pitches
         self.parsimonyPivot = parsimonyPivot
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
@@ -73,7 +73,7 @@ struct PitchSpeller {
 
     /// - Returns: An array of `SpelledPitch` values in the order in which the original
     /// unspelled `Pitch` values are given.
-    func spell() -> [SpelledPitch<EDO12>] {
+    func spell() -> [SpelledPitch] {
 
         var assignedNodes: [AssignedNode] {
             let (sourceSide, sinkSide) = flowNetwork.minimumCut
@@ -89,11 +89,11 @@ struct PitchSpeller {
             .map(spellPitch)
     }
 
-    private func spellPitch(_ up: AssignedNode, _ down: AssignedNode) -> SpelledPitch<EDO12> {
+    private func spellPitch(_ up: AssignedNode, _ down: AssignedNode) -> SpelledPitch {
         let pitch = self.pitch(node: up.index)
         let tendencies = TendencyPair((up.assignment, down.assignment))
-        let spelling = Pitch.Spelling<EDO12>(pitchClass: pitch.class, tendencies: tendencies)!
-        return SpelledPitch(try! pitch.spelled(with: Pitch.Spelling<EDO48>(spelling)))
+        let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
+        return try! pitch.spelled(with: spelling)
     }
 
     /// - Returns: The `Pitch` value for the given `node` value.
-- 
2.17.2 (Apple Git-113)


From b20c2a3d5e5fd788338d867ba8f17928d16cf821 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 21 Oct 2018 12:42:10 -0400
Subject: [PATCH 22/66] Refactor neutralLetterName calculation (#118)

---
 .../Wetherfield/Pitch.Spelling.Category.swift | 83 ++++++-------------
 1 file changed, 25 insertions(+), 58 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 2df7b20..060a1f9 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -85,10 +85,10 @@ extension Pitch.Spelling {
     /// `modifierDirection` can be converted into a `QuarterStepModifier` within the
     /// `PitchSpellingCategoryProtocol` in which the given `pitchClass` resides. Otherwise, `nil`.
     init?(pitchClass: Pitch.Class, modifierDirection: ModifierDirection) {
+        let letterName = Pitch.Spelling.letterName(pitchClass: pitchClass, with: modifierDirection)
         guard
             let category = Category.category(for: pitchClass),
-            let modifier = category.modifiers[modifierDirection],
-            let letterName = LetterName(pitchClass: pitchClass, modifierDirection: modifierDirection)
+            let modifier = category.modifiers[modifierDirection]
         else {
             return nil
         }
@@ -96,68 +96,35 @@ extension Pitch.Spelling {
     }
 }
 
-extension LetterName {
-
-    /// Create a `LetterName` with the given `pitchClass` and `modifierDirection`.
-    init?(pitchClass: Pitch.Class, modifierDirection: ModifierDirection) {
-        if pitchClass == 8 {
-            switch modifierDirection {
-            case .down: self = .a
-            case .up: self = .g
-            default: return nil
-            }
-            return
-        }
-        guard
-            let neutral = LetterName.neutral(for: pitchClass),
-            let adjusted = neutral.adjusted(for: pitchClass, with: modifierDirection)
-        else {
-            return nil
-        }
-        self = adjusted
-    }
-
+extension Pitch.Spelling {
+    
     /// - Returns: The `LetterName` which corresponds to the `.neutral` `ModifierDirection` for the
     /// the given `pitchClass`, if such a `LetterName` exists. Otherwise, `nil`.
-    static func neutral(for pitchClass: Pitch.Class) -> LetterName? {
-        switch pitchClass {
-        // Category "Five" pitch classes have no neutral `LetterName`
-        case 8:
-            return nil
-        // Category "One" pitch classes need to be shifted down
-        case 1,6:
-            return LetterName.default(for: pitchClass - 1)!
-        // Category "Three" pitch classes need to be shifted up
-        case 3,10:
-            return LetterName.default(for: pitchClass + 1)!
-        // `Pitch.Class` values which can be spelled with a `natural` modifier need no adjustment
-        case 0...11:
-            return LetterName.default(for: pitchClass)!
+    static func neutralLetterName(for pitchClass: Pitch.Class) -> LetterName? {
+        guard let category = Category.category(for: pitchClass) else { return nil }
+        guard let modifier = category.modifiers[.neutral] else { return nil }
+        switch modifier {
+        case .natural:
+            return LetterName.default(for: pitchClass)
+        case .flat:
+            return LetterName.default(for: pitchClass + 1)
+        case .sharp:
+            return LetterName.default(for: pitchClass - 1)
         default:
-            return nil
+            fatalError("Unsupported Pitch.Spelling.Modifier \(modifier)")
         }
     }
-
-    /// - Returns: A `LetterName` adjusted for the given `pitchClass` and the given
-    /// `modifierDirection`, if such a `LetterName` value exists. Otherwise, `nil`.
-    func adjusted(for pitchClass: Pitch.Class, with modifierDirection: ModifierDirection)
-        -> LetterName?
+   
+    /// Create a `LetterName` with the given `pitchClass` and `modifierDirection`.
+    static func letterName(pitchClass: Pitch.Class,
+                            with modifierDirection: ModifierDirection) -> LetterName
     {
-        switch pitchClass {
-        case 8:
-            switch modifierDirection {
-            case .down: return .a
-            case .up: return .g
-            default: return nil
-            }
-        case 0...11:
-            switch modifierDirection {
-            case .down: return successor
-            case .neutral: return self
-            case .up: return predecessor
-            }
-        default:
-            return nil
+        guard let neutralLetterName = Pitch.Spelling.neutralLetterName(for: pitchClass)
+            else { return modifierDirection == .down ? .a : .g }
+        switch modifierDirection {
+        case .down: return neutralLetterName.successor
+        case .neutral: return neutralLetterName
+        case .up: return neutralLetterName.predecessor
         }
     }
 }
-- 
2.17.2 (Apple Git-113)


From f86047b4b5d18bdc81a053816ddaece42d14a346 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 21 Oct 2018 13:46:23 -0400
Subject: [PATCH 23/66] Diversify indexing types in PitchSpeller (#123)

---
 .../PitchSpeller/Wetherfield/Tendency.swift   |  8 ++-
 .../Wetherfield/Wetherfield.swift             | 61 ++++++++++++-------
 2 files changed, 46 insertions(+), 23 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
index 4022646..41f64b0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
@@ -9,11 +9,17 @@ import Pitch
 
 /// One of two values encoded in a Wetherfield `FlowNetwork`. Each provides a tendency `up`, or
 /// `down` for the purposes of spelling an unspelled pitch in a given musical context.
-internal enum Tendency: Int {
+enum Tendency: Int {
     case down = 0
     case up = 1
 }
 
+extension Tendency: Comparable {
+    static func < (lhs: Tendency, rhs: Tendency) -> Bool {
+        return lhs.rawValue < rhs.rawValue
+    }
+}
+
 /// A pair of `Tendency` values. Wrapped up here for the purposes of `Equatable` and `Hashable`
 /// synthesizing.
 struct TendencyPair: Hashable {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 1955b49..51f5b9f 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -9,41 +9,47 @@ import DataStructures
 import Pitch
 
 protocol PitchSpellingNode: Hashable {
-    var index: Int { get }
+    associatedtype Index
+    
+    var index: Index { get }
 }
 
 struct PitchSpeller {
 
     struct UnassignedNode: PitchSpellingNode {
-        let index: Int
+        let index: Cross<Int, Tendency>
     }
 
     struct AssignedNode: PitchSpellingNode {
-        let index: Int
+        let index: Cross<Int, Tendency>
         let assignment: Tendency
-        init(_ index: Int, _ assignment: Tendency) {
+        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
             self.index = index
             self.assignment = assignment
         }
     }
+    
+    struct IndexedPitch: PitchSpellingNode {
+        let index: Int
+        let pitch: Pitch
+    }
 
     /// - Returns: The nodes for the `Pitch` at the given `index`.
-    private static func nodes(pitchAtIndex index: Int) -> (Int, Int) {
-        let offset = 2 * index
-        return (offset, offset + 1)
+    private static func nodes(pitchAtIndex index: Int) -> (Cross<Int, Tendency>, Cross<Int, Tendency>) {
+        return (.init(index, .down), .init(index, .up))
     }
 
     /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
     /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
     /// the given `Pitch`.)
-    private static func node(_ offset: Int, _ index: Int) -> Int {
-        return 2 * offset + index
+    private static func node(_ offset: Int, _ index: Tendency) -> Cross<Int, Tendency> {
+        return .init(offset, index)
     }
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
     /// `pitchNodes`.
-    private static func internalNodes(pitches: [Pitch]) -> [Int] {
-        return pitches.indices.flatMap { offset in [0,1].map { index in node(offset, index) } }
+    private static func internalNodes(pitches: [Pitch]) -> [Cross<Int, Tendency>] {
+        return pitches.indices.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
     }
 
     // MARK: - Instance Properties
@@ -56,10 +62,10 @@ struct PitchSpeller {
 
     /// The nodes within the `FlowNetwork`. The values are the encodings of the indices of `Pitch`
     /// values in `pitches.
-    let pitchNodes: [Int]
+    let pitchNodes: [Cross<Int, Tendency>]
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
-    let flowNetwork: FlowNetwork<Int,Double>
+    let flowNetwork: FlowNetwork<Cross<Int, Tendency>,Double>
 
     // MARK: - Initializers
 
@@ -68,7 +74,11 @@ struct PitchSpeller {
         self.pitches = pitches
         self.parsimonyPivot = parsimonyPivot
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
-        self.flowNetwork = FlowNetwork(source: -2, sink: -1, internalNodes: pitchNodes)
+        self.flowNetwork = FlowNetwork(
+            source: Cross<Int, Tendency>(-1, .down),
+            sink: Cross<Int, Tendency>(-1, .up),
+            internalNodes: pitchNodes
+        )
     }
 
     /// - Returns: An array of `SpelledPitch` values in the order in which the original
@@ -76,15 +86,16 @@ struct PitchSpeller {
     func spell() -> [SpelledPitch] {
 
         var assignedNodes: [AssignedNode] {
-            let (sourceSide, sinkSide) = flowNetwork.minimumCut
+            var (sourceSide, sinkSide) = flowNetwork.minimumCut
+            sourceSide.remove(flowNetwork.source)
+            sinkSide.remove(flowNetwork.sink)
             let downNodes = sourceSide.map { index in AssignedNode(index, .down) }
             let upNodes = sinkSide.map { index in AssignedNode(index, .up) }
             return downNodes + upNodes
         }
 
         return assignedNodes
-            .sorted { $0.index < $1.index }
-            .dropFirst(2)
+            .sorted()
             .pairs
             .map(spellPitch)
     }
@@ -97,16 +108,16 @@ struct PitchSpeller {
     }
 
     /// - Returns: The `Pitch` value for the given `node` value.
-    private func pitch(node: Int) -> Pitch {
-        return pitches[node / 2]
+    private func pitch(node: Cross<Int, Tendency>) -> Pitch {
+        return pitches[node.a]
     }
 }
 
-extension FlowNetwork where Node == Int, Weight == Double {
+extension FlowNetwork where Node == Cross<Int, Tendency>, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-    init(source: Int, sink: Int, internalNodes: [Int]) {
-        let graph = WeightedDirectedGraph<Int,Double>(
+    init(source: Cross<Int, Tendency>, sink: Cross<Int, Tendency>, internalNodes: [Cross<Int, Tendency>]) {
+        let graph = WeightedDirectedGraph<Cross<Int, Tendency>,Double>(
             source: source,
             sink: sink,
             internalNodes: internalNodes
@@ -115,6 +126,12 @@ extension FlowNetwork where Node == Int, Weight == Double {
     }
 }
 
+extension PitchSpeller.AssignedNode: Comparable {
+    static func < (lhs: PitchSpeller.AssignedNode, rhs: PitchSpeller.AssignedNode) -> Bool {
+        return lhs.index < rhs.index
+    }
+}
+
 extension WeightedDirectedGraph {
     /// Create a `DirectedGraph` which is hooked up as necessary for the Wetherfield pitch-spelling process.
     init(source: Node, sink: Node, internalNodes: [Node]) {
-- 
2.17.2 (Apple Git-113)


From 76047b62c43aaa8bf0af2448cb6e66c95f53254e Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 21 Oct 2018 13:58:55 -0400
Subject: [PATCH 24/66] Improve runtime of spell function with dictionaries
 (#126)

---
 .../Wetherfield/Wetherfield.swift             | 28 +++++++++++--------
 1 file changed, 17 insertions(+), 11 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 51f5b9f..a92d5db 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -48,8 +48,8 @@ struct PitchSpeller {
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
     /// `pitchNodes`.
-    private static func internalNodes(pitches: [Pitch]) -> [Cross<Int, Tendency>] {
-        return pitches.indices.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
+    private static func internalNodes(pitches: [Int: Pitch]) -> [Cross<Int, Tendency>] {
+        return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
     }
 
     // MARK: - Instance Properties
@@ -58,7 +58,7 @@ struct PitchSpeller {
     let parsimonyPivot: Pitch.Spelling
 
     /// The unspelled `Pitch` values to be spelled.
-    let pitches: [Pitch]
+    let pitches: [Int: Pitch]
 
     /// The nodes within the `FlowNetwork`. The values are the encodings of the indices of `Pitch`
     /// values in `pitches.
@@ -70,7 +70,7 @@ struct PitchSpeller {
     // MARK: - Initializers
 
     /// Create a `PitchSpeller` to spell the given `pitches`, with the given `parsimonyPivot`.
-    init(pitches: [Pitch], parsimonyPivot: Pitch.Spelling = .init(.d)) {
+    init(pitches: [Int: Pitch], parsimonyPivot: Pitch.Spelling = .init(.d)) {
         self.pitches = pitches
         self.parsimonyPivot = parsimonyPivot
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
@@ -81,9 +81,9 @@ struct PitchSpeller {
         )
     }
 
-    /// - Returns: An array of `SpelledPitch` values in the order in which the original
-    /// unspelled `Pitch` values are given.
-    func spell() -> [SpelledPitch] {
+    /// - Returns: An array of `SpelledPitch` values with the same indices as the original
+    /// unspelled `Pitch` values.
+    func spell() -> [Int: SpelledPitch] {
 
         var assignedNodes: [AssignedNode] {
             var (sourceSide, sinkSide) = flowNetwork.minimumCut
@@ -95,9 +95,15 @@ struct PitchSpeller {
         }
 
         return assignedNodes
-            .sorted()
-            .pairs
-            .map(spellPitch)
+            .reduce(into: [Int: (AssignedNode, AssignedNode)]()) { pairs, node in
+                if !pairs.keys.contains(node.index.a) {
+                    pairs[node.index.a] = (node, node)
+                }
+                switch node.index.b {
+                case .up: pairs[node.index.a]!.0 = node
+                case .down: pairs[node.index.a]!.1 = node
+                }
+            }.mapValues(spellPitch)
     }
 
     private func spellPitch(_ up: AssignedNode, _ down: AssignedNode) -> SpelledPitch {
@@ -109,7 +115,7 @@ struct PitchSpeller {
 
     /// - Returns: The `Pitch` value for the given `node` value.
     private func pitch(node: Cross<Int, Tendency>) -> Pitch {
-        return pitches[node.a]
+        return pitches[node.a]!
     }
 }
 
-- 
2.17.2 (Apple Git-113)


From f197e2eba2c2c6a09630dc133ae0caa9fb87a46f Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Tue, 23 Oct 2018 14:36:57 -0400
Subject: [PATCH 25/66] Initial implementation of addition of SpelledPitch and
 IntervalDescriptor types (#132)

---
 Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 9cb5a46..1feb46c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -45,7 +45,7 @@ extension WeightedDirectedGraph where Weight: Comparable {
     /// value).
     mutating func removeEdgeIfFlowless(_ edge: Edge) {
         if weight(edge) == 0 {
-            removeEdge(edge)
+            remove(edge)
         }
     }
 
-- 
2.17.2 (Apple Git-113)


From a13c88c51417a9dd957fbd1d6a0caeb317823c4e Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 27 Oct 2018 14:28:02 -0400
Subject: [PATCH 26/66] Flow network to graph on master (#141)

---
 .../Wetherfield/FlowNetwork.swift             | 50 ++++++++++++-------
 .../Wetherfield/Wetherfield.swift             |  2 +-
 2 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 1feb46c..21d83c1 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -11,13 +11,19 @@ import DataStructures
 /// - Each edge has a capacity for flow
 /// - A "source" node, which only emanates flow outward
 /// - A "sink" node, which only receives flow
-public struct FlowNetwork <Node: Hashable, Weight: Numeric & Comparable> {
-
-    // MARK: - Instance Properties
+public struct FlowNetwork<Node: Hashable, Weight: Numeric & Comparable>:
+    WeightedGraphProtocol,
+    DirectedGraphProtocol
+{
+    public var weights: [Edge : Weight]
+    public var nodes: Set<Node>
+    public var source: Node
+    public var sink: Node
+}
 
-    var directedGraph: WeightedDirectedGraph<Node,Weight>
-    var source: Node
-    var sink: Node
+extension FlowNetwork {
+    
+    public typealias Edge = OrderedPair<Node>
 }
 
 extension FlowNetwork {
@@ -26,16 +32,26 @@ extension FlowNetwork {
 
     /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
     init(_ directedGraph: WeightedDirectedGraph<Node,Weight>, source: Node, sink: Node) {
-        self.directedGraph = directedGraph
-        self.directedGraph.insert(source)
-        self.directedGraph.insert(sink)
+        self.nodes = directedGraph.nodes
+        self.weights = directedGraph.weights
         self.source = source
         self.sink = sink
     }
 }
 
-extension WeightedDirectedGraph where Weight: Comparable {
-    // TODO: Make throw
+extension FlowNetwork {
+
+    // MARK: - Instance Methods
+
+    func contains(_ node: Node) -> Bool {
+        return node == source || node == sink || nodes.contains(node)
+    }
+}
+
+extension FlowNetwork {
+
+    // MARK: - Mutating Methods
+
     mutating func reduceFlow(through edge: Edge, by amount: Weight) {
         updateEdge(edge) { weight in weight - amount }
     }
@@ -83,7 +99,7 @@ extension FlowNetwork {
     /// - Returns: All of the `Node` values contained herein which are neither the `source` nor
     /// the `sink`.
     public var internalNodes: [Node] {
-        return directedGraph.nodes.filter { $0 != source && $0 != sink }
+        return nodes.filter { $0 != source && $0 != sink }
     }
 
     /// - Returns: A minimum cut with nodes included on the `sink` side in case of a
@@ -101,7 +117,7 @@ extension FlowNetwork {
     var maximumFlowAndResidualNetwork: (flow: Weight, network: DirectedGraph<Node>) {
         // Make a copy of the directed representation of the network to be mutated by pushing flow
         // through it.
-        var residualNetwork = directedGraph
+        var residualNetwork = self
         // While an augmenting path (a path emanating directionally from the source node) can be
         // found, push flow through the path, mutating the residual network
         while let augmentingPath = residualNetwork.shortestUnweightedPath(from: source, to: sink) {
@@ -110,14 +126,14 @@ extension FlowNetwork {
         // Compares the edges in the mutated residual network against the original directed
         // graph.
         let flow: Weight = {
-            let sourceEdges = directedGraph.neighbors(of: source).lazy
+            let sourceEdges = neighbors(of: source).lazy
                 .map { OrderedPair(self.source, $0) }
                 .partition(residualNetwork.contains)
             let edgesPresent = sourceEdges.whereTrue.lazy
-                .map { edge in self.directedGraph.weight(edge)! - residualNetwork.weight(edge)! }
+                .map { edge in self.weight(edge)! - residualNetwork.weight(edge)! }
                 .reduce(0,+)
             let edgesAbsent = sourceEdges.whereFalse.lazy
-                .compactMap(directedGraph.weight)
+                .compactMap(weight)
                 .reduce(0,+)
             return edgesPresent + edgesAbsent
         }()
@@ -130,7 +146,7 @@ extension Sequence {
     func filterComplement (_ predicate: (Element) -> Bool) -> [Element] {
         return filter { !predicate($0) }
     }
-    
+
     func partition (_ predicate: (Element) -> Bool) -> (whereFalse: [Element], whereTrue: [Element]) {
         return (filterComplement(predicate), filter(predicate))
     }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index a92d5db..0907eb0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -28,7 +28,7 @@ struct PitchSpeller {
             self.assignment = assignment
         }
     }
-    
+
     struct IndexedPitch: PitchSpellingNode {
         let index: Int
         let pitch: Pitch
-- 
2.17.2 (Apple Git-113)


From e04fc463ed81d74a7aa6bbeb9a1d43879016dbbd Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 27 Oct 2018 14:29:44 -0400
Subject: [PATCH 27/66] Move FP structures into own files (#140) (#142)

---
 .../PitchSpeller/Wetherfield/Getter.swift     | 24 +++++++++++++++++++
 .../PitchSpeller/Wetherfield/PullBack.swift   | 22 +++++++++++++++++
 .../PitchSpeller/Wetherfield/Reducer.swift    | 24 +++++++++++++++++++
 3 files changed, 70 insertions(+)
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Getter.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Reducer.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Getter.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Getter.swift
new file mode 100644
index 0000000..6b8b358
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Getter.swift
@@ -0,0 +1,24 @@
+//
+//  Getter.swift
+//  SpelledPitch
+//
+//  Created by James Bean on 10/24/18.
+//
+
+struct Getter<A, B> {
+    let view: (A) -> B
+}
+
+extension Getter {
+    init(_ keyPath: KeyPath<A,B>) {
+        self.init { $0[keyPath: keyPath] }
+    }
+}
+
+func compose <A,B,C> (_ lhs: Getter<A,B>, _ rhs: Getter<B,C>) -> Getter<A,C> {
+    return .init { a in rhs.view(lhs.view(a)) }
+}
+
+func * <A,B,C> (lhs: Getter<A,B>, rhs: Getter<B,C>) -> Getter<A,C> {
+    return compose(lhs,rhs)
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift
new file mode 100644
index 0000000..8742ab6
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift
@@ -0,0 +1,22 @@
+//
+//  PullBack.swift
+//  SpelledPitch
+//
+//  Created by James Bean on 10/24/18.
+//
+
+import DataStructures
+
+struct PullBack <A,B,C,P,Q> where
+    P: SymmetricPair & Hashable,
+    Q: SymmetricPair & Hashable,
+    P.A == A,
+    Q.B == B
+{
+    let map: (Q) -> C?
+    let lensOnIndex: Getter<A, B>
+
+    func retrieve(for p: P) -> C {
+        return map(Q(lensOnIndex.view(p.a), lensOnIndex.view(p.b)))!
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Reducer.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Reducer.swift
new file mode 100644
index 0000000..6653b28
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Reducer.swift
@@ -0,0 +1,24 @@
+//
+//  Reducer.swift
+//  SpelledPitch
+//
+//  Created by James Bean on 10/24/18.
+//
+
+import Algebra
+
+struct Reducer <S,A>: Monoid {
+
+    static var identity: Reducer {
+        return .init { _, _ in return }
+    }
+
+    static func <> (lhs: Reducer, rhs: Reducer) -> Reducer {
+        return Reducer { s,a in
+            rhs.reduce(&s,a)
+            lhs.reduce(&s,a)
+        }
+    }
+
+    let reduce: (inout S, A) -> ()
+}
-- 
2.17.2 (Apple Git-113)


From 457aad5b40179ecc0aeb40e9e088aa2c2eefc5e4 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 27 Oct 2018 14:29:58 -0400
Subject: [PATCH 28/66] Retire TendencyPair, make typealias for
 OrderedPair<Tendency> (#139) (#144)

---
 .../PitchSpeller/Wetherfield/Tendency.swift   | 21 +++----------------
 .../Wetherfield/Wetherfield.swift             |  2 +-
 2 files changed, 4 insertions(+), 19 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
index 41f64b0..f49b3d0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
@@ -5,8 +5,11 @@
 //  Created by James Bean on 5/22/18.
 //
 
+import DataStructures
 import Pitch
 
+typealias TendencyPair = OrderedPair<Tendency>
+
 /// One of two values encoded in a Wetherfield `FlowNetwork`. Each provides a tendency `up`, or
 /// `down` for the purposes of spelling an unspelled pitch in a given musical context.
 enum Tendency: Int {
@@ -20,24 +23,6 @@ extension Tendency: Comparable {
     }
 }
 
-/// A pair of `Tendency` values. Wrapped up here for the purposes of `Equatable` and `Hashable`
-/// synthesizing.
-struct TendencyPair: Hashable {
-
-    let up: Tendency
-    let down: Tendency
-
-    init(_ up: Tendency, _ down: Tendency) {
-        self.up = up
-        self.down = down
-    }
-
-    init(_ tuple: (Tendency, Tendency)) {
-        self.up = tuple.0
-        self.down = tuple.1
-    }
-}
-
 extension Pitch.Spelling {
 
     /// Creates a `Pitch.Spelling` value with the given `pitchClass` and the given `tendencies`,
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 0907eb0..55116e3 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -108,7 +108,7 @@ struct PitchSpeller {
 
     private func spellPitch(_ up: AssignedNode, _ down: AssignedNode) -> SpelledPitch {
         let pitch = self.pitch(node: up.index)
-        let tendencies = TendencyPair((up.assignment, down.assignment))
+        let tendencies = TendencyPair(up.assignment, down.assignment)
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
-- 
2.17.2 (Apple Git-113)


From fc424bd980bfc944857ad12ab663996ad9c8f653 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 27 Oct 2018 14:40:33 -0400
Subject: [PATCH 29/66] Use Cross<Int,Tendency> as PitchSpellingNode.Index
 [based on (#135)] (into master) (#143)

---
 .../Wetherfield/Wetherfield.swift             | 38 +++++++++----------
 1 file changed, 17 insertions(+), 21 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 55116e3..8d91ead 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -9,46 +9,42 @@ import DataStructures
 import Pitch
 
 protocol PitchSpellingNode: Hashable {
-    associatedtype Index
-    
+    typealias Index = Cross<Int,Tendency>
     var index: Index { get }
 }
 
 struct PitchSpeller {
 
     struct UnassignedNode: PitchSpellingNode {
-        let index: Cross<Int, Tendency>
+        let index: Index
     }
 
     struct AssignedNode: PitchSpellingNode {
-        let index: Cross<Int, Tendency>
+        let index: Index
         let assignment: Tendency
-        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+        init(_ index: Index, _ assignment: Tendency) {
             self.index = index
             self.assignment = assignment
         }
     }
 
-    struct IndexedPitch: PitchSpellingNode {
-        let index: Int
-        let pitch: Pitch
-    }
-
     /// - Returns: The nodes for the `Pitch` at the given `index`.
-    private static func nodes(pitchAtIndex index: Int) -> (Cross<Int, Tendency>, Cross<Int, Tendency>) {
+    private static func nodes(pitchAtIndex index: Int)
+        -> (PitchSpellingNode.Index, PitchSpellingNode.Index)
+    {
         return (.init(index, .down), .init(index, .up))
     }
 
     /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
     /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
     /// the given `Pitch`.)
-    private static func node(_ offset: Int, _ index: Tendency) -> Cross<Int, Tendency> {
+    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
         return .init(offset, index)
     }
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
     /// `pitchNodes`.
-    private static func internalNodes(pitches: [Int: Pitch]) -> [Cross<Int, Tendency>] {
+    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
         return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
     }
 
@@ -62,10 +58,10 @@ struct PitchSpeller {
 
     /// The nodes within the `FlowNetwork`. The values are the encodings of the indices of `Pitch`
     /// values in `pitches.
-    let pitchNodes: [Cross<Int, Tendency>]
+    let pitchNodes: [PitchSpellingNode.Index]
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
-    let flowNetwork: FlowNetwork<Cross<Int, Tendency>,Double>
+    var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
 
     // MARK: - Initializers
 
@@ -75,8 +71,8 @@ struct PitchSpeller {
         self.parsimonyPivot = parsimonyPivot
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
-            source: Cross<Int, Tendency>(-1, .down),
-            sink: Cross<Int, Tendency>(-1, .up),
+            source: PitchSpellingNode.Index(-1, .down),
+            sink: PitchSpellingNode.Index(-1, .up),
             internalNodes: pitchNodes
         )
     }
@@ -114,16 +110,16 @@ struct PitchSpeller {
     }
 
     /// - Returns: The `Pitch` value for the given `node` value.
-    private func pitch(node: Cross<Int, Tendency>) -> Pitch {
+    private func pitch(node: PitchSpellingNode.Index) -> Pitch {
         return pitches[node.a]!
     }
 }
 
-extension FlowNetwork where Node == Cross<Int, Tendency>, Weight == Double {
+extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-    init(source: Cross<Int, Tendency>, sink: Cross<Int, Tendency>, internalNodes: [Cross<Int, Tendency>]) {
-        let graph = WeightedDirectedGraph<Cross<Int, Tendency>,Double>(
+    init(source: PitchSpellingNode.Index, sink: PitchSpellingNode.Index, internalNodes: [PitchSpellingNode.Index]) {
+        let graph = WeightedDirectedGraph<PitchSpellingNode.Index,Double>(
             source: source,
             sink: sink,
             internalNodes: internalNodes
-- 
2.17.2 (Apple Git-113)


From 5c463f0cd21c2d325a27e688d5776be125b40ada Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Fri, 2 Nov 2018 19:51:59 -0400
Subject: [PATCH 30/66] Carrying witnesses (#145)

---
 .../Wetherfield/AdjacencyCarrying.swift       |  54 +++++++++
 .../Wetherfield/FlowNetwork.swift             |  14 +++
 .../PitchSpeller/Wetherfield/PullBack.swift   |  22 ----
 .../Wetherfield/WeightCarrying.swift          | 103 ++++++++++++++++++
 4 files changed, 171 insertions(+), 22 deletions(-)
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
new file mode 100644
index 0000000..51c3d09
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
@@ -0,0 +1,54 @@
+//
+//  AdjacencyCarrying.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 30/10/2018.
+//
+
+import DataStructures
+
+struct AdjacencyCarrying <G: GraphProtocol> {
+    let contains: (G.Edge) -> Bool
+    
+    private init (contains: @escaping (G.Edge) -> Bool) {
+        self.contains = contains
+    }
+    
+    func contains (from start: G.Node, to end: G.Node) -> Bool {
+        return contains(G.Edge(start, end))
+    }
+    
+    func pullback <H: GraphProtocol> (_ f: @escaping (H.Node) -> G.Node) -> AdjacencyCarrying<H> {
+        return AdjacencyCarrying<H> { e in self.contains(G.Edge(f(e.a), f(e.b))) }
+    }
+    
+    static func build (from g: G) -> AdjacencyCarrying {
+        return AdjacencyCarrying(contains: g.contains)
+    }
+}
+
+extension AdjacencyCarrying {
+    
+    static func * <H> (lhs: AdjacencyCarrying, rhs: AdjacencyCarrying<H>) -> AdjacencyCarrying
+        where
+        H: UndirectedGraphProtocol,
+        H.Node == G.Node
+    {
+        return AdjacencyCarrying { e in lhs.contains(e) && rhs.contains(H.Edge(e.a, e.b)) }
+    }
+    
+    static func + (lhs: AdjacencyCarrying, rhs: AdjacencyCarrying) -> AdjacencyCarrying {
+        return AdjacencyCarrying { e in lhs.contains(e) || rhs.contains(e) }
+    }
+}
+
+extension AdjacencyCarrying where G: DirectedGraphProtocol {
+    
+    static func * <H> (lhs: AdjacencyCarrying, rhs: AdjacencyCarrying<H>) -> AdjacencyCarrying
+        where
+        H: DirectedGraphProtocol,
+        H.Node == G.Node
+    {
+        return AdjacencyCarrying { e in lhs.contains(e) && rhs.contains(H.Edge(e.a, e.b)) }
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 21d83c1..66ff95f 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -39,6 +39,20 @@ extension FlowNetwork {
     }
 }
 
+extension FlowNetwork {
+    mutating func mask <G: WeightedGraphProtocol> (_ weightCarrying: WeightCarrying<G>)
+        where Node == G.Node, Weight == G.Weight
+    {
+        for edge in weights.keys {
+            if let maskWeight = weightCarrying.weight(from: edge.a, to: edge.b) {
+                updateEdge(edge) { $0 * maskWeight }
+            } else {
+                remove(edge)
+            }
+        }
+    }
+}
+
 extension FlowNetwork {
 
     // MARK: - Instance Methods
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift
deleted file mode 100644
index 8742ab6..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/PullBack.swift
+++ /dev/null
@@ -1,22 +0,0 @@
-//
-//  PullBack.swift
-//  SpelledPitch
-//
-//  Created by James Bean on 10/24/18.
-//
-
-import DataStructures
-
-struct PullBack <A,B,C,P,Q> where
-    P: SymmetricPair & Hashable,
-    Q: SymmetricPair & Hashable,
-    P.A == A,
-    Q.B == B
-{
-    let map: (Q) -> C?
-    let lensOnIndex: Getter<A, B>
-
-    func retrieve(for p: P) -> C {
-        return map(Q(lensOnIndex.view(p.a), lensOnIndex.view(p.b)))!
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
new file mode 100644
index 0000000..0a935e5
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
@@ -0,0 +1,103 @@
+//
+//  WeightCarrying.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 30/10/2018.
+//
+
+import DataStructures
+
+struct WeightCarrying<G: WeightedGraphProtocol> {
+    let weight: (G.Edge) -> G.Weight?
+    
+    private init (weight: @escaping (G.Edge) -> G.Weight?) {
+        self.weight = weight
+    }
+    
+    func weight (from start: G.Node, to end: G.Node) -> G.Weight? {
+        return weight(G.Edge(start, end))
+		}
+
+    func pullback <H: WeightedGraphProtocol> (_ f: @escaping (H.Node) -> G.Node) -> WeightCarrying<H>
+        where H.Weight == G.Weight
+    {
+        return WeightCarrying<H> { e in self.weight(G.Edge(f(e.a), f(e.b))) }
+    }
+    
+    static func build (from g: G) -> WeightCarrying {
+        return WeightCarrying(weight: g.weight)
+    }
+}
+
+extension WeightCarrying {
+    
+    static func * <H> (lhs: WeightCarrying, rhs: WeightCarrying<H>) -> WeightCarrying
+        where
+        H: UndirectedGraphProtocol,
+        H.Node == G.Node,
+        H.Weight == G.Weight
+    {
+        return WeightCarrying { e in
+            guard let lweight = lhs.weight(e), let rweight = rhs.weight(H.Edge(e.a, e.b))
+                else { return nil }
+            return lweight * rweight
+        }
+    }
+    
+    static func * <H> (lhs: WeightCarrying, rhs: AdjacencyCarrying<H>) -> WeightCarrying
+        where
+        H: UndirectedGraphProtocol,
+        H.Node == G.Node
+    {
+        return WeightCarrying { e in rhs.contains(H.Edge(e.a,e.b)) ? lhs.weight(e) : nil }
+    }
+    
+    static func * <H> (lhs: AdjacencyCarrying<H>, rhs: WeightCarrying) -> WeightCarrying
+        where
+        H: UndirectedGraphProtocol,
+        H.Node == G.Node
+    {
+        return WeightCarrying { e in lhs.contains(H.Edge(e.a,e.b)) ? rhs.weight(e) : nil }
+    }
+    
+    static func + (lhs: WeightCarrying, rhs: WeightCarrying) -> WeightCarrying {
+        return WeightCarrying { e in
+            guard let lweight = lhs.weight(e) else { return rhs.weight(e) }
+            guard let rweight = rhs.weight(e) else { return lhs.weight(e) }
+            return lweight + rweight
+        }
+    }
+}
+
+extension WeightCarrying where G: DirectedGraphProtocol {
+    
+    static func * <H> (lhs: WeightCarrying, rhs: WeightCarrying<H>) -> WeightCarrying
+        where
+        H: DirectedGraphProtocol,
+        H.Node == G.Node,
+        H.Weight == G.Weight
+    {
+        return WeightCarrying { e in
+            guard let lweight = lhs.weight(e), let rweight = rhs.weight(H.Edge(e.a, e.b))
+                else { return nil }
+            return lweight * rweight
+        }
+    }
+    
+    static func * <H> (lhs: WeightCarrying, rhs: AdjacencyCarrying<H>) -> WeightCarrying
+        where
+        H: DirectedGraphProtocol,
+        H.Node == G.Node
+    {
+        return WeightCarrying { e in rhs.contains(H.Edge(e.a,e.b)) ? lhs.weight(e) : nil }
+    }
+    
+    static func * <H> (lhs: AdjacencyCarrying<H>, rhs: WeightCarrying) -> WeightCarrying
+        where
+        H: DirectedGraphProtocol,
+        H.Node == G.Node
+    {
+        return WeightCarrying { e in lhs.contains(H.Edge(e.a,e.b)) ? rhs.weight(e) : nil }
+    }
+}
+
-- 
2.17.2 (Apple Git-113)


From ce6cd417a0965ea31eb0cff512a8ad09bc6030f5 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Fri, 2 Nov 2018 19:57:40 -0400
Subject: [PATCH 31/66] Spell individual pitches (#148)

---
 .../Wetherfield/WeightCarrying.swift            |  2 +-
 .../PitchSpeller/Wetherfield/Wetherfield.swift  | 17 ++++++++++++++++-
 2 files changed, 17 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
index 0a935e5..947c35a 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
@@ -16,7 +16,7 @@ struct WeightCarrying<G: WeightedGraphProtocol> {
     
     func weight (from start: G.Node, to end: G.Node) -> G.Weight? {
         return weight(G.Edge(start, end))
-		}
+    }
 
     func pullback <H: WeightedGraphProtocol> (_ f: @escaping (H.Node) -> G.Node) -> WeightCarrying<H>
         where H.Weight == G.Weight
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 8d91ead..211e5b2 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -15,6 +15,21 @@ protocol PitchSpellingNode: Hashable {
 
 struct PitchSpeller {
 
+    // FIXME: Flesh out for all tendencies
+    static let tendencyGraph: WeightedGraph<Tendency,Double> = WeightedGraph(
+        [
+            .up,
+            .down
+        ],
+        [
+            UnorderedPair(.up,.up): 1,
+            UnorderedPair(.down, .down): 1
+        ]
+    )
+
+    static let weightCarrying = WeightCarrying.build(from: PitchSpeller.tendencyGraph)
+    static let tendencyMask: WeightCarrying<WeightedGraph<Cross<Int,Tendency>,Double>> = weightCarrying.pullback { $0.b }
+
     struct UnassignedNode: PitchSpellingNode {
         let index: Index
     }
@@ -75,6 +90,7 @@ struct PitchSpeller {
             sink: PitchSpellingNode.Index(-1, .up),
             internalNodes: pitchNodes
         )
+        flowNetwork.mask(PitchSpeller.tendencyMask)
     }
 
     /// - Returns: An array of `SpelledPitch` values with the same indices as the original
@@ -89,7 +105,6 @@ struct PitchSpeller {
             let upNodes = sinkSide.map { index in AssignedNode(index, .up) }
             return downNodes + upNodes
         }
-
         return assignedNodes
             .reduce(into: [Int: (AssignedNode, AssignedNode)]()) { pairs, node in
                 if !pairs.keys.contains(node.index.a) {
-- 
2.17.2 (Apple Git-113)


From 53709b2dbc569b4b63a6fbb2e559def5f57e670c Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 3 Nov 2018 14:57:48 -0400
Subject: [PATCH 32/66] Graph schemes (#155)

---
 .../Wetherfield/DirectedGraphProtocol.swift   | 19 ++++++++
 .../DirectedGraphSchemeProtocol.swift         | 10 +++++
 .../Wetherfield/GraphScheme.swift             | 19 ++++++++
 .../Wetherfield/GraphSchemeProtocol.swift     | 21 +++++++++
 .../UndirectedGraphSchemeProtocol.swift       | 10 +++++
 .../UnweightedGraphSchemeProtocol.swift       | 21 +++++++++
 .../WeightedDirectedGraphSchema.swift         | 19 ++++++++
 .../Wetherfield/WeightedGraphScheme.swift     | 19 ++++++++
 .../WeightedGraphSchemeProtocol.swift         | 45 +++++++++++++++++++
 9 files changed, 183 insertions(+)
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
new file mode 100644
index 0000000..5ada6c7
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
@@ -0,0 +1,19 @@
+//
+//  DirectedGraphProtocol.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+struct DirectedGraphScheme <Node>: DirectedGraphSchemeProtocol, UnweightedGraphSchemeProtocol {
+    
+    typealias Edge = OrderedPair<Node>
+    
+    var contains: (Edge) -> Bool
+    
+    init (_ contains: @escaping (Edge) -> Bool) {
+        self.contains = contains
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift
new file mode 100644
index 0000000..a0814cf
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift
@@ -0,0 +1,10 @@
+//
+//  DirectedGraphSchemeProtocol.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+protocol DirectedGraphSchemeProtocol: GraphSchemeProtocol where Edge == OrderedPair<Node> { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
new file mode 100644
index 0000000..88a1f8b
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
@@ -0,0 +1,19 @@
+//
+//  GraphScheme.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeProtocol {
+    
+    typealias Edge = UnorderedPair<Node>
+    
+    var contains: (Edge) -> Bool
+    
+    init (_ contains: @escaping (Edge) -> Bool) {
+        self.contains = contains
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
new file mode 100644
index 0000000..ad11593
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
@@ -0,0 +1,21 @@
+//
+//  GraphSchemeProtocol.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+protocol GraphSchemeProtocol {
+    associatedtype Node
+    associatedtype Edge: SymmetricPair where Edge.A == Node
+}
+
+extension GraphProtocol {
+    func adjacencyScheme <G> (_ f: @escaping (G.Node) -> Node) -> AdjacencyCarrying<G> where
+        G: GraphProtocol
+    {
+        return AdjacencyCarrying.build(from: self).pullback(f)
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift
new file mode 100644
index 0000000..1184b5f
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift
@@ -0,0 +1,10 @@
+//
+//  UndirectedGraphSchemeProtocol.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+protocol UndirectedGraphSchemeProtocol: GraphSchemeProtocol where Edge == UnorderedPair<Node> { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
new file mode 100644
index 0000000..4cea885
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -0,0 +1,21 @@
+//
+//  UnweightedGraphSchemeProtocol.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+protocol UnweightedGraphSchemeProtocol: GraphSchemeProtocol {
+    var contains: (Edge) -> Bool { get }
+    
+    init (_ contains: @escaping (Edge) -> Bool)
+}
+
+extension UnweightedGraphSchemeProtocol {
+    @inlinable
+    func pullback <H> (_ f: @escaping (H.Node) -> Node) -> H where H: UnweightedGraphSchemeProtocol {
+        return H.init { self.contains(Edge(f($0.a),f($0.b))) }
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift
new file mode 100644
index 0000000..854f9c8
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift
@@ -0,0 +1,19 @@
+//
+//  WeightedDirectedGraphSchema.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+struct WeightedDirectedGraphScheme <Node,Weight>: DirectedGraphSchemeProtocol, WeightedGraphSchemeProtocol {
+    
+    typealias Edge = OrderedPair<Node>
+    
+    var weight: (Edge) -> Weight?
+    
+    init (_ weight: @escaping (Edge) -> Weight?) {
+        self.weight = weight
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
new file mode 100644
index 0000000..3f74b7e
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
@@ -0,0 +1,19 @@
+//
+//  WeightedGraphScheme.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+struct WeightedGraphScheme <Node,Weight>: UndirectedGraphSchemeProtocol, WeightedGraphSchemeProtocol {
+    
+    typealias Edge = UnorderedPair<Node>
+    
+    var weight: (Edge) -> Weight?
+    
+    init (_ weight: @escaping (Edge) -> Weight?) {
+        self.weight = weight
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
new file mode 100644
index 0000000..13a6a5e
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
@@ -0,0 +1,45 @@
+//
+//  WeightedGraphSchemeProtocol.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+protocol WeightedGraphSchemeProtocol: GraphSchemeProtocol {
+    associatedtype Weight
+    
+    var weight: (Edge) -> Weight? { get }
+    
+    init (_ weight: @escaping (Edge) -> Weight?)
+}
+
+extension WeightedGraphSchemeProtocol {
+    @inlinable
+    func pullback <H> (_ f: @escaping (H.Node) -> Node) -> H where
+        H: WeightedGraphSchemeProtocol,
+        H.Weight == Weight
+    {
+        return H.init { self.weight(Edge(f($0.a),f($0.b))) }
+    }
+}
+
+extension WeightedGraphSchemeProtocol {
+    @inlinable
+    func unweighted <H> () -> H where
+        H: UnweightedGraphSchemeProtocol,
+        H.Edge == Edge
+    {
+        return H.init { self.weight($0) != nil }
+    }
+}
+
+extension WeightedGraphProtocol {
+    func weightScheme <G> (_ f: @escaping (G.Node) -> Node) -> WeightCarrying<G> where
+        G: WeightedGraphProtocol,
+        G.Weight == Weight
+    {
+        return WeightCarrying.build(from: self).pullback(f)
+    }
+}
-- 
2.17.2 (Apple Git-113)


From 272c80774a08610fef0783ec0529b01231e175f5 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 3 Nov 2018 21:05:00 -0400
Subject: [PATCH 33/66] Switch out WeightCarrying for AdjacencyCarrying...
 (#153)

---
 .../PitchSpeller/Wetherfield/FlowNetwork.swift        |  8 ++++++++
 .../PitchSpeller/Wetherfield/Wetherfield.swift        | 11 ++++++-----
 2 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 66ff95f..faf9a3a 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -51,6 +51,14 @@ extension FlowNetwork {
             }
         }
     }
+    
+    mutating func mask <G: GraphProtocol> (_ adjacencyCarrying: AdjacencyCarrying<G>)
+        where Node == G.Node
+    {
+        for edge in edges {
+            if !adjacencyCarrying.contains(from: edge.a, to: edge.b) { remove(edge) }
+        }
+    }
 }
 
 extension FlowNetwork {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 211e5b2..6df5600 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -16,19 +16,20 @@ protocol PitchSpellingNode: Hashable {
 struct PitchSpeller {
 
     // FIXME: Flesh out for all tendencies
-    static let tendencyGraph: WeightedGraph<Tendency,Double> = WeightedGraph(
+    static let tendencyGraph: Graph<Tendency> = Graph(
         [
             .up,
             .down
         ],
         [
-            UnorderedPair(.up,.up): 1,
-            UnorderedPair(.down, .down): 1
+            UnorderedPair(.up,.up),
+            UnorderedPair(.down,.down)
         ]
     )
 
-    static let weightCarrying = WeightCarrying.build(from: PitchSpeller.tendencyGraph)
-    static let tendencyMask: WeightCarrying<WeightedGraph<Cross<Int,Tendency>,Double>> = weightCarrying.pullback { $0.b }
+    static let adjacencyCarrying = AdjacencyCarrying.build(from: PitchSpeller.tendencyGraph)
+    static let tendencyMask: AdjacencyCarrying<Graph<Cross<Int,Tendency>>>
+        = adjacencyCarrying.pullback { $0.b }
 
     struct UnassignedNode: PitchSpellingNode {
         let index: Index
-- 
2.17.2 (Apple Git-113)


From 286e0b5cea0127bc653cc338a5f589771428b67e Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 3 Nov 2018 21:46:48 -0400
Subject: [PATCH 34/66] Refactor flow network indices as casewise sink, source
 or internal (#151)

* Refactor flow network indices as casewise sink, source or internal

* Add closure based builder for WeightCarrying

and AdjacencyCarrying

* Switch weighted carrying for adjacency carrying

* Remove commented code
---
 .../Wetherfield/AdjacencyCarrying.swift       |  4 ++
 .../Wetherfield/WeightCarrying.swift          |  4 ++
 .../Wetherfield/Wetherfield.swift             | 71 +++++++++++--------
 3 files changed, 51 insertions(+), 28 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
index 51c3d09..c3c32ca 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
@@ -25,6 +25,10 @@ struct AdjacencyCarrying <G: GraphProtocol> {
     static func build (from g: G) -> AdjacencyCarrying {
         return AdjacencyCarrying(contains: g.contains)
     }
+    
+    static func build (_ contains: @escaping (G.Edge) -> Bool) -> AdjacencyCarrying {
+        return AdjacencyCarrying(contains: contains)
+    }
 }
 
 extension AdjacencyCarrying {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
index 947c35a..ecbf260 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
@@ -27,6 +27,10 @@ struct WeightCarrying<G: WeightedGraphProtocol> {
     static func build (from g: G) -> WeightCarrying {
         return WeightCarrying(weight: g.weight)
     }
+    
+    static func build (_ weight: @escaping (G.Edge) -> G.Weight?) -> WeightCarrying {
+        return WeightCarrying(weight: weight)
+    }
 }
 
 extension WeightCarrying {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 6df5600..63aefb6 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -8,8 +8,14 @@
 import DataStructures
 import Pitch
 
+enum FlowNode<Index>: Hashable where Index: Hashable {
+    case `internal`(Index)
+    case source
+    case sink
+}
+
 protocol PitchSpellingNode: Hashable {
-    typealias Index = Cross<Int,Tendency>
+    typealias Index = FlowNode<Cross<Int,Tendency>>
     var index: Index { get }
 }
 
@@ -28,8 +34,13 @@ struct PitchSpeller {
     )
 
     static let adjacencyCarrying = AdjacencyCarrying.build(from: PitchSpeller.tendencyGraph)
-    static let tendencyMask: AdjacencyCarrying<Graph<Cross<Int,Tendency>>>
-        = adjacencyCarrying.pullback { $0.b }
+    static let tendencyMask: AdjacencyCarrying<Graph<FlowNode<Cross<Int,Tendency>>>> = adjacencyCarrying.pullback {
+        switch $0 {
+        case .source: return .down
+        case .sink: return .up
+        case .`internal`(let index): return index.b
+        }
+    }
 
     struct UnassignedNode: PitchSpellingNode {
         let index: Index
@@ -43,19 +54,21 @@ struct PitchSpeller {
             self.assignment = assignment
         }
     }
-
-    /// - Returns: The nodes for the `Pitch` at the given `index`.
-    private static func nodes(pitchAtIndex index: Int)
-        -> (PitchSpellingNode.Index, PitchSpellingNode.Index)
-    {
-        return (.init(index, .down), .init(index, .up))
+    
+    struct InternalAssignedNode {
+        let index: Cross<Int, Tendency>
+        let assignment: Tendency
+        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
     }
 
     /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
     /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
     /// the given `Pitch`.)
     private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-        return .init(offset, index)
+        return .`internal`(.init(offset, index))
     }
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
@@ -70,7 +83,7 @@ struct PitchSpeller {
     let parsimonyPivot: Pitch.Spelling
 
     /// The unspelled `Pitch` values to be spelled.
-    let pitches: [Int: Pitch]
+    let pitch: (PitchSpellingNode.Index) -> Pitch?
 
     /// The nodes within the `FlowNetwork`. The values are the encodings of the indices of `Pitch`
     /// values in `pitches.
@@ -83,12 +96,19 @@ struct PitchSpeller {
 
     /// Create a `PitchSpeller` to spell the given `pitches`, with the given `parsimonyPivot`.
     init(pitches: [Int: Pitch], parsimonyPivot: Pitch.Spelling = .init(.d)) {
-        self.pitches = pitches
+        self.pitch = { index in
+            switch index {
+            case .source, .sink:
+                return Pitch(value: parsimonyPivot.pitchClass.value)
+            case .`internal`(let cross):
+                return pitches[cross.a]
+            }
+        }
         self.parsimonyPivot = parsimonyPivot
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
-            source: PitchSpellingNode.Index(-1, .down),
-            sink: PitchSpellingNode.Index(-1, .up),
+            source: .source,
+            sink: .sink,
             internalNodes: pitchNodes
         )
         flowNetwork.mask(PitchSpeller.tendencyMask)
@@ -107,7 +127,13 @@ struct PitchSpeller {
             return downNodes + upNodes
         }
         return assignedNodes
-            .reduce(into: [Int: (AssignedNode, AssignedNode)]()) { pairs, node in
+            .compactMap { (assignedNode) -> InternalAssignedNode? in
+                switch assignedNode.index {
+                case .source, .sink: return nil
+                case .`internal`(let index): return InternalAssignedNode(index, assignedNode.assignment)
+                }
+            }
+            .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
                 if !pairs.keys.contains(node.index.a) {
                     pairs[node.index.a] = (node, node)
                 }
@@ -118,17 +144,12 @@ struct PitchSpeller {
             }.mapValues(spellPitch)
     }
 
-    private func spellPitch(_ up: AssignedNode, _ down: AssignedNode) -> SpelledPitch {
-        let pitch = self.pitch(node: up.index)
+    private func spellPitch(_ up: InternalAssignedNode, _ down: InternalAssignedNode) -> SpelledPitch {
+        let pitch = self.pitch(.`internal`(up.index))!
         let tendencies = TendencyPair(up.assignment, down.assignment)
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
-
-    /// - Returns: The `Pitch` value for the given `node` value.
-    private func pitch(node: PitchSpellingNode.Index) -> Pitch {
-        return pitches[node.a]!
-    }
 }
 
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
@@ -144,12 +165,6 @@ extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     }
 }
 
-extension PitchSpeller.AssignedNode: Comparable {
-    static func < (lhs: PitchSpeller.AssignedNode, rhs: PitchSpeller.AssignedNode) -> Bool {
-        return lhs.index < rhs.index
-    }
-}
-
 extension WeightedDirectedGraph {
     /// Create a `DirectedGraph` which is hooked up as necessary for the Wetherfield pitch-spelling process.
     init(source: Node, sink: Node, internalNodes: [Node]) {
-- 
2.17.2 (Apple Git-113)


From 1ec9148708a4b1cd32d630ad90d2dcd0949873cb Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 4 Nov 2018 01:37:53 -0400
Subject: [PATCH 35/66] Graph schemes (#156)

* Add weightScheme and adjacencyScheme constructors

* Move weightScheme pullback

* Move adjacencyScheme pullback

* Make scheme protocols public

* Add weightScheme initializer to WeightedGraphProtocol

* Add weightedScheme constructor

* Add public permission to Carrying structs
---
 .../Wetherfield/AdjacencyCarrying.swift       |  2 +-
 .../DirectedGraphSchemeProtocol.swift         |  2 +-
 .../Wetherfield/GraphSchemeProtocol.swift     |  2 +-
 .../UndirectedGraphSchemeProtocol.swift       |  2 +-
 .../UnweightedGraphSchemeProtocol.swift       |  2 +-
 .../Wetherfield/WeightCarrying.swift          | 13 +++++++++++-
 .../WeightedGraphProtocolExtension.swift      | 20 +++++++++++++++++++
 .../WeightedGraphSchemeProtocol.swift         |  2 +-
 8 files changed, 38 insertions(+), 7 deletions(-)
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphProtocolExtension.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
index c3c32ca..d0a56c8 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
@@ -7,7 +7,7 @@
 
 import DataStructures
 
-struct AdjacencyCarrying <G: GraphProtocol> {
+public struct AdjacencyCarrying <G: GraphProtocol> {
     let contains: (G.Edge) -> Bool
     
     private init (contains: @escaping (G.Edge) -> Bool) {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift
index a0814cf..955f7c2 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphSchemeProtocol.swift
@@ -7,4 +7,4 @@
 
 import DataStructures
 
-protocol DirectedGraphSchemeProtocol: GraphSchemeProtocol where Edge == OrderedPair<Node> { }
+public protocol DirectedGraphSchemeProtocol: GraphSchemeProtocol where Edge == OrderedPair<Node> { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
index ad11593..2b3a6c1 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
@@ -7,7 +7,7 @@
 
 import DataStructures
 
-protocol GraphSchemeProtocol {
+public protocol GraphSchemeProtocol {
     associatedtype Node
     associatedtype Edge: SymmetricPair where Edge.A == Node
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift
index 1184b5f..e6d1520 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UndirectedGraphSchemeProtocol.swift
@@ -7,4 +7,4 @@
 
 import DataStructures
 
-protocol UndirectedGraphSchemeProtocol: GraphSchemeProtocol where Edge == UnorderedPair<Node> { }
+public protocol UndirectedGraphSchemeProtocol: GraphSchemeProtocol where Edge == UnorderedPair<Node> { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 4cea885..83bf759 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -7,7 +7,7 @@
 
 import DataStructures
 
-protocol UnweightedGraphSchemeProtocol: GraphSchemeProtocol {
+public protocol UnweightedGraphSchemeProtocol: GraphSchemeProtocol {
     var contains: (Edge) -> Bool { get }
     
     init (_ contains: @escaping (Edge) -> Bool)
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
index ecbf260..8a11396 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
@@ -7,7 +7,7 @@
 
 import DataStructures
 
-struct WeightCarrying<G: WeightedGraphProtocol> {
+public struct WeightCarrying<G: WeightedGraphProtocol> {
     let weight: (G.Edge) -> G.Weight?
     
     private init (weight: @escaping (G.Edge) -> G.Weight?) {
@@ -73,6 +73,17 @@ extension WeightCarrying {
     }
 }
 
+extension WeightCarrying {
+    
+    func weightedScheme <Scheme: WeightedGraphSchemeProtocol> () -> Scheme where
+        Scheme.Edge == G.Edge,
+        Scheme.Node == G.Node,
+        Scheme.Weight == G.Weight
+    {
+        return Scheme.init(weight)
+    }
+}
+
 extension WeightCarrying where G: DirectedGraphProtocol {
     
     static func * <H> (lhs: WeightCarrying, rhs: WeightCarrying<H>) -> WeightCarrying
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphProtocolExtension.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphProtocolExtension.swift
new file mode 100644
index 0000000..4ea02d7
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphProtocolExtension.swift
@@ -0,0 +1,20 @@
+//
+//  WeightedGraphProtocolExtension.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 03/11/2018.
+//
+
+import DataStructures
+
+extension WeightedGraphProtocol {
+    @inlinable
+    func weightScheme <G> () -> G where
+        G: WeightedGraphSchemeProtocol,
+        G.Edge == Edge,
+        G.Weight == Weight,
+        G.Node == Node
+    {
+        return G.init(self.weight)
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
index 13a6a5e..dce5b8b 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
@@ -7,7 +7,7 @@
 
 import DataStructures
 
-protocol WeightedGraphSchemeProtocol: GraphSchemeProtocol {
+public protocol WeightedGraphSchemeProtocol: GraphSchemeProtocol {
     associatedtype Weight
     
     var weight: (Edge) -> Weight? { get }
-- 
2.17.2 (Apple Git-113)


From 69b87875d01671e4e466afd886dec564144bae0d Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 4 Nov 2018 01:41:52 -0400
Subject: [PATCH 36/66] Make switch style clearer (#157)

---
 .../SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift   | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 63aefb6..e1820d5 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -34,8 +34,8 @@ struct PitchSpeller {
     )
 
     static let adjacencyCarrying = AdjacencyCarrying.build(from: PitchSpeller.tendencyGraph)
-    static let tendencyMask: AdjacencyCarrying<Graph<FlowNode<Cross<Int,Tendency>>>> = adjacencyCarrying.pullback {
-        switch $0 {
+    static let tendencyMask: AdjacencyCarrying<Graph<FlowNode<Cross<Int,Tendency>>>> = adjacencyCarrying.pullback { node in
+        switch node {
         case .source: return .down
         case .sink: return .up
         case .`internal`(let index): return index.b
-- 
2.17.2 (Apple Git-113)


From 66f5b1ca2fb505526fb1cc4d7a5cc524e5383869 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 4 Nov 2018 20:33:50 -0500
Subject: [PATCH 37/66] Cnatural, Bnatural, etc (white notes) parsimony pivot
 (#158)

---
 .../Wetherfield/FlowNetwork.swift             |   6 +
 .../Wetherfield/GraphSchemeProtocol.swift     |   8 +-
 .../Wetherfield/Pitch.Spelling.Category.swift |   4 +-
 .../UnweightedGraphSchemeProtocol.swift       |  11 ++
 .../Wetherfield/Wetherfield.swift             | 130 ++++++++++++++----
 5 files changed, 127 insertions(+), 32 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index faf9a3a..a90e690 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -59,6 +59,12 @@ extension FlowNetwork {
             if !adjacencyCarrying.contains(from: edge.a, to: edge.b) { remove(edge) }
         }
     }
+    
+    mutating func mask (_ adjacencyScheme: GraphScheme<Node>) {
+        for edge in edges where !adjacencyScheme.contains(GraphScheme<Node>.Edge(edge.a, edge.b)) {
+            remove(edge)
+        }
+    }
 }
 
 extension FlowNetwork {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
index 2b3a6c1..91d2899 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
@@ -13,9 +13,11 @@ public protocol GraphSchemeProtocol {
 }
 
 extension GraphProtocol {
-    func adjacencyScheme <G> (_ f: @escaping (G.Node) -> Node) -> AdjacencyCarrying<G> where
-        G: GraphProtocol
+    func adjacencyScheme <G> () -> G where
+        G: UnweightedGraphSchemeProtocol,
+        G.Edge == Edge,
+        G.Node == Node
     {
-        return AdjacencyCarrying.build(from: self).pullback(f)
+        return G.init(self.contains)
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 060a1f9..fe6ebd0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -220,7 +220,9 @@ extension Pitch.Spelling.Category.Five: TendencyConverting {
     static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
         return [
             .init(.down,.down): .down,
-            .init(.up,.down): .up
+            .init(.down,.up): .down,
+            .init(.up,.down): .up,
+            .init(.up,.up): .up
         ]
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 83bf759..1aae3f1 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -19,3 +19,14 @@ extension UnweightedGraphSchemeProtocol {
         return H.init { self.contains(Edge(f($0.a),f($0.b))) }
     }
 }
+
+extension UnweightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol {
+    
+    static func * (lhs: Self, rhs: Self) -> Self {
+        return Self.init { edge in lhs.contains(edge) && rhs.contains(edge) }
+    }
+    
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self.init { edge in lhs.contains(edge) || rhs.contains(edge) }
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index e1820d5..2b9e496 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -19,28 +19,17 @@ protocol PitchSpellingNode: Hashable {
     var index: Index { get }
 }
 
-struct PitchSpeller {
-
-    // FIXME: Flesh out for all tendencies
-    static let tendencyGraph: Graph<Tendency> = Graph(
-        [
-            .up,
-            .down
-        ],
-        [
-            UnorderedPair(.up,.up),
-            UnorderedPair(.down,.down)
-        ]
-    )
-
-    static let adjacencyCarrying = AdjacencyCarrying.build(from: PitchSpeller.tendencyGraph)
-    static let tendencyMask: AdjacencyCarrying<Graph<FlowNode<Cross<Int,Tendency>>>> = adjacencyCarrying.pullback { node in
-        switch node {
+extension FlowNode where Index == Cross<Int,Tendency> {
+    var tendency: Tendency {
+        switch self {
         case .source: return .down
-        case .sink: return .up
-        case .`internal`(let index): return index.b
+        case.sink: return .up
+        case.internal(let index): return index.b
         }
     }
+}
+
+struct PitchSpeller {
 
     struct UnassignedNode: PitchSpellingNode {
         let index: Index
@@ -63,12 +52,74 @@ struct PitchSpeller {
             self.assignment = assignment
         }
     }
+    
+    // FIXME: Flesh out for all tendencies
+    static let tendencyGraph: Graph<Tendency> = Graph(
+        [
+            .up,
+            .down
+        ],
+        [
+            UnorderedPair(.up,.up),
+            UnorderedPair(.down,.down)
+        ]
+    )
+    
+    // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
+    // be connected to `(8, .up)` in the spelling dependency model.
+    static let eightTendencyLink: [(Pitch.Class, Tendency)] = [
+        (00, .down),
+        (01, .up),
+        (03, .down),
+        (04, .up),
+        (05, .down),
+        (06, .up),
+        (07, .down),
+        (08, .up),
+        (09, .up),
+        (10, .down),
+        (11, .up)
+    ]
+    
+    // Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
+    static let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
+        PitchSpeller.eightTendencyLink.lazy
+            .map { pitchClass, tendency in
+                .init(pitchClass, tendency)
+            }.map { cross in
+                .init(cross, .init(8, .up))
+        }
+    )
+    
+    static let sameTendencyScheme: GraphScheme = tendencyGraph.adjacencyScheme()
+    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
+        = sameTendencyScheme.pullback { node in
+            switch node {
+            case .source: return .down
+            case .sink: return .up
+            case .internal(let index): return index.b
+            }
+    }
+    
+    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
+        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                edge.contains(pitchClass)
+            }
+        }
+        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                !edge.contains(pitchClass)
+            }
+        }
+        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
+    }
 
     /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
     /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
     /// the given `Pitch`.)
     private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-        return .`internal`(.init(offset, index))
+        return .internal(.init(offset, index))
     }
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
@@ -79,9 +130,6 @@ struct PitchSpeller {
 
     // MARK: - Instance Properties
 
-    /// The omnipresent, tie-breaking `Pitch.Spelling` value.
-    let parsimonyPivot: Pitch.Spelling
-
     /// The unspelled `Pitch` values to be spelled.
     let pitch: (PitchSpellingNode.Index) -> Pitch?
 
@@ -91,6 +139,9 @@ struct PitchSpeller {
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
     var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
+    
+    /// Getter for pitch class (from Index)
+    let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 
     // MARK: - Initializers
 
@@ -100,18 +151,31 @@ struct PitchSpeller {
             switch index {
             case .source, .sink:
                 return Pitch(value: parsimonyPivot.pitchClass.value)
-            case .`internal`(let cross):
+            case .internal(let cross):
                 return pitches[cross.a]
             }
         }
-        self.parsimonyPivot = parsimonyPivot
+        let getPitchClass: (FlowNode<Cross<Int,Tendency>>) -> Pitch.Class = { flowNode in
+            switch flowNode {
+            case .source, .sink:
+                return parsimonyPivot.pitchClass
+            case .internal(let cross):
+                return pitches[cross.a]!.class
+            }
+        }
+        self.getPitchClass = getPitchClass
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
             source: .source,
             sink: .sink,
             internalNodes: pitchNodes
         )
-        flowNetwork.mask(PitchSpeller.tendencyMask)
+        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(PitchSpeller.eightLookup.contains)
+        let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
+            .init(getPitchClass(flowNode), flowNode.tendency)
+        }
+        flowNetwork.mask((PitchSpeller.connectSameTendencies * whereEdge(contains: false)(8)) +
+            (connectToEight * whereEdge(contains: true)(8)) )
     }
 
     /// - Returns: An array of `SpelledPitch` values with the same indices as the original
@@ -130,7 +194,7 @@ struct PitchSpeller {
             .compactMap { (assignedNode) -> InternalAssignedNode? in
                 switch assignedNode.index {
                 case .source, .sink: return nil
-                case .`internal`(let index): return InternalAssignedNode(index, assignedNode.assignment)
+                case .internal(let index): return InternalAssignedNode(index, assignedNode.assignment)
                 }
             }
             .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
@@ -145,11 +209,21 @@ struct PitchSpeller {
     }
 
     private func spellPitch(_ up: InternalAssignedNode, _ down: InternalAssignedNode) -> SpelledPitch {
-        let pitch = self.pitch(.`internal`(up.index))!
+        let pitch = self.pitch(.internal(up.index))!
         let tendencies = TendencyPair(up.assignment, down.assignment)
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
+    
+    func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
+        func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
+            return PitchSpeller.adjacencyScheme(contains: true)(8).pullback(getPitchClass)
+        }
+        func doesNotContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
+            return PitchSpeller.adjacencyScheme(contains: false)(8).pullback(getPitchClass)
+        }
+        return contains ? doesContain : doesNotContain
+    }
 }
 
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
-- 
2.17.2 (Apple Git-113)


From 721438d19eab6798cf4312c140452401e5318b3d Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sun, 4 Nov 2018 23:03:32 -0500
Subject: [PATCH 38/66] Remove tendency graph (#160)

---
 .../Wetherfield/Wetherfield.swift             | 26 +++++--------------
 1 file changed, 7 insertions(+), 19 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 2b9e496..b3b8e0a 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -53,18 +53,6 @@ struct PitchSpeller {
         }
     }
     
-    // FIXME: Flesh out for all tendencies
-    static let tendencyGraph: Graph<Tendency> = Graph(
-        [
-            .up,
-            .down
-        ],
-        [
-            UnorderedPair(.up,.up),
-            UnorderedPair(.down,.down)
-        ]
-    )
-    
     // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
     // be connected to `(8, .up)` in the spelling dependency model.
     static let eightTendencyLink: [(Pitch.Class, Tendency)] = [
@@ -91,15 +79,15 @@ struct PitchSpeller {
         }
     )
     
-    static let sameTendencyScheme: GraphScheme = tendencyGraph.adjacencyScheme()
     static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
-        = sameTendencyScheme.pullback { node in
-            switch node {
-            case .source: return .down
-            case .sink: return .up
-            case .internal(let index): return index.b
+        = GraphScheme<Tendency> { edge in edge.a == edge.b }
+            .pullback { node in
+                switch node {
+                case .source: return .down
+                case .sink: return .up
+                case .internal(let index): return index.b
+                }
             }
-    }
     
     static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
         func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-- 
2.17.2 (Apple Git-113)


From 674fdd183e6cfc1532823f15e0cfdba349f3f10d Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sun, 4 Nov 2018 23:27:50 -0500
Subject: [PATCH 39/66] [NFC] Streamline eightLookup chained lazy map functions
 (#161)

---
 .../PitchSpeller/Wetherfield/Wetherfield.swift             | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index b3b8e0a..c6e1e3a 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -71,12 +71,7 @@ struct PitchSpeller {
     
     // Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
     static let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
-        PitchSpeller.eightTendencyLink.lazy
-            .map { pitchClass, tendency in
-                .init(pitchClass, tendency)
-            }.map { cross in
-                .init(cross, .init(8, .up))
-        }
+        PitchSpeller.eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
     )
     
     static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
-- 
2.17.2 (Apple Git-113)


From 054813fb5c5527ce47df42d928e2ec56c55160d2 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sun, 4 Nov 2018 23:43:22 -0500
Subject: [PATCH 40/66] [NFC] Use FlowNode.tendency (#162)

---
 .../Wetherfield/Wetherfield.swift             | 24 +++++++------------
 1 file changed, 8 insertions(+), 16 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index c6e1e3a..29c9656 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -14,21 +14,21 @@ enum FlowNode<Index>: Hashable where Index: Hashable {
     case sink
 }
 
-protocol PitchSpellingNode: Hashable {
-    typealias Index = FlowNode<Cross<Int,Tendency>>
-    var index: Index { get }
-}
-
 extension FlowNode where Index == Cross<Int,Tendency> {
     var tendency: Tendency {
         switch self {
         case .source: return .down
-        case.sink: return .up
-        case.internal(let index): return index.b
+        case .sink: return .up
+        case .internal(let index): return index.b
         }
     }
 }
 
+protocol PitchSpellingNode: Hashable {
+    typealias Index = FlowNode<Cross<Int,Tendency>>
+    var index: Index { get }
+}
+
 struct PitchSpeller {
 
     struct UnassignedNode: PitchSpellingNode {
@@ -74,15 +74,7 @@ struct PitchSpeller {
         PitchSpeller.eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
     )
     
-    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
-        = GraphScheme<Tendency> { edge in edge.a == edge.b }
-            .pullback { node in
-                switch node {
-                case .source: return .down
-                case .sink: return .up
-                case .internal(let index): return index.b
-                }
-            }
+    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> = GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
     
     static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
         func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-- 
2.17.2 (Apple Git-113)


From 1e0058259f74e7fd5a1c8359afa83d6e064ed420 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Mon, 5 Nov 2018 00:02:22 -0500
Subject: [PATCH 41/66] Spell self as pivot correctly (#163)

---
 .../PitchSpeller/Wetherfield/Wetherfield.swift       | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 29c9656..603f704 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -149,8 +149,12 @@ struct PitchSpeller {
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
             .init(getPitchClass(flowNode), flowNode.tendency)
         }
-        flowNetwork.mask((PitchSpeller.connectSameTendencies * whereEdge(contains: false)(8)) +
-            (connectToEight * whereEdge(contains: true)(8)) )
+        let connectedToTwoNotEight = PitchSpeller.connectSameTendencies * whereEdge(contains: false)(8) * whereEdge(contains: true)(2)
+        let sameClass = PitchSpeller.connectSameTendencies * GraphScheme<Pitch.Class> { edge in
+            edge.a == edge.b }
+            .pullback(getPitchClass)
+        let connectedToEight = connectToEight * whereEdge(contains: true)(8)
+        flowNetwork.mask(connectedToTwoNotEight + sameClass + connectedToEight)
     }
 
     /// - Returns: An array of `SpelledPitch` values with the same indices as the original
@@ -192,10 +196,10 @@ struct PitchSpeller {
     
     func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
         func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-            return PitchSpeller.adjacencyScheme(contains: true)(8).pullback(getPitchClass)
+            return PitchSpeller.adjacencyScheme(contains: true)(pitchClass).pullback(getPitchClass)
         }
         func doesNotContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-            return PitchSpeller.adjacencyScheme(contains: false)(8).pullback(getPitchClass)
+            return PitchSpeller.adjacencyScheme(contains: false)(pitchClass).pullback(getPitchClass)
         }
         return contains ? doesContain : doesNotContain
     }
-- 
2.17.2 (Apple Git-113)


From 6bfc711603ed2240beb6162f66ced0718d845b64 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 00:03:05 -0500
Subject: [PATCH 42/66] [NFC] Reorganize PitchSpeller struct into extensions
 (#165)

---
 .../Wetherfield/Wetherfield.swift             | 180 ++++++++++--------
 1 file changed, 104 insertions(+), 76 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 603f704..013035c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -31,78 +31,6 @@ protocol PitchSpellingNode: Hashable {
 
 struct PitchSpeller {
 
-    struct UnassignedNode: PitchSpellingNode {
-        let index: Index
-    }
-
-    struct AssignedNode: PitchSpellingNode {
-        let index: Index
-        let assignment: Tendency
-        init(_ index: Index, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-    
-    struct InternalAssignedNode {
-        let index: Cross<Int, Tendency>
-        let assignment: Tendency
-        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-    
-    // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
-    // be connected to `(8, .up)` in the spelling dependency model.
-    static let eightTendencyLink: [(Pitch.Class, Tendency)] = [
-        (00, .down),
-        (01, .up),
-        (03, .down),
-        (04, .up),
-        (05, .down),
-        (06, .up),
-        (07, .down),
-        (08, .up),
-        (09, .up),
-        (10, .down),
-        (11, .up)
-    ]
-    
-    // Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
-    static let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
-        PitchSpeller.eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
-    )
-    
-    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> = GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
-    
-    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
-        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-            return GraphScheme<Pitch.Class> { edge in
-                edge.contains(pitchClass)
-            }
-        }
-        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-            return GraphScheme<Pitch.Class> { edge in
-                !edge.contains(pitchClass)
-            }
-        }
-        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
-    }
-
-    /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
-    /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
-    /// the given `Pitch`.)
-    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-        return .internal(.init(offset, index))
-    }
-
-    /// - Returns: An array of nodes, each representing the index of the unassigned node in
-    /// `pitchNodes`.
-    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
-        return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
-    }
-
     // MARK: - Instance Properties
 
     /// The unspelled `Pitch` values to be spelled.
@@ -117,6 +45,9 @@ struct PitchSpeller {
     
     /// Getter for pitch class (from Index)
     let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
+}
+
+extension PitchSpeller {
 
     // MARK: - Initializers
 
@@ -145,7 +76,7 @@ struct PitchSpeller {
             sink: .sink,
             internalNodes: pitchNodes
         )
-        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(PitchSpeller.eightLookup.contains)
+        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(eightLookup.contains)
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
             .init(getPitchClass(flowNode), flowNode.tendency)
         }
@@ -156,6 +87,53 @@ struct PitchSpeller {
         let connectedToEight = connectToEight * whereEdge(contains: true)(8)
         flowNetwork.mask(connectedToTwoNotEight + sameClass + connectedToEight)
     }
+}
+
+extension PitchSpeller {
+
+    // MARK: - Type Properties
+
+    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
+        = GraphScheme<Tendency> { edge in edge.a == edge.b }
+            .pullback { node in
+                switch node {
+                case .source: return .down
+                case .sink: return .up
+                case .internal(let index): return index.b
+                }
+    }
+
+    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
+        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                edge.contains(pitchClass)
+            }
+        }
+        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                !edge.contains(pitchClass)
+            }
+        }
+        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
+    }
+
+    /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
+    /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
+    /// the given `Pitch`.)
+    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
+        return .internal(.init(offset, index))
+    }
+
+    /// - Returns: An array of nodes, each representing the index of the unassigned node in
+    /// `pitchNodes`.
+    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
+        return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
+    }
+}
+
+extension PitchSpeller {
+
+    // MARK: - Instance Methods
 
     /// - Returns: An array of `SpelledPitch` values with the same indices as the original
     /// unspelled `Pitch` values.
@@ -172,8 +150,10 @@ struct PitchSpeller {
         return assignedNodes
             .compactMap { (assignedNode) -> InternalAssignedNode? in
                 switch assignedNode.index {
-                case .source, .sink: return nil
-                case .internal(let index): return InternalAssignedNode(index, assignedNode.assignment)
+                case .source, .sink:
+                    return nil
+                case .internal(let index):
+                    return InternalAssignedNode(index, assignedNode.assignment)
                 }
             }
             .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
@@ -193,7 +173,7 @@ struct PitchSpeller {
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
-    
+
     func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
         func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
             return PitchSpeller.adjacencyScheme(contains: true)(pitchClass).pullback(getPitchClass)
@@ -205,6 +185,54 @@ struct PitchSpeller {
     }
 }
 
+// For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
+// be connected to `(8, .up)` in the spelling dependency model.
+private let eightTendencyLink: [(Pitch.Class, Tendency)] = [
+    (00, .down),
+    (01, .up),
+    (03, .down),
+    (04, .up),
+    (05, .down),
+    (06, .up),
+    (07, .down),
+    (08, .up),
+    (09, .up),
+    (10, .down),
+    (11, .up)
+]
+
+// Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
+private let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
+    eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
+)
+
+extension PitchSpeller {
+
+    // MARK: - Nested Types
+
+    struct UnassignedNode: PitchSpellingNode {
+        let index: Index
+    }
+
+    struct AssignedNode: PitchSpellingNode {
+        let index: Index
+        let assignment: Tendency
+        init(_ index: Index, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+
+    struct InternalAssignedNode {
+        let index: Cross<Int, Tendency>
+        let assignment: Tendency
+        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+}
+
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-- 
2.17.2 (Apple Git-113)


From 54db2ef3b709badd54bf3da01f16e414318f3e49 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 17:21:15 -0500
Subject: [PATCH 43/66] [NFC] Refactor PitchSpeller.whereEdge(contains:) (#169)

---
 .../Wetherfield/Wetherfield.swift             | 73 ++++++++++---------
 1 file changed, 39 insertions(+), 34 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 013035c..d6f5137 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -47,6 +47,33 @@ struct PitchSpeller {
     let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 }
 
+extension PitchSpeller {
+
+    // MARK: - Nested Types
+
+    struct UnassignedNode: PitchSpellingNode {
+        let index: Index
+    }
+
+    struct AssignedNode: PitchSpellingNode {
+        let index: Index
+        let assignment: Tendency
+        init(_ index: Index, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+
+    struct InternalAssignedNode {
+        let index: Cross<Int, Tendency>
+        let assignment: Tendency
+        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+}
+
 extension PitchSpeller {
 
     // MARK: - Initializers
@@ -174,14 +201,14 @@ extension PitchSpeller {
         return try! pitch.spelled(with: spelling)
     }
 
+    /// FIXME: Consider implementing as:
+    /// `let whereEdge: (Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index>`
     func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-        func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-            return PitchSpeller.adjacencyScheme(contains: true)(pitchClass).pullback(getPitchClass)
-        }
-        func doesNotContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-            return PitchSpeller.adjacencyScheme(contains: false)(pitchClass).pullback(getPitchClass)
+        return { pitchClass in
+            return PitchSpeller
+                .adjacencyScheme(contains: contains)(pitchClass)
+                .pullback(self.getPitchClass)
         }
-        return contains ? doesContain : doesNotContain
     }
 }
 
@@ -206,37 +233,15 @@ private let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
     eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
 )
 
-extension PitchSpeller {
-
-    // MARK: - Nested Types
-
-    struct UnassignedNode: PitchSpellingNode {
-        let index: Index
-    }
-
-    struct AssignedNode: PitchSpellingNode {
-        let index: Index
-        let assignment: Tendency
-        init(_ index: Index, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-
-    struct InternalAssignedNode {
-        let index: Cross<Int, Tendency>
-        let assignment: Tendency
-        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-}
-
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-    init(source: PitchSpellingNode.Index, sink: PitchSpellingNode.Index, internalNodes: [PitchSpellingNode.Index]) {
+    init(
+        source: PitchSpellingNode.Index,
+        sink: PitchSpellingNode.Index,
+        internalNodes: [PitchSpellingNode.Index]
+    )
+    {
         let graph = WeightedDirectedGraph<PitchSpellingNode.Index,Double>(
             source: source,
             sink: sink,
-- 
2.17.2 (Apple Git-113)


From 412903cf68f04f592aab7b0263a4f7fd9fd5788c Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:44:33 -0500
Subject: [PATCH 44/66] Use FlowNode.tendency property

---
 .../PitchSpeller/Wetherfield/Wetherfield.swift            | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index d6f5137..97cc79c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -121,13 +121,7 @@ extension PitchSpeller {
     // MARK: - Type Properties
 
     static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
-        = GraphScheme<Tendency> { edge in edge.a == edge.b }
-            .pullback { node in
-                switch node {
-                case .source: return .down
-                case .sink: return .up
-                case .internal(let index): return index.b
-                }
+        = GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency
     }
 
     static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
-- 
2.17.2 (Apple Git-113)


From ecf4cb572deeebe416bd501e521a0b3cd36237ed Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:48:55 -0500
Subject: [PATCH 45/66] Refactor connectSameTendencies out to free func

---
 .../PitchSpeller/Wetherfield/Wetherfield.swift        | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 97cc79c..263ddc0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -107,8 +107,8 @@ extension PitchSpeller {
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
             .init(getPitchClass(flowNode), flowNode.tendency)
         }
-        let connectedToTwoNotEight = PitchSpeller.connectSameTendencies * whereEdge(contains: false)(8) * whereEdge(contains: true)(2)
-        let sameClass = PitchSpeller.connectSameTendencies * GraphScheme<Pitch.Class> { edge in
+        let connectedToTwoNotEight = connectSameTendencies * whereEdge(contains: false)(8) * whereEdge(contains: true)(2)
+        let sameClass = connectSameTendencies * GraphScheme<Pitch.Class> { edge in
             edge.a == edge.b }
             .pullback(getPitchClass)
         let connectedToEight = connectToEight * whereEdge(contains: true)(8)
@@ -120,10 +120,6 @@ extension PitchSpeller {
 
     // MARK: - Type Properties
 
-    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
-        = GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency
-    }
-
     static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
         func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
             return GraphScheme<Pitch.Class> { edge in
@@ -206,6 +202,9 @@ extension PitchSpeller {
     }
 }
 
+let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> = GraphScheme<Tendency> { edge in edge.a == edge.b
+}.pullback { node in node.tendency }
+
 // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
 // be connected to `(8, .up)` in the spelling dependency model.
 private let eightTendencyLink: [(Pitch.Class, Tendency)] = [
-- 
2.17.2 (Apple Git-113)


From af5b56d9274bc2e48b3aff483c8d55c94e6b4328 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:51:40 -0500
Subject: [PATCH 46/66] Refactor node(_:_:) out to free func

---
 .../PitchSpeller/Wetherfield/Wetherfield.swift     | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 263ddc0..d20304c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -134,12 +134,7 @@ extension PitchSpeller {
         return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
     }
 
-    /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
-    /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
-    /// the given `Pitch`.)
-    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-        return .internal(.init(offset, index))
-    }
+
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
     /// `pitchNodes`.
@@ -202,6 +197,13 @@ extension PitchSpeller {
     }
 }
 
+/// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
+/// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
+/// the given `Pitch`.)
+private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
+    return .internal(.init(offset, index))
+}
+
 let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> = GraphScheme<Tendency> { edge in edge.a == edge.b
 }.pullback { node in node.tendency }
 
-- 
2.17.2 (Apple Git-113)


From 0808f904de7eb1aa2c0d655ef0156cc64bf18aa3 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:54:21 -0500
Subject: [PATCH 47/66] Remove pitchNodes property, refactor
 internalNodes(pitches:) out to free func

---
 .../Wetherfield/Wetherfield.swift             | 22 +++++++------------
 1 file changed, 8 insertions(+), 14 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index d20304c..c55e43f 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -36,10 +36,6 @@ struct PitchSpeller {
     /// The unspelled `Pitch` values to be spelled.
     let pitch: (PitchSpellingNode.Index) -> Pitch?
 
-    /// The nodes within the `FlowNetwork`. The values are the encodings of the indices of `Pitch`
-    /// values in `pitches.
-    let pitchNodes: [PitchSpellingNode.Index]
-
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
     var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
     
@@ -97,11 +93,11 @@ extension PitchSpeller {
             }
         }
         self.getPitchClass = getPitchClass
-        self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
+//        self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
             source: .source,
             sink: .sink,
-            internalNodes: pitchNodes
+            internalNodes: internalNodes(pitches: pitches)
         )
         let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(eightLookup.contains)
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
@@ -133,14 +129,6 @@ extension PitchSpeller {
         }
         return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
     }
-
-
-
-    /// - Returns: An array of nodes, each representing the index of the unassigned node in
-    /// `pitchNodes`.
-    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
-        return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
-    }
 }
 
 extension PitchSpeller {
@@ -197,6 +185,12 @@ extension PitchSpeller {
     }
 }
 
+/// - Returns: An array of nodes, each representing the index of the unassigned node in
+/// `pitchNodes`.
+private func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
+    return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
+}
+
 /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
 /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
 /// the given `Pitch`.)
-- 
2.17.2 (Apple Git-113)


From 95fc6445ff22922e4148436b7125519a2f8584e2 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:54:39 -0500
Subject: [PATCH 48/66] Move flowNetwork to top of instance properties

---
 .../SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index c55e43f..3ff4b29 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -33,12 +33,12 @@ struct PitchSpeller {
 
     // MARK: - Instance Properties
 
+    /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
+    var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
+
     /// The unspelled `Pitch` values to be spelled.
     let pitch: (PitchSpellingNode.Index) -> Pitch?
 
-    /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
-    var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
-    
     /// Getter for pitch class (from Index)
     let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 }
-- 
2.17.2 (Apple Git-113)


From 1828cef38cc4d70592855fb8c8728a5d8a280e2f Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:56:54 -0500
Subject: [PATCH 49/66] Sweep away dead code

---
 Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 3ff4b29..271a850 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -93,7 +93,6 @@ extension PitchSpeller {
             }
         }
         self.getPitchClass = getPitchClass
-//        self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
             source: .source,
             sink: .sink,
-- 
2.17.2 (Apple Git-113)


From 1fb3c2480d12d72fa2b2f1b8b625e9a305acb5e3 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:58:47 -0500
Subject: [PATCH 50/66] Try to make whitespace manageable for all those
 generics

---
 .../SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift   | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 271a850..df35d73 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -197,8 +197,8 @@ private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
     return .internal(.init(offset, index))
 }
 
-let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> = GraphScheme<Tendency> { edge in edge.a == edge.b
-}.pullback { node in node.tendency }
+let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> =
+    GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
 
 // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
 // be connected to `(8, .up)` in the spelling dependency model.
-- 
2.17.2 (Apple Git-113)


From 442ce55b0e2cd8e94382cbfd8eb1cba01d661db6 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 21:59:13 -0500
Subject: [PATCH 51/66] Verticalize parameter list

---
 .../SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index df35d73..ef5c6f7 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -166,7 +166,11 @@ extension PitchSpeller {
             }.mapValues(spellPitch)
     }
 
-    private func spellPitch(_ up: InternalAssignedNode, _ down: InternalAssignedNode) -> SpelledPitch {
+    private func spellPitch(
+        _ up: InternalAssignedNode,
+        _ down: InternalAssignedNode
+    ) -> SpelledPitch
+    {
         let pitch = self.pitch(.internal(up.index))!
         let tendencies = TendencyPair(up.assignment, down.assignment)
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
-- 
2.17.2 (Apple Git-113)


From ddf5b3f1f992e59d175078422a7bac76072a633a Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 22:03:23 -0500
Subject: [PATCH 52/66] Refactor adjacencyScheme out to free func

---
 .../Wetherfield/Wetherfield.swift             | 48 ++++++++-----------
 1 file changed, 21 insertions(+), 27 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index ef5c6f7..ead9b47 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -76,6 +76,11 @@ extension PitchSpeller {
 
     /// Create a `PitchSpeller` to spell the given `pitches`, with the given `parsimonyPivot`.
     init(pitches: [Int: Pitch], parsimonyPivot: Pitch.Spelling = .init(.d)) {
+        self.flowNetwork = FlowNetwork(
+            source: .source,
+            sink: .sink,
+            internalNodes: internalNodes(pitches: pitches)
+        )
         self.pitch = { index in
             switch index {
             case .source, .sink:
@@ -93,11 +98,7 @@ extension PitchSpeller {
             }
         }
         self.getPitchClass = getPitchClass
-        self.flowNetwork = FlowNetwork(
-            source: .source,
-            sink: .sink,
-            internalNodes: internalNodes(pitches: pitches)
-        )
+
         let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(eightLookup.contains)
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
             .init(getPitchClass(flowNode), flowNode.tendency)
@@ -111,25 +112,6 @@ extension PitchSpeller {
     }
 }
 
-extension PitchSpeller {
-
-    // MARK: - Type Properties
-
-    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
-        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-            return GraphScheme<Pitch.Class> { edge in
-                edge.contains(pitchClass)
-            }
-        }
-        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-            return GraphScheme<Pitch.Class> { edge in
-                !edge.contains(pitchClass)
-            }
-        }
-        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
-    }
-}
-
 extension PitchSpeller {
 
     // MARK: - Instance Methods
@@ -181,9 +163,7 @@ extension PitchSpeller {
     /// `let whereEdge: (Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index>`
     func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
         return { pitchClass in
-            return PitchSpeller
-                .adjacencyScheme(contains: contains)(pitchClass)
-                .pullback(self.getPitchClass)
+            adjacencyScheme(contains: contains)(pitchClass).pullback(self.getPitchClass)
         }
     }
 }
@@ -201,6 +181,20 @@ private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
     return .internal(.init(offset, index))
 }
 
+private func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
+    func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+        return GraphScheme<Pitch.Class> { edge in
+            edge.contains(pitchClass)
+        }
+    }
+    func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+        return GraphScheme<Pitch.Class> { edge in
+            !edge.contains(pitchClass)
+        }
+    }
+    return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
+}
+
 let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> =
     GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
 
-- 
2.17.2 (Apple Git-113)


From 8402c5d7364eb99a7c36ca4c4f10b0fe3b5ba1e4 Mon Sep 17 00:00:00 2001
From: James <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 22:06:46 -0500
Subject: [PATCH 53/66] Make free func private

---
 .../SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift   | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index ead9b47..e2948a3 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -99,7 +99,7 @@ extension PitchSpeller {
         }
         self.getPitchClass = getPitchClass
 
-        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(eightLookup.contains)
+        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>> (eightLookup.contains)
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
             .init(getPitchClass(flowNode), flowNode.tendency)
         }
@@ -195,7 +195,7 @@ private func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pi
     return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
 }
 
-let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> =
+private let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> =
     GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
 
 // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
-- 
2.17.2 (Apple Git-113)


From 5ee69e2d0744a8ecd77658de0f74dccf0569f07f Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Wed, 7 Nov 2018 10:00:18 -0500
Subject: [PATCH 54/66] Clean up / Refactor (#171)

* Remove WeightedGraphProtocol extension

* Place constructors in single WeightedGraphSchemeProtocol extension

* Add weight(from:to:) to WeightedGraphSchemeProtocol

* Rename WeightedDirectedGraphScheme

* Refactor weight(from:to:) into pullback definition

* Remove unneeded init

* Add contains(from:to:) to UnweightedGraphSchemeProtocol

* Add multiplication of different unweighted graph scheme protocols

* Add multiplication functions for WeightedGraphSchemeProtocol

* Add unweighted scheme multiplications to UnweightedGraphSchemeProtocol

* Implement weight scaling of UnweightedGraphSchemeProtocol

* Remove .inits

* Remove more .inits

* Add mask functions
---
 .../Wetherfield/DirectedGraphProtocol.swift   |  4 ++
 .../Wetherfield/FlowNetwork.swift             | 18 +++++-
 .../Wetherfield/GraphScheme.swift             |  4 ++
 .../Wetherfield/GraphSchemeProtocol.swift     |  2 +-
 .../UnweightedGraphSchemeProtocol.swift       | 32 ++++++++++-
 .../Wetherfield/WeightCarrying.swift          |  2 +-
 ...wift => WeightedDirectedGraphScheme.swift} |  6 +-
 .../Wetherfield/WeightedGraphScheme.swift     |  4 ++
 .../WeightedGraphSchemeProtocol.swift         | 55 ++++++++++++++++---
 9 files changed, 109 insertions(+), 18 deletions(-)
 rename Sources/SpelledPitch/PitchSpeller/Wetherfield/{WeightedDirectedGraphSchema.swift => WeightedDirectedGraphScheme.swift} (72%)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
index 5ada6c7..26c6784 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
@@ -16,4 +16,8 @@ struct DirectedGraphScheme <Node>: DirectedGraphSchemeProtocol, UnweightedGraphS
     init (_ contains: @escaping (Edge) -> Bool) {
         self.contains = contains
     }
+    
+    func contains(from start: Node, to end: Node) -> Bool {
+        return contains(Edge(start, end))
+    }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index a90e690..64267bc 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -51,7 +51,7 @@ extension FlowNetwork {
             }
         }
     }
-    
+
     mutating func mask <G: GraphProtocol> (_ adjacencyCarrying: AdjacencyCarrying<G>)
         where Node == G.Node
     {
@@ -60,11 +60,23 @@ extension FlowNetwork {
         }
     }
     
-    mutating func mask (_ adjacencyScheme: GraphScheme<Node>) {
-        for edge in edges where !adjacencyScheme.contains(GraphScheme<Node>.Edge(edge.a, edge.b)) {
+    mutating func mask <Scheme: UnweightedGraphSchemeProtocol> (_ adjacencyScheme: Scheme) where
+        Scheme.Node == Node
+    {
+        for edge in edges where !adjacencyScheme.contains(from: edge.a, to: edge.b) {
             remove(edge)
         }
     }
+    
+    mutating func mask <Scheme: WeightedGraphSchemeProtocol> (_ weightScheme: Scheme) where
+        Scheme.Node == Node,
+        Scheme.Weight == Weight
+    {
+        for edge in edges {
+            guard let scalar = weightScheme.weight(from: edge.a, to: edge.b) else { remove(edge); return }
+            updateEdge(edge) { $0 * scalar }
+        }
+    }
 }
 
 extension FlowNetwork {
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
index 88a1f8b..0601f22 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
@@ -16,4 +16,8 @@ struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeP
     init (_ contains: @escaping (Edge) -> Bool) {
         self.contains = contains
     }
+    
+    func contains(from start: Node, to end: Node) -> Bool {
+        return contains(Edge(start, end))
+    }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
index 91d2899..45b0c3f 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphSchemeProtocol.swift
@@ -18,6 +18,6 @@ extension GraphProtocol {
         G.Edge == Edge,
         G.Node == Node
     {
-        return G.init(self.contains)
+        return G(self.contains)
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 1aae3f1..97cf5c6 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -11,22 +11,48 @@ public protocol UnweightedGraphSchemeProtocol: GraphSchemeProtocol {
     var contains: (Edge) -> Bool { get }
     
     init (_ contains: @escaping (Edge) -> Bool)
+    
+    func contains (from start: Node, to end: Node) -> Bool
 }
 
 extension UnweightedGraphSchemeProtocol {
     @inlinable
     func pullback <H> (_ f: @escaping (H.Node) -> Node) -> H where H: UnweightedGraphSchemeProtocol {
-        return H.init { self.contains(Edge(f($0.a),f($0.b))) }
+        return H { self.contains(Edge(f($0.a),f($0.b))) }
     }
 }
 
 extension UnweightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol {
     
     static func * (lhs: Self, rhs: Self) -> Self {
-        return Self.init { edge in lhs.contains(edge) && rhs.contains(edge) }
+        return Self { edge in lhs.contains(edge) && rhs.contains(edge) }
     }
     
     static func + (lhs: Self, rhs: Self) -> Self {
-        return Self.init { edge in lhs.contains(edge) || rhs.contains(edge) }
+        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
+    }
+}
+
+extension UnweightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol {
+    
+    static func * <Scheme> (lhs: Self, rhs: Scheme) -> Self where
+        Scheme: UnweightedGraphSchemeProtocol,
+        Scheme.Node == Node
+    {
+        return Self { edge in lhs.contains(edge) && rhs.contains(from: edge.a, to: edge.b) }
+    }
+}
+
+extension UnweightedGraphSchemeProtocol {
+    
+    static func * <Weight, Scheme> (lhs: Weight, rhs: Self) -> Scheme where
+        Scheme: WeightedGraphSchemeProtocol,
+        Scheme.Weight == Weight,
+        Scheme.Node == Node,
+        Scheme.Edge == Edge
+    {
+        return Scheme { edge in
+            return rhs.contains(edge) ? lhs : nil
+        }
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
index 8a11396..62934ad 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
@@ -80,7 +80,7 @@ extension WeightCarrying {
         Scheme.Node == G.Node,
         Scheme.Weight == G.Weight
     {
-        return Scheme.init(weight)
+        return Scheme(weight)
     }
 }
 
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphScheme.swift
similarity index 72%
rename from Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift
rename to Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphScheme.swift
index 854f9c8..ab0f1e1 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphSchema.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedDirectedGraphScheme.swift
@@ -1,5 +1,5 @@
 //
-//  WeightedDirectedGraphSchema.swift
+//  WeightedDirectedGraphScheme.swift
 //  SpelledPitch
 //
 //  Created by Benjamin Wetherfield on 03/11/2018.
@@ -16,4 +16,8 @@ struct WeightedDirectedGraphScheme <Node,Weight>: DirectedGraphSchemeProtocol, W
     init (_ weight: @escaping (Edge) -> Weight?) {
         self.weight = weight
     }
+    
+    func weight(from start: Node, to end: Node) -> Weight? {
+        return weight(Edge(start, end))
+    }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
index 3f74b7e..e166755 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
@@ -16,4 +16,8 @@ struct WeightedGraphScheme <Node,Weight>: UndirectedGraphSchemeProtocol, Weighte
     init (_ weight: @escaping (Edge) -> Weight?) {
         self.weight = weight
     }
+    
+    func weight(from start: Node, to end: Node) -> Weight? {
+        return weight(Edge(start, end))
+    }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
index dce5b8b..7cb7889 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
@@ -13,6 +13,8 @@ public protocol WeightedGraphSchemeProtocol: GraphSchemeProtocol {
     var weight: (Edge) -> Weight? { get }
     
     init (_ weight: @escaping (Edge) -> Weight?)
+    
+    func weight (from start: Node, to end: Node) -> Weight?
 }
 
 extension WeightedGraphSchemeProtocol {
@@ -21,25 +23,60 @@ extension WeightedGraphSchemeProtocol {
         H: WeightedGraphSchemeProtocol,
         H.Weight == Weight
     {
-        return H.init { self.weight(Edge(f($0.a),f($0.b))) }
+        return H { self.weight(from: f($0.a), to: f($0.b)) }
     }
-}
 
-extension WeightedGraphSchemeProtocol {
     @inlinable
     func unweighted <H> () -> H where
         H: UnweightedGraphSchemeProtocol,
         H.Edge == Edge
     {
-        return H.init { self.weight($0) != nil }
+        return H { self.weight($0) != nil }
+    }
+}
+
+extension WeightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol, Weight: Numeric {
+    
+    static func * (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in
+            guard let lweight = lhs.weight(edge), let rweight = rhs.weight(edge) else { return nil }
+            return lweight * rweight
+        }
     }
 }
 
-extension WeightedGraphProtocol {
-    func weightScheme <G> (_ f: @escaping (G.Node) -> Node) -> WeightCarrying<G> where
-        G: WeightedGraphProtocol,
-        G.Weight == Weight
+extension WeightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol, Weight: Numeric {
+    
+    static func * <Scheme> (lhs: Self, rhs: Scheme) -> Self where
+    Scheme: WeightedGraphSchemeProtocol,
+    Scheme.Node == Node,
+    Scheme.Weight == Weight
+    {
+        return Self { edge in
+            guard
+                let lweight = lhs.weight(edge),
+                let rweight = rhs.weight(from: edge.a, to: edge.b) else { return nil }
+            return lweight * rweight
+        }
+    }
+    
+    static func * <Scheme> (lhs: Self, rhs: Scheme) -> Self where
+        Scheme: UnweightedGraphSchemeProtocol,
+        Scheme.Node == Node
+    {
+        return Self { edge in
+            if let lweight = lhs.weight(edge) {
+                return rhs.contains(from: edge.a, to: edge.b) ? lweight : nil
+            } else {
+                return nil
+            }
+        }
+    }
+    
+    static func * <Scheme> (lhs: Scheme, rhs: Self) -> Self where
+        Scheme: UnweightedGraphSchemeProtocol,
+        Scheme.Node == Node
     {
-        return WeightCarrying.build(from: self).pullback(f)
+        return rhs * lhs
     }
 }
-- 
2.17.2 (Apple Git-113)


From 0a470c0985c614a58cf6bca78111299a472b3751 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Wed, 7 Nov 2018 12:23:48 -0500
Subject: [PATCH 55/66] Add directed analog to unweighted() for undirected
 schemes *edited* (#173)

---
 .../PitchSpeller/Wetherfield/GraphScheme.swift             | 7 +++++++
 .../Wetherfield/UnweightedGraphSchemeProtocol.swift        | 1 +
 .../PitchSpeller/Wetherfield/WeightedGraphScheme.swift     | 7 +++++++
 3 files changed, 15 insertions(+)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
index 0601f22..6813f19 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
@@ -21,3 +21,10 @@ struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeP
         return contains(Edge(start, end))
     }
 }
+
+extension GraphScheme {
+    
+    var directed: DirectedGraphScheme<Node> {
+        return .init { edge in self.contains(from: edge.a, to: edge.b) }
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 97cf5c6..6a4feb4 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -56,3 +56,4 @@ extension UnweightedGraphSchemeProtocol {
         }
     }
 }
+
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
index e166755..2fd918e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphScheme.swift
@@ -21,3 +21,10 @@ struct WeightedGraphScheme <Node,Weight>: UndirectedGraphSchemeProtocol, Weighte
         return weight(Edge(start, end))
     }
 }
+
+extension WeightedGraphScheme {
+    
+    var directed: WeightedDirectedGraphScheme<Node,Weight> {
+        return .init { edge in self.weight(from: edge.a, to: edge.b) }
+    }
+}
-- 
2.17.2 (Apple Git-113)


From 6baf6901cc591169642f0878c19b7b7e4ad0e8e1 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sun, 11 Nov 2018 22:44:11 -0500
Subject: [PATCH 56/66] Add more dyad tests (#176)

---
 ...otocol.swift => DirectedGraphScheme.swift} |   2 +-
 .../Wetherfield/FlowNetwork.swift             |  11 +-
 .../Wetherfield/GraphScheme.swift             |   6 +-
 .../Wetherfield/Pitch.Spelling.Category.swift |   4 +-
 .../UnweightedGraphSchemeProtocol.swift       |  28 ++-
 .../WeightedGraphSchemeProtocol.swift         |  26 +-
 .../Wetherfield/Wetherfield.swift             | 222 ++++++++++++------
 7 files changed, 206 insertions(+), 93 deletions(-)
 rename Sources/SpelledPitch/PitchSpeller/Wetherfield/{DirectedGraphProtocol.swift => DirectedGraphScheme.swift} (87%)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphScheme.swift
similarity index 87%
rename from Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
rename to Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphScheme.swift
index 26c6784..ed440c3 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphScheme.swift
@@ -17,7 +17,7 @@ struct DirectedGraphScheme <Node>: DirectedGraphSchemeProtocol, UnweightedGraphS
         self.contains = contains
     }
     
-    func contains(from start: Node, to end: Node) -> Bool {
+    func containsEdge(from start: Node, to end: Node) -> Bool {
         return contains(Edge(start, end))
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 64267bc..d94f7d2 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -63,7 +63,7 @@ extension FlowNetwork {
     mutating func mask <Scheme: UnweightedGraphSchemeProtocol> (_ adjacencyScheme: Scheme) where
         Scheme.Node == Node
     {
-        for edge in edges where !adjacencyScheme.contains(from: edge.a, to: edge.b) {
+        for edge in edges where !adjacencyScheme.containsEdge(from: edge.a, to: edge.b) {
             remove(edge)
         }
     }
@@ -73,8 +73,11 @@ extension FlowNetwork {
         Scheme.Weight == Weight
     {
         for edge in edges {
-            guard let scalar = weightScheme.weight(from: edge.a, to: edge.b) else { remove(edge); return }
-            updateEdge(edge) { $0 * scalar }
+            if let scalar = weightScheme.weight(from: edge.a, to: edge.b) {
+                updateEdge(edge) { $0 * scalar }
+            } else {
+                remove(edge)
+            }
         }
     }
 }
@@ -191,3 +194,5 @@ extension Sequence {
         return (filterComplement(predicate), filter(predicate))
     }
 }
+
+extension FlowNetwork: Equatable where Node: Hashable, Weight: Hashable { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
index 6813f19..bc5529b 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
@@ -16,8 +16,8 @@ struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeP
     init (_ contains: @escaping (Edge) -> Bool) {
         self.contains = contains
     }
-    
-    func contains(from start: Node, to end: Node) -> Bool {
+
+    func containsEdge(from start: Node, to end: Node) -> Bool {
         return contains(Edge(start, end))
     }
 }
@@ -25,6 +25,6 @@ struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeP
 extension GraphScheme {
     
     var directed: DirectedGraphScheme<Node> {
-        return .init { edge in self.contains(from: edge.a, to: edge.b) }
+        return .init { edge in self.containsEdge(from: edge.a, to: edge.b) }
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index fe6ebd0..dc60079 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -23,7 +23,7 @@ extension Pitch.Spelling {
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharp]
+                return [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
             }
         }
 
@@ -44,7 +44,7 @@ extension Pitch.Spelling {
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .flat, .up: .sharp]
+                return [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
             }
         }
 
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 6a4feb4..1da832c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -11,8 +11,8 @@ public protocol UnweightedGraphSchemeProtocol: GraphSchemeProtocol {
     var contains: (Edge) -> Bool { get }
     
     init (_ contains: @escaping (Edge) -> Bool)
-    
-    func contains (from start: Node, to end: Node) -> Bool
+
+    func containsEdge (from start: Node, to end: Node) -> Bool
 }
 
 extension UnweightedGraphSchemeProtocol {
@@ -22,15 +22,18 @@ extension UnweightedGraphSchemeProtocol {
     }
 }
 
+extension UnweightedGraphSchemeProtocol {
+    
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
+    }
+}
+
 extension UnweightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol {
     
     static func * (lhs: Self, rhs: Self) -> Self {
         return Self { edge in lhs.contains(edge) && rhs.contains(edge) }
     }
-    
-    static func + (lhs: Self, rhs: Self) -> Self {
-        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
-    }
 }
 
 extension UnweightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol {
@@ -39,7 +42,18 @@ extension UnweightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol
         Scheme: UnweightedGraphSchemeProtocol,
         Scheme.Node == Node
     {
-        return Self { edge in lhs.contains(edge) && rhs.contains(from: edge.a, to: edge.b) }
+        return Self { edge in lhs.contains(edge) && rhs.containsEdge(from: edge.a, to: edge.b) }
+    }
+    
+    static func * <Scheme> (lhs: Scheme, rhs: Self) -> Self where
+        Scheme: UnweightedGraphSchemeProtocol,
+        Scheme.Node == Node
+    {
+        return rhs * lhs
+    }
+    
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
     }
 }
 
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
index 7cb7889..58de7d7 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
@@ -35,6 +35,17 @@ extension WeightedGraphSchemeProtocol {
     }
 }
 
+extension WeightedGraphSchemeProtocol {
+    
+    /// - Returns: rhs weight function whenever the lhs is missing the edge in question.
+    /// This function is non-commutative.
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in
+            lhs.weight(edge) ?? rhs.weight(edge)
+        }
+    }
+}
+
 extension WeightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol, Weight: Numeric {
     
     static func * (lhs: Self, rhs: Self) -> Self {
@@ -53,10 +64,11 @@ extension WeightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol, W
     Scheme.Weight == Weight
     {
         return Self { edge in
-            guard
-                let lweight = lhs.weight(edge),
-                let rweight = rhs.weight(from: edge.a, to: edge.b) else { return nil }
-            return lweight * rweight
+            lhs.weight(edge).flatMap { lweight in
+                rhs.weight(from: edge.a, to: edge.b).map { rweight in
+                    lweight * rweight
+                }
+            }
         }
     }
     
@@ -65,10 +77,8 @@ extension WeightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol, W
         Scheme.Node == Node
     {
         return Self { edge in
-            if let lweight = lhs.weight(edge) {
-                return rhs.contains(from: edge.a, to: edge.b) ? lweight : nil
-            } else {
-                return nil
+            lhs.weight(edge).flatMap { weight in
+                rhs.containsEdge(from: edge.a, to: edge.b) ? weight : nil
             }
         }
     }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index e2948a3..616aa5e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -14,6 +14,16 @@ enum FlowNode<Index>: Hashable where Index: Hashable {
     case sink
 }
 
+func bind <S: Hashable, A: Hashable> (_ f: @escaping (S) -> A) -> (FlowNode<S>) -> FlowNode<A> {
+    return { flowNodeS in
+        switch flowNodeS {
+        case .internal(let index): return .internal(f(index))
+        case .source: return .source
+        case .sink: return .sink
+        }
+    }
+}
+
 extension FlowNode where Index == Cross<Int,Tendency> {
     var tendency: Tendency {
         switch self {
@@ -24,6 +34,33 @@ extension FlowNode where Index == Cross<Int,Tendency> {
     }
 }
 
+extension FlowNode where Index: Pair, Index.A == Int {
+    var int: Int? {
+        switch self {
+        case .internal(let index): return index.a
+        default: return nil
+        }
+    }
+}
+
+extension FlowNode where Index: Pair, Index.A == Pitch.Class {
+    var pitchClass: Pitch.Class? {
+        switch self {
+        case .internal(let index): return index.a
+        case .source, .sink: return nil
+        }
+    }
+}
+
+extension FlowNode where Index: Pair, Index.B == Tendency {
+    var tendency: Tendency? {
+        switch self {
+        case .internal(let index): return index.b
+        default: return nil
+        }
+    }
+}
+
 protocol PitchSpellingNode: Hashable {
     typealias Index = FlowNode<Cross<Int,Tendency>>
     var index: Index { get }
@@ -38,9 +75,6 @@ struct PitchSpeller {
 
     /// The unspelled `Pitch` values to be spelled.
     let pitch: (PitchSpellingNode.Index) -> Pitch?
-
-    /// Getter for pitch class (from Index)
-    let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 }
 
 extension PitchSpeller {
@@ -89,26 +123,28 @@ extension PitchSpeller {
                 return pitches[cross.a]
             }
         }
-        let getPitchClass: (FlowNode<Cross<Int,Tendency>>) -> Pitch.Class = { flowNode in
-            switch flowNode {
-            case .source, .sink:
-                return parsimonyPivot.pitchClass
-            case .internal(let cross):
-                return pitches[cross.a]!.class
-            }
+        
+        let internalPitchClassTendency = { (cross: Cross<Int, Tendency>) in
+            Cross(pitches[cross.a]!.class, cross.b)
         }
-        self.getPitchClass = getPitchClass
-
-        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>> (eightLookup.contains)
-        let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
-            .init(getPitchClass(flowNode), flowNode.tendency)
-        }
-        let connectedToTwoNotEight = connectSameTendencies * whereEdge(contains: false)(8) * whereEdge(contains: true)(2)
-        let sameClass = connectSameTendencies * GraphScheme<Pitch.Class> { edge in
-            edge.a == edge.b }
-            .pullback(getPitchClass)
-        let connectedToEight = connectToEight * whereEdge(contains: true)(8)
-        flowNetwork.mask(connectedToTwoNotEight + sameClass + connectedToEight)
+        let pitchClassTendencyGetter = bind(internalPitchClassTendency)
+        
+        let specificSourceEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            sourceEdges.pullback(pitchClassTendencyGetter)
+        let specificInternalEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            internalEdges.pullback(pitchClassTendencyGetter)
+        let specificSinkEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            sinkEdges.pullback(pitchClassTendencyGetter)
+        
+        // All the connections that rely on pitch class specific information
+        let connections: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            (connectDifferentInts * specificInternalEdges) + specificSourceEdges + specificSinkEdges
+        
+        // Combination of pitch class specific information and connections within each `Int` index
+        // regardless of pitch class.
+        let maskArgument: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            connections + bigMAssignment
+        flowNetwork.mask(maskArgument)
     }
 }
 
@@ -140,10 +176,11 @@ extension PitchSpeller {
             .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
                 if !pairs.keys.contains(node.index.a) {
                     pairs[node.index.a] = (node, node)
-                }
-                switch node.index.b {
-                case .up: pairs[node.index.a]!.0 = node
-                case .down: pairs[node.index.a]!.1 = node
+                } else {
+                    switch node.index.b {
+                    case .up: pairs[node.index.a]!.0 = node
+                    case .down: pairs[node.index.a]!.1 = node
+                    }
                 }
             }.mapValues(spellPitch)
     }
@@ -158,14 +195,6 @@ extension PitchSpeller {
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
-
-    /// FIXME: Consider implementing as:
-    /// `let whereEdge: (Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index>`
-    func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-        return { pitchClass in
-            adjacencyScheme(contains: contains)(pitchClass).pullback(self.getPitchClass)
-        }
-    }
 }
 
 /// - Returns: An array of nodes, each representing the index of the unassigned node in
@@ -181,43 +210,98 @@ private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
     return .internal(.init(offset, index))
 }
 
-private func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
-    func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-        return GraphScheme<Pitch.Class> { edge in
-            edge.contains(pitchClass)
-        }
-    }
-    func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-        return GraphScheme<Pitch.Class> { edge in
-            !edge.contains(pitchClass)
-        }
-    }
-    return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
-}
-
-private let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> =
-    GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
-
-// For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
-// be connected to `(8, .up)` in the spelling dependency model.
-private let eightTendencyLink: [(Pitch.Class, Tendency)] = [
-    (00, .down),
-    (01, .up),
-    (03, .down),
-    (04, .up),
-    (05, .down),
-    (06, .up),
-    (07, .down),
-    (08, .up),
-    (09, .up),
-    (10, .down),
-    (11, .up)
+private let connectUpToDown: DirectedGraphScheme<PitchSpellingNode.Index> =
+    DirectedGraphScheme<Tendency> { edge in
+        edge.a == .up && edge.b == .down
+        }.pullback { node in node.tendency }
+
+private let bigMAdjacency: DirectedGraphScheme<PitchSpellingNode.Index> =
+    connectSameInts * connectUpToDown
+
+private let bigMAssignment: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+    Double.infinity * bigMAdjacency
+
+private let connectSameInts: GraphScheme<PitchSpellingNode.Index> =
+    GraphScheme<Int?> { edge in edge.a == edge.b && edge.a != nil }.pullback { node in node.int }
+
+private let connectDifferentInts: GraphScheme<PitchSpellingNode.Index> =
+    GraphScheme<Int?> { edge in !(edge.a == edge.b && edge.a != nil) }.pullback { node in node.int }
+
+private let sourceEdges =
+    WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> { edge in
+        (edge.a == .source && edge.b.tendency == .down) ?
+            edge.b.pitchClass.flatMap { index in sourceEdgeLookup[index] } : nil
+}
+
+private let sourceEdgeLookup: [Pitch.Class: Double] = [
+    00: 2,
+    01: 3,
+    02: 3,
+    03: 1,
+    04: 3,
+    05: 2,
+    06: 3,
+    07: 3,
+
+    09: 3,
+    10: 1,
+    11: 3,
 ]
 
-// Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
-private let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
-    eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
-)
+private let sinkEdges =
+    WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> { edge in
+        (edge.b == .sink && edge.a.tendency == .up) ?
+            edge.a.pitchClass.flatMap { index in sinkEdgeLookup[index] } : nil
+}
+
+private let sinkEdgeLookup: [Pitch.Class: Double] = [
+    00: 3,
+    01: 1,
+    02: 2,
+    03: 3,
+    04: 3,
+    05: 3,
+    06: 1,
+    07: 3,
+    
+    09: 3,
+    10: 3,
+    11: 2,
+]
+
+private let internalEdges: WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> =
+        WeightedGraphScheme { edge in
+            switch (edge.a, edge.b) {
+            case (.internal(let source), .internal(let destination)):
+                return internalEdgeLookup[.init(source, destination)]
+            default: return nil
+            }
+}.directed
+
+private let internalEdgeLookup: [UnorderedPair<Cross<Pitch.Class, Tendency>>: Double] = [
+    
+    // Replacement for eightTendencyLink
+    .init(.init(00, .down), .init(08,   .up)): 1,
+    .init(.init(01,   .up), .init(08,   .up)): 1,
+    .init(.init(03, .down), .init(08,   .up)): 1,
+    .init(.init(04,   .up), .init(08,   .up)): 1,
+    .init(.init(05, .down), .init(08,   .up)): 1,
+    .init(.init(06,   .up), .init(08,   .up)): 1,
+    .init(.init(07, .down), .init(08,   .up)): 1,
+    .init(.init(08,   .up), .init(08,   .up)): 1,
+    .init(.init(09,   .up), .init(08,   .up)): 1,
+    .init(.init(10, .down), .init(08,   .up)): 1,
+    .init(.init(11,   .up), .init(08,   .up)): 1,
+
+    .init(.init(00, .down), .init(01,   .up)): 1.5,
+    .init(.init(00,   .up), .init(01, .down)): 0.5,
+    
+    .init(.init(01, .down), .init(03,   .up)): 1,
+    .init(.init(01,   .up), .init(03, .down)): 1,
+    
+    .init(.init(01, .down), .init(05,   .up)): 0.5,
+    .init(.init(01,   .up), .init(05, .down)): 1.5,
+]
 
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
-- 
2.17.2 (Apple Git-113)


From 8784c33d7dc538f5bc104e8fbeebe719e2201187 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Wed, 14 Nov 2018 14:51:09 -0500
Subject: [PATCH 57/66] Harmonize with Structure @ 0.19.4 (#195)

---
 .../Wetherfield/AdjacencyCarrying.swift       |  58 ---------
 .../Wetherfield/FlowNetwork.swift             |  19 ---
 .../Wetherfield/WeightCarrying.swift          | 118 ------------------
 .../Wetherfield/WeightLabel.swift             |  76 +++++++++++
 .../WeightedGraphSchemeProtocol.swift         |   6 +-
 .../Wetherfield/Wetherfield.swift             |   4 +-
 6 files changed, 81 insertions(+), 200 deletions(-)
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightLabel.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
deleted file mode 100644
index d0a56c8..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/AdjacencyCarrying.swift
+++ /dev/null
@@ -1,58 +0,0 @@
-//
-//  AdjacencyCarrying.swift
-//  SpelledPitch
-//
-//  Created by Benjamin Wetherfield on 30/10/2018.
-//
-
-import DataStructures
-
-public struct AdjacencyCarrying <G: GraphProtocol> {
-    let contains: (G.Edge) -> Bool
-    
-    private init (contains: @escaping (G.Edge) -> Bool) {
-        self.contains = contains
-    }
-    
-    func contains (from start: G.Node, to end: G.Node) -> Bool {
-        return contains(G.Edge(start, end))
-    }
-    
-    func pullback <H: GraphProtocol> (_ f: @escaping (H.Node) -> G.Node) -> AdjacencyCarrying<H> {
-        return AdjacencyCarrying<H> { e in self.contains(G.Edge(f(e.a), f(e.b))) }
-    }
-    
-    static func build (from g: G) -> AdjacencyCarrying {
-        return AdjacencyCarrying(contains: g.contains)
-    }
-    
-    static func build (_ contains: @escaping (G.Edge) -> Bool) -> AdjacencyCarrying {
-        return AdjacencyCarrying(contains: contains)
-    }
-}
-
-extension AdjacencyCarrying {
-    
-    static func * <H> (lhs: AdjacencyCarrying, rhs: AdjacencyCarrying<H>) -> AdjacencyCarrying
-        where
-        H: UndirectedGraphProtocol,
-        H.Node == G.Node
-    {
-        return AdjacencyCarrying { e in lhs.contains(e) && rhs.contains(H.Edge(e.a, e.b)) }
-    }
-    
-    static func + (lhs: AdjacencyCarrying, rhs: AdjacencyCarrying) -> AdjacencyCarrying {
-        return AdjacencyCarrying { e in lhs.contains(e) || rhs.contains(e) }
-    }
-}
-
-extension AdjacencyCarrying where G: DirectedGraphProtocol {
-    
-    static func * <H> (lhs: AdjacencyCarrying, rhs: AdjacencyCarrying<H>) -> AdjacencyCarrying
-        where
-        H: DirectedGraphProtocol,
-        H.Node == G.Node
-    {
-        return AdjacencyCarrying { e in lhs.contains(e) && rhs.contains(H.Edge(e.a, e.b)) }
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index d94f7d2..c15753a 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -40,25 +40,6 @@ extension FlowNetwork {
 }
 
 extension FlowNetwork {
-    mutating func mask <G: WeightedGraphProtocol> (_ weightCarrying: WeightCarrying<G>)
-        where Node == G.Node, Weight == G.Weight
-    {
-        for edge in weights.keys {
-            if let maskWeight = weightCarrying.weight(from: edge.a, to: edge.b) {
-                updateEdge(edge) { $0 * maskWeight }
-            } else {
-                remove(edge)
-            }
-        }
-    }
-
-    mutating func mask <G: GraphProtocol> (_ adjacencyCarrying: AdjacencyCarrying<G>)
-        where Node == G.Node
-    {
-        for edge in edges {
-            if !adjacencyCarrying.contains(from: edge.a, to: edge.b) { remove(edge) }
-        }
-    }
     
     mutating func mask <Scheme: UnweightedGraphSchemeProtocol> (_ adjacencyScheme: Scheme) where
         Scheme.Node == Node
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
deleted file mode 100644
index 62934ad..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightCarrying.swift
+++ /dev/null
@@ -1,118 +0,0 @@
-//
-//  WeightCarrying.swift
-//  SpelledPitch
-//
-//  Created by Benjamin Wetherfield on 30/10/2018.
-//
-
-import DataStructures
-
-public struct WeightCarrying<G: WeightedGraphProtocol> {
-    let weight: (G.Edge) -> G.Weight?
-    
-    private init (weight: @escaping (G.Edge) -> G.Weight?) {
-        self.weight = weight
-    }
-    
-    func weight (from start: G.Node, to end: G.Node) -> G.Weight? {
-        return weight(G.Edge(start, end))
-    }
-
-    func pullback <H: WeightedGraphProtocol> (_ f: @escaping (H.Node) -> G.Node) -> WeightCarrying<H>
-        where H.Weight == G.Weight
-    {
-        return WeightCarrying<H> { e in self.weight(G.Edge(f(e.a), f(e.b))) }
-    }
-    
-    static func build (from g: G) -> WeightCarrying {
-        return WeightCarrying(weight: g.weight)
-    }
-    
-    static func build (_ weight: @escaping (G.Edge) -> G.Weight?) -> WeightCarrying {
-        return WeightCarrying(weight: weight)
-    }
-}
-
-extension WeightCarrying {
-    
-    static func * <H> (lhs: WeightCarrying, rhs: WeightCarrying<H>) -> WeightCarrying
-        where
-        H: UndirectedGraphProtocol,
-        H.Node == G.Node,
-        H.Weight == G.Weight
-    {
-        return WeightCarrying { e in
-            guard let lweight = lhs.weight(e), let rweight = rhs.weight(H.Edge(e.a, e.b))
-                else { return nil }
-            return lweight * rweight
-        }
-    }
-    
-    static func * <H> (lhs: WeightCarrying, rhs: AdjacencyCarrying<H>) -> WeightCarrying
-        where
-        H: UndirectedGraphProtocol,
-        H.Node == G.Node
-    {
-        return WeightCarrying { e in rhs.contains(H.Edge(e.a,e.b)) ? lhs.weight(e) : nil }
-    }
-    
-    static func * <H> (lhs: AdjacencyCarrying<H>, rhs: WeightCarrying) -> WeightCarrying
-        where
-        H: UndirectedGraphProtocol,
-        H.Node == G.Node
-    {
-        return WeightCarrying { e in lhs.contains(H.Edge(e.a,e.b)) ? rhs.weight(e) : nil }
-    }
-    
-    static func + (lhs: WeightCarrying, rhs: WeightCarrying) -> WeightCarrying {
-        return WeightCarrying { e in
-            guard let lweight = lhs.weight(e) else { return rhs.weight(e) }
-            guard let rweight = rhs.weight(e) else { return lhs.weight(e) }
-            return lweight + rweight
-        }
-    }
-}
-
-extension WeightCarrying {
-    
-    func weightedScheme <Scheme: WeightedGraphSchemeProtocol> () -> Scheme where
-        Scheme.Edge == G.Edge,
-        Scheme.Node == G.Node,
-        Scheme.Weight == G.Weight
-    {
-        return Scheme(weight)
-    }
-}
-
-extension WeightCarrying where G: DirectedGraphProtocol {
-    
-    static func * <H> (lhs: WeightCarrying, rhs: WeightCarrying<H>) -> WeightCarrying
-        where
-        H: DirectedGraphProtocol,
-        H.Node == G.Node,
-        H.Weight == G.Weight
-    {
-        return WeightCarrying { e in
-            guard let lweight = lhs.weight(e), let rweight = rhs.weight(H.Edge(e.a, e.b))
-                else { return nil }
-            return lweight * rweight
-        }
-    }
-    
-    static func * <H> (lhs: WeightCarrying, rhs: AdjacencyCarrying<H>) -> WeightCarrying
-        where
-        H: DirectedGraphProtocol,
-        H.Node == G.Node
-    {
-        return WeightCarrying { e in rhs.contains(H.Edge(e.a,e.b)) ? lhs.weight(e) : nil }
-    }
-    
-    static func * <H> (lhs: AdjacencyCarrying<H>, rhs: WeightCarrying) -> WeightCarrying
-        where
-        H: DirectedGraphProtocol,
-        H.Node == G.Node
-    {
-        return WeightCarrying { e in lhs.contains(H.Edge(e.a,e.b)) ? rhs.weight(e) : nil }
-    }
-}
-
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightLabel.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightLabel.swift
new file mode 100644
index 0000000..311f6ab
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightLabel.swift
@@ -0,0 +1,76 @@
+//
+//  WeightLabel.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 09/11/2018.
+//
+
+import Algebra
+import DataStructures
+import Pitch
+
+struct WeightLabel <Edge: SymmetricPair & Hashable>: AdditiveGroup {
+
+    var inverse: WeightLabel<Edge> {
+        return -self
+    }
+
+    init (edge: Edge? = nil, plus plusColumn: Set<Edge> = [], minus minusColumn: Set<Edge> = []) {
+        self.edge = edge
+        self.plusColumn = plusColumn
+        self.minusColumn = minusColumn
+    }
+    
+    static var zero: WeightLabel {
+        return .init()
+    }
+    
+    static func build(_ edge: Edge) -> WeightLabel {
+        return .init(edge: edge, plus: [edge])
+    }
+    
+    static prefix func - (_ invert: WeightLabel) -> WeightLabel {
+        return .init(edge: invert.edge, plus: invert.minusColumn, minus: invert.plusColumn)
+    }
+
+    static func + (lhs: WeightLabel, rhs: WeightLabel) -> WeightLabel {
+        return
+            .init(
+                edge: lhs.edge,
+                plus: lhs.plusColumn.union(rhs.plusColumn)
+                    .subtracting(lhs.minusColumn.union(rhs.minusColumn)),
+                minus: lhs.minusColumn.union(rhs.minusColumn)
+                    .subtracting(lhs.plusColumn.intersection(rhs.plusColumn))
+        )
+    }
+    
+    static func - (lhs: WeightLabel, rhs: WeightLabel) -> WeightLabel {
+        return lhs + -rhs
+    }
+    
+    let edge: Edge?
+    private let plusColumn: Set<Edge>
+    private let minusColumn: Set<Edge>
+}
+
+extension WeightLabel: Equatable where Edge: Equatable {
+    
+    static func == (lhs: WeightLabel, rhs: WeightLabel) -> Bool {
+        return lhs.plusColumn.subtracting(lhs.minusColumn) == rhs.plusColumn.subtracting(rhs.minusColumn)
+    }
+}
+
+extension WeightLabel: Comparable where Edge.A: Assigned {
+    static func < (lhs: WeightLabel<Edge>, rhs: WeightLabel<Edge>) -> Bool {
+        return lhs.edge.flatMap { left in
+            rhs.edge.map { right in
+                left.a.assignment < left.b.assignment &&
+                !(right.a.assignment < right.b.assignment)
+            }
+        } ?? false
+    }
+}
+
+protocol Assigned {
+    var assignment: Tendency { get }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
index 58de7d7..9af511d 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
@@ -59,9 +59,9 @@ extension WeightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol,
 extension WeightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol, Weight: Numeric {
     
     static func * <Scheme> (lhs: Self, rhs: Scheme) -> Self where
-    Scheme: WeightedGraphSchemeProtocol,
-    Scheme.Node == Node,
-    Scheme.Weight == Weight
+        Scheme: WeightedGraphSchemeProtocol,
+        Scheme.Node == Node,
+        Scheme.Weight == Weight
     {
         return Self { edge in
             lhs.weight(edge).flatMap { lweight in
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 616aa5e..c7af8ce 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -128,7 +128,7 @@ extension PitchSpeller {
             Cross(pitches[cross.a]!.class, cross.b)
         }
         let pitchClassTendencyGetter = bind(internalPitchClassTendency)
-        
+
         let specificSourceEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
             sourceEdges.pullback(pitchClassTendencyGetter)
         let specificInternalEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
@@ -321,7 +321,7 @@ extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     }
 }
 
-extension WeightedDirectedGraph {
+extension WeightedDirectedGraph where Weight: ExpressibleByIntegerLiteral {
     /// Create a `DirectedGraph` which is hooked up as necessary for the Wetherfield pitch-spelling process.
     init(source: Node, sink: Node, internalNodes: [Node]) {
         self.init(Set([source,sink] + internalNodes))
-- 
2.17.2 (Apple Git-113)


From 63100da4f16940d7d578d56d24c626808fe22231 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Thu, 15 Nov 2018 19:55:44 -0500
Subject: [PATCH 58/66] Enable Tendency <-> Pitch.Spelling.Modifier isomorphism
 (#196)

---
 .../PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift   | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index dc60079..18fa1f9 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -5,13 +5,14 @@
 //  Created by James Bean on 6/10/18.
 //
 
+import DataStructures
 import Math
 import Pitch
 
 /// Interface for the six pitch spelling categories.
 protocol PitchSpellingCategoryProtocol {
-    typealias ModifierMap = [ModifierDirection: Pitch.Spelling.Modifier]
-    /// The available `QuarterStepModifier` value by the given `ModifierDirection`.
+    typealias ModifierMap = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
+    /// The available `Pitch.Spelling.Modifier` value by the given `ModifierDirection`.
     static var modifiers: ModifierMap { get }
 }
 
-- 
2.17.2 (Apple Git-113)


From 07976873708d404ad2c010ade92fe7f59d891279 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Thu, 15 Nov 2018 20:08:29 -0500
Subject: [PATCH 59/66] Refine naming of ModifierMap, modifiers (#197)

---
 .../Wetherfield/Pitch.Spelling.Category.swift | 32 ++++++-------------
 1 file changed, 10 insertions(+), 22 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 18fa1f9..4655f56 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -11,9 +11,9 @@ import Pitch
 
 /// Interface for the six pitch spelling categories.
 protocol PitchSpellingCategoryProtocol {
-    typealias ModifierMap = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
+    typealias Map = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
     /// The available `Pitch.Spelling.Modifier` value by the given `ModifierDirection`.
-    static var modifiers: ModifierMap { get }
+    static var map: Map { get }
 }
 
 extension Pitch.Spelling {
@@ -23,44 +23,32 @@ extension Pitch.Spelling {
 
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
-            static var modifiers: ModifierMap {
-                return [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
-            }
+            static let map: Map = [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
-            static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .sharp, .up: .doubleSharp]
-            }
+            static let map: Map = [.down: .flat, .neutral: .sharp, .up: .doubleSharp]
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
-            static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .doubleSharp]
-            }
+            static let map: Map = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
-            static var modifiers: ModifierMap {
-                return [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
-            }
+            static let map: Map = [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
-            static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .doubleSharp]
-            }
+            static let map: Map = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
-            static var modifiers: ModifierMap {
-                return [.down: .flat, .up: .sharp]
-            }
+            static let map: Map = [.down: .flat, .up: .sharp]
         }
 
         /// - Returns: The type of `PitchSpellingCategoryProtocol` in which the given `pitchClass`
@@ -89,7 +77,7 @@ extension Pitch.Spelling {
         let letterName = Pitch.Spelling.letterName(pitchClass: pitchClass, with: modifierDirection)
         guard
             let category = Category.category(for: pitchClass),
-            let modifier = category.modifiers[modifierDirection]
+            let modifier = category.map[modifierDirection]
         else {
             return nil
         }
@@ -103,7 +91,7 @@ extension Pitch.Spelling {
     /// the given `pitchClass`, if such a `LetterName` exists. Otherwise, `nil`.
     static func neutralLetterName(for pitchClass: Pitch.Class) -> LetterName? {
         guard let category = Category.category(for: pitchClass) else { return nil }
-        guard let modifier = category.modifiers[.neutral] else { return nil }
+        guard let modifier = category.map[.neutral] else { return nil }
         switch modifier {
         case .natural:
             return LetterName.default(for: pitchClass)
-- 
2.17.2 (Apple Git-113)


From 4090a3197eb6b67717664e74bc2c51c45fe5855c Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Thu, 15 Nov 2018 21:26:28 -0500
Subject: [PATCH 60/66] Refactor rename bimaps, add more (#201)

---
 .../Wetherfield/Pitch.Spelling.Category.swift | 32 +++++++++----------
 .../Wetherfield/TendencyConverting.swift      |  5 +--
 2 files changed, 19 insertions(+), 18 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 4655f56..01c1277 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -11,9 +11,9 @@ import Pitch
 
 /// Interface for the six pitch spelling categories.
 protocol PitchSpellingCategoryProtocol {
-    typealias Map = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
+    typealias ModifierLookup = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
     /// The available `Pitch.Spelling.Modifier` value by the given `ModifierDirection`.
-    static var map: Map { get }
+    static var lookup: ModifierLookup { get }
 }
 
 extension Pitch.Spelling {
@@ -23,32 +23,32 @@ extension Pitch.Spelling {
 
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
-            static let map: Map = [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
+            static let lookup: ModifierLookup = [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
-            static let map: Map = [.down: .flat, .neutral: .sharp, .up: .doubleSharp]
+            static let lookup: ModifierLookup = [.down: .flat, .neutral: .sharp, .up: .doubleSharp]
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
-            static let map: Map = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
+            static let lookup: ModifierLookup = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
-            static let map: Map = [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
+            static let lookup: ModifierLookup = [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
-            static let map: Map = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
+            static let lookup: ModifierLookup = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
-            static let map: Map = [.down: .flat, .up: .sharp]
+            static let lookup: ModifierLookup = [.down: .flat, .up: .sharp]
         }
 
         /// - Returns: The type of `PitchSpellingCategoryProtocol` in which the given `pitchClass`
@@ -77,7 +77,7 @@ extension Pitch.Spelling {
         let letterName = Pitch.Spelling.letterName(pitchClass: pitchClass, with: modifierDirection)
         guard
             let category = Category.category(for: pitchClass),
-            let modifier = category.map[modifierDirection]
+            let modifier = category.lookup[modifierDirection]
         else {
             return nil
         }
@@ -91,7 +91,7 @@ extension Pitch.Spelling {
     /// the given `pitchClass`, if such a `LetterName` exists. Otherwise, `nil`.
     static func neutralLetterName(for pitchClass: Pitch.Class) -> LetterName? {
         guard let category = Category.category(for: pitchClass) else { return nil }
-        guard let modifier = category.map[.neutral] else { return nil }
+        guard let modifier = category.lookup[.neutral] else { return nil }
         switch modifier {
         case .natural:
             return LetterName.default(for: pitchClass)
@@ -156,7 +156,7 @@ extension LetterName {
 // MARK: `Pitch.Spelling.Category` -> `TendencyConverting`
 
 extension Pitch.Spelling.Category.Zero: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
+    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
         return [
             .init(.down,.down): .down,
             .init(.up,.down): .neutral,
@@ -166,7 +166,7 @@ extension Pitch.Spelling.Category.Zero: TendencyConverting {
 }
 
 extension Pitch.Spelling.Category.One: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
+    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
         return [
             .init(.down,.down): .down,
             .init(.up,.down): .neutral,
@@ -176,7 +176,7 @@ extension Pitch.Spelling.Category.One: TendencyConverting {
 }
 
 extension Pitch.Spelling.Category.Two: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
+    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
         return [
             .init(.down,.down): .down,
             .init(.up,.down): .neutral,
@@ -186,7 +186,7 @@ extension Pitch.Spelling.Category.Two: TendencyConverting {
 }
 
 extension Pitch.Spelling.Category.Three: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
+    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
         return [
             .init(.down,.down): .down,
             .init(.up,.down): .neutral,
@@ -196,7 +196,7 @@ extension Pitch.Spelling.Category.Three: TendencyConverting {
 }
 
 extension Pitch.Spelling.Category.Four: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
+    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
         return [
             .init(.down,.down): .down,
             .init(.up,.down): .neutral,
@@ -206,7 +206,7 @@ extension Pitch.Spelling.Category.Four: TendencyConverting {
 }
 
 extension Pitch.Spelling.Category.Five: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.TendencyMap {
+    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
         return [
             .init(.down,.down): .down,
             .init(.down,.up): .down,
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
index 40d8370..5a080d8 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
@@ -5,13 +5,14 @@
 //  Created by James Bean on 6/10/18.
 //
 
+import DataStructures
 import Pitch
 
 /// Interface for `PitchSpellingCategoryProtocol` types which can convert a `TendencyPair` into a
 /// `ModifierDirection`.
 protocol TendencyConverting {
-    typealias TendencyMap = [TendencyPair: ModifierDirection]
-    static var modifierDirectionByTendencies: TendencyMap { get }
+    typealias DirectionCodec = Bimap<TendencyPair,ModifierDirection>
+    static var modifierDirectionByTendencies: DirectionCodec { get }
 }
 
 extension TendencyConverting {
-- 
2.17.2 (Apple Git-113)


From 85e5b6e35a7311ab0f1f8920d6a89ac34efafd87 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Fri, 16 Nov 2018 19:44:47 -0500
Subject: [PATCH 61/66] Refine Lookup naming in Pitch.Spelling.Category and
 TendencyConverting (#203)

---
 .../Wetherfield/Pitch.Spelling.Category.swift | 109 ++++++------------
 .../Wetherfield/TendencyConverting.swift      |  54 ++++++++-
 2 files changed, 85 insertions(+), 78 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 01c1277..24961e2 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -13,7 +13,7 @@ import Pitch
 protocol PitchSpellingCategoryProtocol {
     typealias ModifierLookup = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
     /// The available `Pitch.Spelling.Modifier` value by the given `ModifierDirection`.
-    static var lookup: ModifierLookup { get }
+    static var directionToModifier: ModifierLookup { get }
 }
 
 extension Pitch.Spelling {
@@ -23,32 +23,55 @@ extension Pitch.Spelling {
 
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
-            static let lookup: ModifierLookup = [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
+            static let directionToModifier: ModifierLookup = [
+                .down: .doubleFlat,
+                .neutral: .natural,
+                .up: .sharp
+            ]
         }
 
         /// Category for pitch classes `1` and `6`.
         struct One: PitchSpellingCategoryProtocol {
-            static let lookup: ModifierLookup = [.down: .flat, .neutral: .sharp, .up: .doubleSharp]
+            static let directionToModifier: ModifierLookup = [
+                .down: .flat,
+                .neutral: .sharp,
+                .up: .doubleSharp
+            ]
         }
 
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
-            static let lookup: ModifierLookup = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
+            static let directionToModifier: ModifierLookup = [
+                .down: .flat,
+                .neutral: .natural,
+                .up: .doubleSharp
+            ]
         }
 
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
-            static let lookup: ModifierLookup = [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
+            static let directionToModifier: ModifierLookup = [
+                .down: .doubleFlat,
+                .neutral: .flat,
+                .up: .sharp
+            ]
         }
 
         /// Category for pitch classes `4`, and `11`.
         struct Four: PitchSpellingCategoryProtocol {
-            static let lookup: ModifierLookup = [.down: .flat, .neutral: .natural, .up: .doubleSharp]
+            static let directionToModifier: ModifierLookup = [
+                .down: .flat,
+                .neutral: .natural,
+                .up: .doubleSharp
+            ]
         }
 
         /// Category for pitch class `8`.
         struct Five: PitchSpellingCategoryProtocol {
-            static let lookup: ModifierLookup = [.down: .flat, .up: .sharp]
+            static let directionToModifier: ModifierLookup = [
+                .down: .flat,
+                .up: .sharp
+            ]
         }
 
         /// - Returns: The type of `PitchSpellingCategoryProtocol` in which the given `pitchClass`
@@ -77,7 +100,7 @@ extension Pitch.Spelling {
         let letterName = Pitch.Spelling.letterName(pitchClass: pitchClass, with: modifierDirection)
         guard
             let category = Category.category(for: pitchClass),
-            let modifier = category.lookup[modifierDirection]
+            let modifier = category.directionToModifier[modifierDirection]
         else {
             return nil
         }
@@ -91,7 +114,7 @@ extension Pitch.Spelling {
     /// the given `pitchClass`, if such a `LetterName` exists. Otherwise, `nil`.
     static func neutralLetterName(for pitchClass: Pitch.Class) -> LetterName? {
         guard let category = Category.category(for: pitchClass) else { return nil }
-        guard let modifier = category.lookup[.neutral] else { return nil }
+        guard let modifier = category.directionToModifier[.neutral] else { return nil }
         switch modifier {
         case .natural:
             return LetterName.default(for: pitchClass)
@@ -105,8 +128,8 @@ extension Pitch.Spelling {
     }
    
     /// Create a `LetterName` with the given `pitchClass` and `modifierDirection`.
-    static func letterName(pitchClass: Pitch.Class,
-                            with modifierDirection: ModifierDirection) -> LetterName
+    static func letterName(pitchClass: Pitch.Class, with modifierDirection: ModifierDirection)
+        -> LetterName
     {
         guard let neutralLetterName = Pitch.Spelling.neutralLetterName(for: pitchClass)
             else { return modifierDirection == .down ? .a : .g }
@@ -151,67 +174,3 @@ extension LetterName {
         }
     }
 }
-
-// FIXME: Move below to own file when SR-631 build order bug is resolved.
-// MARK: `Pitch.Spelling.Category` -> `TendencyConverting`
-
-extension Pitch.Spelling.Category.Zero: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
-        return [
-            .init(.down,.down): .down,
-            .init(.up,.down): .neutral,
-            .init(.up,.up): .up
-        ]
-    }
-}
-
-extension Pitch.Spelling.Category.One: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
-        return [
-            .init(.down,.down): .down,
-            .init(.up,.down): .neutral,
-            .init(.up,.up): .up
-        ]
-    }
-}
-
-extension Pitch.Spelling.Category.Two: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
-        return [
-            .init(.down,.down): .down,
-            .init(.up,.down): .neutral,
-            .init(.up,.up): .up
-        ]
-    }
-}
-
-extension Pitch.Spelling.Category.Three: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
-        return [
-            .init(.down,.down): .down,
-            .init(.up,.down): .neutral,
-            .init(.up,.up): .up
-        ]
-    }
-}
-
-extension Pitch.Spelling.Category.Four: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
-        return [
-            .init(.down,.down): .down,
-            .init(.up,.down): .neutral,
-            .init(.up,.up): .up
-        ]
-    }
-}
-
-extension Pitch.Spelling.Category.Five: TendencyConverting {
-    static var modifierDirectionByTendencies: TendencyConverting.DirectionCodec {
-        return [
-            .init(.down,.down): .down,
-            .init(.down,.up): .down,
-            .init(.up,.down): .up,
-            .init(.up,.up): .up
-        ]
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
index 5a080d8..2a6f2c3 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/TendencyConverting.swift
@@ -11,8 +11,8 @@ import Pitch
 /// Interface for `PitchSpellingCategoryProtocol` types which can convert a `TendencyPair` into a
 /// `ModifierDirection`.
 protocol TendencyConverting {
-    typealias DirectionCodec = Bimap<TendencyPair,ModifierDirection>
-    static var modifierDirectionByTendencies: DirectionCodec { get }
+    typealias DirectionLookup = Bimap<TendencyPair,ModifierDirection>
+    static var tendenciesToDirection: DirectionLookup { get }
 }
 
 extension TendencyConverting {
@@ -21,7 +21,55 @@ extension TendencyConverting {
     static func modifierDirection(for tendencies: TendencyPair)
         -> ModifierDirection?
     {
-        return modifierDirectionByTendencies[tendencies]
+        return tendenciesToDirection[tendencies]
     }
 }
 
+extension Pitch.Spelling.Category.Zero: TendencyConverting {
+    static let tendenciesToDirection: DirectionLookup = [
+        .init(.down,.down): .down,
+        .init(.up,.down): .neutral,
+        .init(.up,.up): .up
+    ]
+}
+
+extension Pitch.Spelling.Category.One: TendencyConverting {
+    static let tendenciesToDirection: DirectionLookup = [
+        .init(.down,.down): .down,
+        .init(.up,.down): .neutral,
+        .init(.up,.up): .up
+    ]
+}
+
+extension Pitch.Spelling.Category.Two: TendencyConverting {
+    static var tendenciesToDirection: DirectionLookup = [
+        .init(.down,.down): .down,
+        .init(.up,.down): .neutral,
+        .init(.up,.up): .up
+    ]
+}
+
+extension Pitch.Spelling.Category.Three: TendencyConverting {
+    static var tendenciesToDirection: DirectionLookup = [
+        .init(.down,.down): .down,
+        .init(.up,.down): .neutral,
+        .init(.up,.up): .up
+    ]
+}
+
+extension Pitch.Spelling.Category.Four: TendencyConverting {
+    static var tendenciesToDirection: DirectionLookup = [
+        .init(.down,.down): .down,
+        .init(.up,.down): .neutral,
+        .init(.up,.up): .up
+    ]
+}
+
+extension Pitch.Spelling.Category.Five: TendencyConverting {
+    static var tendenciesToDirection: DirectionLookup = [
+        .init(.down,.down): .down,
+        .init(.down,.up): .down,
+        .init(.up,.down): .up,
+        .init(.up,.up): .up
+    ]
+}
-- 
2.17.2 (Apple Git-113)


From 1f2a098a05be3a53bab687a84a3c012f18bbf05e Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Fri, 16 Nov 2018 21:46:22 -0500
Subject: [PATCH 62/66] Conform FlowNode to CustomStringConvertible (#204)

---
 .../PitchSpeller/Wetherfield/Wetherfield.swift  | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index c7af8ce..fc63f87 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -334,3 +334,20 @@ extension WeightedDirectedGraph where Weight: ExpressibleByIntegerLiteral {
         }
     }
 }
+
+extension FlowNode: CustomStringConvertible {
+
+    // MARK: - CustomStringConvertible
+
+    /// Printable description of `FlowNode`.
+    public var description: String {
+        switch self {
+        case .source:
+            return "source"
+        case .sink:
+            return "sink"
+        case .internal(let index):
+            return "\(index)"
+        }
+    }
+}
-- 
2.17.2 (Apple Git-113)


From b44146b03b467b1d7bff7000954f48cb69a44809 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Fri, 16 Nov 2018 22:33:53 -0500
Subject: [PATCH 63/66] Add PitchSpeller tests for dyads (#188)

* Pitch class schemes (#178)

* Add WeightLabel implementation

* Add default weight "classes" (#199)

* Quarantine and mute failing dyad tests (#205)
---
 .../Wetherfield/FlowNetwork.swift             |  16 +-
 .../Wetherfield/Wetherfield.swift             | 183 +++++++++---------
 2 files changed, 107 insertions(+), 92 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index c15753a..124cedd 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -15,7 +15,7 @@ public struct FlowNetwork<Node: Hashable, Weight: Numeric & Comparable>:
     WeightedGraphProtocol,
     DirectedGraphProtocol
 {
-    public var weights: [Edge : Weight]
+    public var weights: [Edge: Weight]
     public var nodes: Set<Node>
     public var source: Node
     public var sink: Node
@@ -30,13 +30,22 @@ extension FlowNetwork {
 
     // MARK: - Initializers
 
-    /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
+    /// Creates a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink`
+    /// nodes.
     init(_ directedGraph: WeightedDirectedGraph<Node,Weight>, source: Node, sink: Node) {
         self.nodes = directedGraph.nodes
         self.weights = directedGraph.weights
         self.source = source
         self.sink = sink
     }
+
+    /// Creates a `FlowNetwork` with the given `source`, `sink`, `nodes`, and `weights`.
+    public init(source: Node, sink: Node, nodes: Set<Node> = [], weights: [Edge: Weight] = [:]) {
+        self.source = source
+        self.sink = sink
+        self.nodes = nodes
+        self.weights = weights
+    }
 }
 
 extension FlowNetwork {
@@ -176,4 +185,5 @@ extension Sequence {
     }
 }
 
-extension FlowNetwork: Equatable where Node: Hashable, Weight: Hashable { }
+extension FlowNetwork: Equatable { }
+extension FlowNetwork: Hashable where Weight: Hashable { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index fc63f87..3ef892c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -32,6 +32,12 @@ extension FlowNode where Index == Cross<Int,Tendency> {
         case .internal(let index): return index.b
         }
     }
+    var int: Int? {
+        switch self {
+        case .internal(let index): return index.a
+        case .source, .sink: return nil
+        }
+    }
 }
 
 extension FlowNode where Index: Pair, Index.A == Int {
@@ -108,13 +114,9 @@ extension PitchSpeller {
 
     // MARK: - Initializers
 
-    /// Create a `PitchSpeller` to spell the given `pitches`, with the given `parsimonyPivot`.
+    /// Creates a `PitchSpeller` to spell the given `pitches`, with the given `parsimonyPivot`.
     init(pitches: [Int: Pitch], parsimonyPivot: Pitch.Spelling = .init(.d)) {
-        self.flowNetwork = FlowNetwork(
-            source: .source,
-            sink: .sink,
-            internalNodes: internalNodes(pitches: pitches)
-        )
+        self.flowNetwork = FlowNetwork(internalNodes: internalNodes(pitches: pitches))
         self.pitch = { index in
             switch index {
             case .source, .sink:
@@ -197,23 +199,9 @@ extension PitchSpeller {
     }
 }
 
-/// - Returns: An array of nodes, each representing the index of the unassigned node in
-/// `pitchNodes`.
-private func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
-    return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
-}
-
-/// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
-/// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
-/// the given `Pitch`.)
-private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-    return .internal(.init(offset, index))
-}
-
 private let connectUpToDown: DirectedGraphScheme<PitchSpellingNode.Index> =
-    DirectedGraphScheme<Tendency> { edge in
-        edge.a == .up && edge.b == .down
-        }.pullback { node in node.tendency }
+    DirectedGraphScheme<Tendency> { edge in edge.a == .up && edge.b == .down }
+        .pullback { node in node.tendency }
 
 private let bigMAdjacency: DirectedGraphScheme<PitchSpellingNode.Index> =
     connectSameInts * connectUpToDown
@@ -229,44 +217,55 @@ private let connectDifferentInts: GraphScheme<PitchSpellingNode.Index> =
 
 private let sourceEdges =
     WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> { edge in
-        (edge.a == .source && edge.b.tendency == .down) ?
-            edge.b.pitchClass.flatMap { index in sourceEdgeLookup[index] } : nil
+        (edge.a == .source && edge.b.tendency == .down)
+            ? edge.b.pitchClass.flatMap { index in sourceEdgeLookup[index] }
+            : nil
 }
 
+// Default weights:
+let heavyWeight: Double = 3
+let middleWeight: Double = 2
+// welterWeight (if necessary)
+let lightWeight: Double = 1.5
+let featherWeight: Double = 1
+// bantamWeight (if necessary)
+let flyWeight: Double = 0.5
+
 private let sourceEdgeLookup: [Pitch.Class: Double] = [
-    00: 2,
-    01: 3,
-    02: 3,
-    03: 1,
-    04: 3,
-    05: 2,
-    06: 3,
-    07: 3,
-
-    09: 3,
-    10: 1,
-    11: 3,
+    00: middleWeight,
+    01: heavyWeight,
+    02: heavyWeight,
+    03: featherWeight,
+    04: heavyWeight,
+    05: middleWeight,
+    06: heavyWeight,
+    07: heavyWeight,
+
+    09: heavyWeight,
+    10: featherWeight,
+    11: heavyWeight,
 ]
 
 private let sinkEdges =
     WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> { edge in
-        (edge.b == .sink && edge.a.tendency == .up) ?
-            edge.a.pitchClass.flatMap { index in sinkEdgeLookup[index] } : nil
+        (edge.b == .sink && edge.a.tendency == .up)
+            ? edge.a.pitchClass.flatMap { index in sinkEdgeLookup[index] }
+            : nil
 }
 
 private let sinkEdgeLookup: [Pitch.Class: Double] = [
-    00: 3,
-    01: 1,
-    02: 2,
-    03: 3,
-    04: 3,
-    05: 3,
-    06: 1,
-    07: 3,
+    00: heavyWeight,
+    01: featherWeight,
+    02: middleWeight,
+    03: heavyWeight,
+    04: heavyWeight,
+    05: heavyWeight,
+    06: featherWeight,
+    07: heavyWeight,
     
-    09: 3,
-    10: 3,
-    11: 2,
+    09: heavyWeight,
+    10: heavyWeight,
+    11: middleWeight,
 ]
 
 private let internalEdges: WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> =
@@ -281,58 +280,64 @@ private let internalEdges: WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Clas
 private let internalEdgeLookup: [UnorderedPair<Cross<Pitch.Class, Tendency>>: Double] = [
     
     // Replacement for eightTendencyLink
-    .init(.init(00, .down), .init(08,   .up)): 1,
-    .init(.init(01,   .up), .init(08,   .up)): 1,
-    .init(.init(03, .down), .init(08,   .up)): 1,
-    .init(.init(04,   .up), .init(08,   .up)): 1,
-    .init(.init(05, .down), .init(08,   .up)): 1,
-    .init(.init(06,   .up), .init(08,   .up)): 1,
-    .init(.init(07, .down), .init(08,   .up)): 1,
-    .init(.init(08,   .up), .init(08,   .up)): 1,
-    .init(.init(09,   .up), .init(08,   .up)): 1,
-    .init(.init(10, .down), .init(08,   .up)): 1,
-    .init(.init(11,   .up), .init(08,   .up)): 1,
-
-    .init(.init(00, .down), .init(01,   .up)): 1.5,
-    .init(.init(00,   .up), .init(01, .down)): 0.5,
+    .init(.init(00, .down), .init(08,   .up)): featherWeight,
+    .init(.init(01,   .up), .init(08,   .up)): featherWeight,
+    .init(.init(03, .down), .init(08,   .up)): featherWeight,
+    .init(.init(04,   .up), .init(08,   .up)): featherWeight,
+    .init(.init(05, .down), .init(08,   .up)): featherWeight,
+    .init(.init(06,   .up), .init(08,   .up)): featherWeight,
+    .init(.init(07, .down), .init(08,   .up)): featherWeight,
+    .init(.init(08,   .up), .init(08,   .up)): featherWeight,
+    .init(.init(09,   .up), .init(08,   .up)): featherWeight,
+    .init(.init(10, .down), .init(08,   .up)): featherWeight,
+    .init(.init(11,   .up), .init(08,   .up)): featherWeight,
+
+    .init(.init(00, .down), .init(01,   .up)): lightWeight,
+    .init(.init(00,   .up), .init(01, .down)): flyWeight,
     
-    .init(.init(01, .down), .init(03,   .up)): 1,
-    .init(.init(01,   .up), .init(03, .down)): 1,
+    .init(.init(01, .down), .init(03,   .up)): featherWeight,
+    .init(.init(01,   .up), .init(03, .down)): featherWeight,
     
-    .init(.init(01, .down), .init(05,   .up)): 0.5,
-    .init(.init(01,   .up), .init(05, .down)): 1.5,
+    .init(.init(01, .down), .init(05,   .up)): flyWeight,
+    .init(.init(01,   .up), .init(05, .down)): lightWeight
 ]
 
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
+
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-    init(
-        source: PitchSpellingNode.Index,
-        sink: PitchSpellingNode.Index,
-        internalNodes: [PitchSpellingNode.Index]
-    )
-    {
-        let graph = WeightedDirectedGraph<PitchSpellingNode.Index,Double>(
-            source: source,
-            sink: sink,
-            internalNodes: internalNodes
-        )
-        self.init(graph, source: source, sink: sink)
-    }
-}
-
-extension WeightedDirectedGraph where Weight: ExpressibleByIntegerLiteral {
-    /// Create a `DirectedGraph` which is hooked up as necessary for the Wetherfield pitch-spelling process.
-    init(source: Node, sink: Node, internalNodes: [Node]) {
-        self.init(Set([source,sink] + internalNodes))
+    init(internalNodes: [PitchSpellingNode.Index]) {
+        self.init(source: .source, sink: .sink)
         for node in internalNodes {
-            insertEdge(from: source, to: node, weight: 1)
-            insertEdge(from: node, to: sink, weight: 1)
+            insertEdge(from: source, to: node, weight: featherWeight)
+            insertEdge(from: node, to: sink, weight: featherWeight)
             for other in internalNodes.lazy.filter({ $0 != node }) {
-                insertEdge(from: node, to: other, weight: 1)
+                insertEdge(from: node, to: other, weight: featherWeight)
             }
         }
     }
+
+    /// Creates an empty `FlowNetwork` ready to be used incrementally constructed for the purposes
+    /// of pitch spelling.
+    init() {
+        self.source = .source
+        self.sink = .sink
+        self.nodes = []
+        self.weights = [:]
+    }
+}
+
+/// - Returns: An array of nodes, each representing the index of the unassigned node in
+/// `pitchNodes`.
+private func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
+    return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
+}
+
+/// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
+/// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
+/// the given `Pitch`.)
+private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
+    return .internal(.init(offset, index))
 }
 
 extension FlowNode: CustomStringConvertible {
-- 
2.17.2 (Apple Git-113)


From 1771f110b34ee7f2c1236d6421513f98d8baedc7 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Tue, 30 Apr 2019 18:32:37 -0400
Subject: [PATCH 64/66] Inverse problem (#207)

* Implement setup for SpellingInverter from a numbered list of spellings

* Simplify SpellingInverter FlowNetwork to a DirectedGraph

* Add signature for getWeights

* Add weight-generating inverse process

* Add and fix test for pitch class 2

* Add test for pitch class 0

* Add test for pitch class 1

* Rename variables in tests

* Add test for pitch class 3

* Add test for pitch class 4

* Add test for pitch class 5

* Add test for pitch class 6

* Add test pitch class 7

* Add test for pitch class 9

* Add test for pitch class 10

* Add test for pitch class 11

* Add test for pitch class 8

* Remove unused getWeieights function

* Add convenience function for checking membership in Nodes

* Implement tests with convenience function

* Fix test typo

* Fix test typo

* Switch in AssignedNode types for FlowNodes

* Add de-assignment conversion

* Replace assigned edge implementation by unassigned implementation

* Fix weightDependencies initialization

* Remove extraneous self

* Remove extraneous typealias

* Fix new contains syntax

* Refactor

* Fix edge initialization

* Add containsEdge convenience functions

* Pass simple edge test

* Add containsSinkEdge functions

* Add convenience assertion check functions

* Add to test pass

* Add to test passes

* Fix dynamic programming in recursive reducer

* Reorder functions

* Remove infinity storage in weights

* Add converter of dependency information from Int to Pitch Class

* Replace weights with a map over edges of pitch classes

* Add adjacency scheme gadgets

* Implement mask

* Fix mask

* Fix maskScheme

* Switch implementation to rewritten graph populator

* Refactor simplify parentheses

* Refactor pitched edge dependency implementation

* Remove dictionary mapping aparatus

* Add PitchedEdge typalias

* Refactor typealias

* Fix indent

* Remove non-pitched dependencies

* Remove redundant signatures

* Fix sink edge populator

* Rename test

* Fix lookup numbers

* Pass test by fixing containsEdge function

* Rename test

* Remove dead code

* Pass test for pitched dependencies on a small example

* Fail weights test with off-by-1 error

* Fix and simplify recursiveReducer

* Add comments

* Remove unused function type value

* Remove optional from scheme

* Add MARKs

* Add graph segmenter

* Fix pitchedDependencies state

* Add cycle check before running recursion

* Fail cycle check test

* Alter test

* Fix cycle finder

* Fix use of reduce

* Deploy weights with nil case for inconsistent spellings

* Resolve always-succeeding conditional downcast warning (#209)

* Generate linux tests (#208)

* Refactor AllSchemes

* Use convenience initializer for pitch spelling

* Add precondition logic

* [NFC] Lint SpellingInverter (#210)

* Format

* Inferrence

* Use function convention

* Fix tests
---
 .../Wetherfield/Pitch.Spelling.Category.swift |   8 +-
 .../Wetherfield/SpellingInverter.swift        | 434 ++++++++++++++++++
 .../PitchSpeller/Wetherfield/Tendency.swift   |   3 +-
 .../UnweightedGraphSchemeProtocol.swift       |   2 +-
 .../Wetherfield/Wetherfield.swift             |   9 +-
 5 files changed, 450 insertions(+), 6 deletions(-)
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index 24961e2..4356b5e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -10,7 +10,7 @@ import Math
 import Pitch
 
 /// Interface for the six pitch spelling categories.
-protocol PitchSpellingCategoryProtocol {
+protocol PitchSpellingCategoryProtocol: TendencyConverting {
     typealias ModifierLookup = Bimap<ModifierDirection,Pitch.Spelling.Modifier>
     /// The available `Pitch.Spelling.Modifier` value by the given `ModifierDirection`.
     static var directionToModifier: ModifierLookup { get }
@@ -42,7 +42,7 @@ extension Pitch.Spelling {
         /// Category for pitch classes `2`, `7`, and `9`.
         struct Two: PitchSpellingCategoryProtocol {
             static let directionToModifier: ModifierLookup = [
-                .down: .flat,
+                .down: .doubleFlat,
                 .neutral: .natural,
                 .up: .doubleSharp
             ]
@@ -76,6 +76,10 @@ extension Pitch.Spelling {
 
         /// - Returns: The type of `PitchSpellingCategoryProtocol` in which the given `pitchClass`
         /// resides, if the `pitchClass` is an integral value. Otherwise, `nil`.
+        //
+        // TODO: The proposal for static subscripts was accepted:
+        // https://github.com/apple/swift-evolution/blob/master/proposals/0254-static-subscripts.md
+        // This would be a nice use case for that.
         static func category(for pitchClass: Pitch.Class) -> PitchSpellingCategoryProtocol.Type? {
             switch pitchClass {
             case 0,5: return Zero.self
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
new file mode 100644
index 0000000..8f9611b
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
@@ -0,0 +1,434 @@
+//
+//  SpellingInverter.swift
+//  SpelledPitch
+//
+//  Created by Benjamin Wetherfield on 2/14/19.
+//
+
+import DataStructures
+import Pitch
+
+struct SpellingInverter {
+    
+    // MARK: - Instance Properties
+    
+    // The pre-assigned `DirectedGraph` which stands in for the `FlowNetwork` that
+    // would solve to the set of spellings passed into the `SpellingInverter`.
+    var flowNetwork: DirectedGraph<PitchSpeller.AssignedNode>
+    
+    let pitchClass: (Int) -> Pitch.Class?
+}
+
+extension SpellingInverter {
+    
+    // MARK: - Type Aliases
+    
+    typealias AssignedEdge = OrderedPair<PitchSpeller.AssignedNode>
+    typealias UnassignedEdge = OrderedPair<PitchSpeller.UnassignedNode>
+    typealias PitchedEdge = UnorderedPair<FlowNode<Cross<Pitch.Class,Tendency>>>
+}
+
+extension SpellingInverter {
+    
+    // MARK: - Initializers
+    
+    init(spellings: [Int: Pitch.Spelling], parsimonyPivot: Pitch.Spelling = .d) {
+        self.flowNetwork = DirectedGraph(internalNodes: internalNodes(spellings: spellings))
+        self.pitchClass = { int in spellings[int]?.pitchClass }
+        
+        let specificEdgeScheme: DirectedGraphScheme<PitchSpeller.UnassignedNode> = (upDownEdgeScheme.pullback(nodeMapper) + sameEdgeScheme.pullback(nodeMapper))
+            * connectDifferentInts
+        
+        let sameIntEdgesScheme: DirectedGraphScheme<PitchSpeller.UnassignedNode> =
+            sameIntsScheme * connectSameInts
+        
+        let specificSourceScheme: DirectedGraphScheme<PitchSpeller.UnassignedNode> =
+            sourceEdgeLookupScheme.pullback(nodeMapper)
+        
+        let specificSinkScheme: DirectedGraphScheme<PitchSpeller.UnassignedNode> =
+            sinkEdgeLookupScheme.pullback(nodeMapper)
+        
+        let allSchemes: [DirectedGraphScheme<PitchSpeller.UnassignedNode>] = [
+            specificEdgeScheme,
+            sameIntEdgesScheme,
+            specificSourceScheme,
+            specificSinkScheme
+        ]
+        
+        let maskScheme: DirectedGraphScheme<PitchSpeller.AssignedNode> = allSchemes
+            .reduce(DirectedGraphScheme { _ in false }, +)
+            .pullback({ $0.unassigned })
+        
+        // Apply masking of specific manifestations of the general global adjacency schemes
+        self.flowNetwork.mask(maskScheme)
+    }
+}
+
+extension SpellingInverter {
+    
+    // MARK: - Computed Properties
+    
+    /// - Returns: A concrete distribution of weights to satisfy the weight relationships delimited by
+    /// `weightDependencies` or `nil` if no such distribution is possible, i.e. there are cyclical
+    /// dependencies between edge types. In the latter case, the spellings fed in are *inconsistent*.
+    /// Weights are parametrized by `Pitch.Class` and `Tendency` values.
+    func generateWeights () -> [PitchedEdge: Double] {
+        let pitchedDependencies = findDependencies()
+        precondition(!findCycle(pitchedDependencies))
+        func dependeciesReducer (
+            _ weights: inout [PitchedEdge: Double],
+            _ dependency: (key: PitchedEdge, value: Set<PitchedEdge>)
+        )
+        {
+            func recursiveReducer (
+                _ weights: inout [PitchedEdge: Double],
+                _ dependency: (key: PitchedEdge, value: Set<PitchedEdge>)
+            ) -> Double
+            {
+                let weight = dependency.value.reduce(1.0) { result, edge in
+                    if weights[edge] != nil { return result + weights[edge]! }
+                    return (
+                        result +
+                        recursiveReducer(&weights, (key: edge, value: pitchedDependencies[edge]!))
+                    )
+                }
+                weights[dependency.key] = weight
+                return weight
+            }
+            let _ = recursiveReducer(&weights, dependency)
+        }
+        return pitchedDependencies.reduce(into: [:], dependeciesReducer)
+    }
+    
+    /// - Returns: getter for the pitched version of a node index
+    var pitchClassMapper: (Cross<Int,Tendency>) -> Cross<Pitch.Class, Tendency> {
+        return { input in
+            Cross<Pitch.Class, Tendency>(self.pitchClass(input.a)!, input.b)
+        }
+    }
+    
+    /// - Returns: getter for the `FlowNode` version of `pitchClassMapper`
+    var flowNodeMapper: (FlowNode<Cross<Int,Tendency>>) -> FlowNode<Cross<Pitch.Class,Tendency>> {
+        return bind(pitchClassMapper)
+    }
+    
+    /// - Returns: getter from a `PitchSpeller.UnassignedNode` to a flow network pitched node
+    var nodeMapper: (PitchSpeller.UnassignedNode) -> FlowNode<Cross<Pitch.Class,Tendency>> {
+        return { self.flowNodeMapper($0.index) }
+    }
+    
+    /// - Returns: getter from an `UnassignedEdge` to a `PitchedEdge`
+    var pairMapper: (UnassignedEdge) -> PitchedEdge {
+        return { pair in
+            .init(self.nodeMapper(pair.a), self.nodeMapper(pair.b))
+        }
+    }
+    
+    /// - Returns: For each `Edge`, a `Set` of `Edge` values, the sum of whose weights the edge's weight
+    /// must be greater than for the inverse spelling procedure to be valid.
+    func findDependencies () -> [PitchedEdge: Set<PitchedEdge>] {
+        var residualNetwork = flowNetwork
+        var weightDependencies: [PitchedEdge: Set<PitchedEdge>] = flowNetwork.edges.lazy
+            .map { .init(self.nodeMapper($0.a.unassigned), self.nodeMapper($0.b.unassigned)) }
+            .reduce(into: [:]) { dependencies, edge in dependencies[edge] = [] }
+        let source = PitchSpeller.AssignedNode(.source, .down)
+        let sink = PitchSpeller.AssignedNode(.sink, .up)
+        while let augmentingPath = residualNetwork.shortestUnweightedPath(from: source, to: sink) {
+            let preCutIndex = augmentingPath.lastIndex { $0.assignment == .down }!
+            let cutEdge = AssignedEdge(augmentingPath[preCutIndex], augmentingPath[preCutIndex+1])
+            for edge in augmentingPath.pairs.map(AssignedEdge.init) where edge != cutEdge {
+                weightDependencies[
+                    PitchedEdge(
+                        self.nodeMapper(edge.a.unassigned),
+                        self.nodeMapper(edge.b.unassigned)
+                    )
+                ]!.insert(
+                    PitchedEdge(
+                        self.nodeMapper(cutEdge.a.unassigned),
+                        self.nodeMapper(cutEdge.b.unassigned)
+                    )
+                )
+            }
+            residualNetwork.remove(cutEdge)
+            residualNetwork.insertEdge(from: cutEdge.b, to: cutEdge.a)
+        }
+        return weightDependencies
+    }
+}
+
+extension SpellingInverter {
+    
+    // MARK: - Instance Methods
+    
+    mutating func mask (_ adjacencyScheme: GraphScheme<FlowNode<Int>>) {
+        let temp: GraphScheme<FlowNode<Cross<Int, Tendency>>>
+            = adjacencyScheme.pullback(bind { cross in cross.a})
+        let mask: GraphScheme<PitchSpeller.AssignedNode> = temp.pullback { node in node.index }
+        flowNetwork.mask(mask)
+    }
+
+    func findCycle(_ dependencies: [PitchedEdge: Set<PitchedEdge>]) -> Bool {
+
+        func reducer (_ result: Bool, _ keyValue: (key: PitchedEdge, value: Set<PitchedEdge>)) -> Bool {
+            
+            var graph = dependencies
+            var flag = false
+            
+            func depthFirstSearch (
+                _ visited: inout Set<PitchedEdge>,
+                _ keyValue: (key: PitchedEdge, value: Set<PitchedEdge>)
+            )
+            {
+                guard let first = graph[keyValue.key]?.first, flag == false else { return }
+                graph[keyValue.key]!.remove(first)
+                if !visited.contains(keyValue.key) && visited.contains(first) {
+                    flag = true
+                    return
+                }
+                visited.insert(keyValue.key)
+                depthFirstSearch(&visited, (first, graph[first]!))
+            }
+
+            let _ = dependencies.reduce(into: [], depthFirstSearch)
+            return flag
+        }
+
+        return dependencies.reduce(false, reducer)
+    }
+}
+
+extension SpellingInverter {
+    
+    // MARK: - Convenience Functions
+    
+    /// Convenience function for testing presence of a given node in the `flowNetwork`
+    func contains(_ indexing: (index: Int, offset: Tendency), _ assignment: Tendency) -> Bool {
+        return flowNetwork.contains(
+            PitchSpeller.AssignedNode(.internal(Cross(indexing.index, indexing.offset)), assignment)
+        )
+    }
+    
+    /// Convenience function for testing presence of an internal edge (ignoring assignments)
+    func containsEdge(
+        from source: (index: Int, offset: Tendency),
+        to destination: (index: Int, offset: Tendency)
+    ) -> Bool {
+        return [
+            (.up,.up),
+            (.up,.down),
+            (.down,.down),
+            (.down,.up)
+        ].reduce(false) { (accumulating: Bool, next: (Tendency, Tendency)) -> Bool in
+            accumulating ||
+            containsEdge(
+                from: (source.index, source.offset, next.0),
+                to: (destination.index, destination.offset, next.1)
+            )
+        }
+    }
+    
+    /// Convenience function for testing presence of internal edge (with assignments)
+    func containsEdge(
+        from source: (index: Int, offset: Tendency, assignment: Tendency),
+        to destination: (index: Int, offset: Tendency, assignment: Tendency)
+    ) -> Bool {
+        return flowNetwork.containsEdge(
+            from: PitchSpeller.AssignedNode(
+                .internal(Cross(source.index, source.offset)), source.assignment
+            ),
+            to: PitchSpeller.AssignedNode(
+                .internal(Cross(destination.index, destination.offset)), destination.assignment
+            )
+        )
+    }
+    
+    /// Convenience function for testing presence of edge from source (ignoring assignment)
+    func containsSourceEdge(to destination: (index: Int, offset: Tendency)) -> Bool {
+        return [.up, .down].reduce(false) { accumulating, next in
+            accumulating || containsSourceEdge(
+                from: .down,
+                to: (destination.index, destination.offset, next)
+            )
+        }
+    }
+    
+    /// Convenience function for testing presence of edge to sink (ignoring assignment)
+    func containsSinkEdge(from source: (index: Int, offset: Tendency)) -> Bool {
+        return [.up, .down].reduce(false) { accumulating, next in
+            accumulating || containsSinkEdge(
+                from: (source.index, source.offset, next),
+                to: .up
+            )
+        }
+    }
+    
+    /// Convenience function for testing presence of edge from source (with assignments)
+    func containsSourceEdge(
+        from sourceTendency: Tendency,
+        to destination: (index: Int, offset: Tendency, assignment: Tendency)
+    ) -> Bool {
+        return flowNetwork.containsEdge(
+            from: PitchSpeller.AssignedNode(.source, sourceTendency),
+            to: PitchSpeller.AssignedNode(
+                .internal(Cross(destination.index, destination.offset)), destination.assignment
+            )
+        )
+    }
+    
+    /// Convenience function for testing presence of edge to sink (with assignments)
+    func containsSinkEdge(
+        from source: (index: Int, offset: Tendency, assignment: Tendency),
+        to destinationTendency: Tendency
+    ) -> Bool {
+        return flowNetwork.containsEdge(
+            from: PitchSpeller.AssignedNode(
+                .internal(Cross(source.index, source.offset)), source.assignment
+            ),
+            to: PitchSpeller.AssignedNode(.sink, destinationTendency)
+        )
+    }
+}
+
+/// Adjacency scheme that connects `.up` tendencies to `.down` tendencies
+private let sameIntsScheme: DirectedGraphScheme<PitchSpeller.UnassignedNode> =
+    DirectedGraphScheme<Tendency?> { edge in edge.a == .up && edge.b == .down }
+        .pullback { node in node.index.tendency}
+
+/// Adjacency scheme that connects `.source` to `.down` tendencies and not pitch class `8`
+private let sourceEdgeLookupScheme: DirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>> =
+    DirectedGraphScheme<FlowNode<Pitch.Class>> { edge in
+        edge.a == .source && edge.b != .internal(8)
+    }.pullback(bind({ cross in cross.a }))
+        * DirectedGraphScheme<FlowNode<Tendency>> { edge in
+            edge.a == .source && edge.b == .internal(.down)
+    }.pullback(bind ({ cross in cross.b }))
+
+/// Adjacency scheme that connects `.up` tendencies and not pitch class `8` to `.sink`
+private let sinkEdgeLookupScheme: DirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>> =
+    DirectedGraphScheme<FlowNode<Pitch.Class>> { edge in
+        edge.a != .internal(8) && edge.b == .sink
+    }.pullback(bind({ cross in cross.a }))
+        * DirectedGraphScheme<FlowNode<Tendency>> { edge in
+            edge.a == .internal(.up) && edge.b == .sink
+    }.pullback(bind ({ cross in cross.b }))
+
+/// Adjacency scheme that connects nodes with the same `int` value
+private let connectSameInts: GraphScheme<PitchSpeller.UnassignedNode> =
+    GraphScheme<Int> { edge in edge.a == edge.b }.pullback { node in node.index.int! }
+
+/// Adjacency scheme that connects nodes with different `int` values
+private let connectDifferentInts: GraphScheme<PitchSpeller.UnassignedNode> =
+    GraphScheme<Int> { edge in edge.a != edge.b }.pullback { node in node.index.int! }
+
+/// Adjacency scheme that connects `.up` tendencies to `.down` tendencies and vice versa provided
+/// the pitch classes of the nodes are connected per `upDownEdgeLookup`
+private let upDownEdgeScheme: DirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>> =
+    GraphScheme { edge in
+        switch (edge.a, edge.b) {
+        case (.internal(let source), .internal(let destination)):
+            return (
+                source.b != destination.b &&
+                upDownEdgeLookup.contains(.init(source.a, destination.a))
+            )
+        default:
+            return false
+        }
+    }.directed
+
+/// Adjacency scheme that connects nodes with the same tendency provided the pitch classes of the nodes
+/// are *not* connected per `upDownEdgeLookup`
+private let sameEdgeScheme: DirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>> =
+    GraphScheme { edge in
+        switch (edge.a, edge.b) {
+        case (.internal(let source), .internal(let destination)):
+            return (
+                source.b == destination.b &&
+                !upDownEdgeLookup.contains(.init(source.a, destination.a))
+            )
+        default:
+            return false
+        }
+    }.directed
+
+/// Pairs of pitch classes that have a different skew, such that `ModifierDirection.neutral` for one node is
+/// sharp or 'up' in absolute terms and for the other node it is down
+private let upDownEdgeLookup: [UnorderedPair<Pitch.Class>] = [
+    .init(00, 01),
+    .init(00, 04),
+    .init(00, 08),
+    .init(01, 03),
+    .init(01, 05),
+    .init(01, 10),
+    .init(03, 04),
+    .init(03, 06),
+    .init(03, 08),
+    .init(03, 11),
+    .init(04, 05),
+    .init(05, 06),
+    .init(05, 08),
+    .init(05, 11),
+    .init(06, 10),
+    .init(07, 08),
+    .init(08, 10),
+    .init(10, 11)
+]
+
+extension DirectedGraph where Node == PitchSpeller.AssignedNode {
+    
+    // MARK: - Initializers
+    
+    /// Create a `DirectedGraph` which is hooked up as neccesary for the Wetherfield inverse-spelling
+    /// process.
+    init(internalNodes: [PitchSpeller.InternalAssignedNode]) {
+        self.init()
+        let source = PitchSpeller.AssignedNode(.source, .down)
+        let sink = PitchSpeller.AssignedNode(.sink, .up)
+        self.insert(source)
+        self.insert(sink)
+        
+        var mapInternal: (PitchSpeller.InternalAssignedNode) -> PitchSpeller.AssignedNode {
+            return { .init(.internal($0.index), $0.assignment) }
+        }
+        
+        for internalNode in internalNodes {
+            let node = mapInternal(internalNode)
+            insert(node)
+            insertEdge(from: source, to: node)
+            insertEdge(from: node, to: sink)
+            for otherInternalNode in internalNodes where otherInternalNode != internalNode {
+                let other = mapInternal(otherInternalNode)
+                insertEdge(from: node, to: other)
+            }
+        }
+    }
+    
+    // MARK: - Instance Methods
+    
+    /// Lazily removes adjacencies from the `flowNetwork` according to `adjacencyScheme`
+    mutating func mask <Scheme: UnweightedGraphSchemeProtocol> (_ adjacencyScheme: Scheme) where
+        Scheme.Node == Node
+    {
+        for edge in edges where !adjacencyScheme.containsEdge(from: edge.a, to: edge.b) {
+            remove(edge)
+        }
+    }
+}
+
+/// - Returns: Index and assignment of all internal nodes of the `flowNetwork`.
+private func internalNodes(spellings: [Int: Pitch.Spelling]) -> [PitchSpeller.InternalAssignedNode] {
+    return spellings
+        .map { offset, spelling in [.down,.up].map { index in node(offset, index, spelling) } }
+        .reduce([], +)
+}
+
+/// - Returns: The value of a node at the given offset (index of a `Pitch.Spelling` within `spellings`),
+/// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
+/// the given `Pitch.Spelling`.)
+private func node(_ offset: Int, _ index: Tendency, _ pitchSpelling: Pitch.Spelling)
+    -> PitchSpeller.InternalAssignedNode
+{
+    let pitchCategory = Pitch.Spelling.Category.category(for: pitchSpelling.pitchClass)!
+    let direction = pitchCategory.directionToModifier[value: pitchSpelling.modifier]!
+    let tendencies = pitchCategory.tendenciesToDirection[value: direction]!
+    return .init(.init(offset, index), index == .up ? tendencies.a : tendencies.b)
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
index f49b3d0..dadcc84 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Tendency.swift
@@ -31,8 +31,7 @@ extension Pitch.Spelling {
     init?(pitchClass: Pitch.Class, tendencies: TendencyPair) {
         guard
             let category = Pitch.Spelling.Category.category(for: pitchClass),
-            let tendencyConverter = category as? TendencyConverting.Type,
-            let modifierDirection = tendencyConverter.modifierDirection(for: tendencies)
+            let modifierDirection = category.modifierDirection(for: tendencies)
         else {
             return nil
         }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 1da832c..7abe645 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -29,7 +29,7 @@ extension UnweightedGraphSchemeProtocol {
     }
 }
 
-extension UnweightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol {
+extension UnweightedGraphSchemeProtocol {
     
     static func * (lhs: Self, rhs: Self) -> Self {
         return Self { edge in lhs.contains(edge) && rhs.contains(edge) }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 3ef892c..0a3c8f8 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -100,7 +100,7 @@ extension PitchSpeller {
         }
     }
 
-    struct InternalAssignedNode {
+    struct InternalAssignedNode: Hashable {
         let index: Cross<Int, Tendency>
         let assignment: Tendency
         init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
@@ -110,6 +110,13 @@ extension PitchSpeller {
     }
 }
 
+extension PitchSpeller.AssignedNode {
+    
+    var unassigned: PitchSpeller.UnassignedNode {
+        return .init(index: index)
+    }
+}
+
 extension PitchSpeller {
 
     // MARK: - Initializers
-- 
2.17.2 (Apple Git-113)


From c2a86bb24aaae43e7371590dc2b31ab1f84c8ded Mon Sep 17 00:00:00 2001
From: Ben Wetherfield <bwetherfield@gmail.com>
Date: Sat, 18 May 2019 13:04:44 +0100
Subject: [PATCH 65/66] Fix func def style

---
 .../Wetherfield/SpellingInverter.swift         | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
index 8f9611b..d07e834 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
@@ -167,7 +167,7 @@ extension SpellingInverter {
         flowNetwork.mask(mask)
     }
 
-    func findCycle(_ dependencies: [PitchedEdge: Set<PitchedEdge>]) -> Bool {
+    func findCycle (_ dependencies: [PitchedEdge: Set<PitchedEdge>]) -> Bool {
 
         func reducer (_ result: Bool, _ keyValue: (key: PitchedEdge, value: Set<PitchedEdge>)) -> Bool {
             
@@ -202,14 +202,14 @@ extension SpellingInverter {
     // MARK: - Convenience Functions
     
     /// Convenience function for testing presence of a given node in the `flowNetwork`
-    func contains(_ indexing: (index: Int, offset: Tendency), _ assignment: Tendency) -> Bool {
+    func contains (_ indexing: (index: Int, offset: Tendency), _ assignment: Tendency) -> Bool {
         return flowNetwork.contains(
             PitchSpeller.AssignedNode(.internal(Cross(indexing.index, indexing.offset)), assignment)
         )
     }
     
     /// Convenience function for testing presence of an internal edge (ignoring assignments)
-    func containsEdge(
+    func containsEdge (
         from source: (index: Int, offset: Tendency),
         to destination: (index: Int, offset: Tendency)
     ) -> Bool {
@@ -228,7 +228,7 @@ extension SpellingInverter {
     }
     
     /// Convenience function for testing presence of internal edge (with assignments)
-    func containsEdge(
+    func containsEdge (
         from source: (index: Int, offset: Tendency, assignment: Tendency),
         to destination: (index: Int, offset: Tendency, assignment: Tendency)
     ) -> Bool {
@@ -243,7 +243,7 @@ extension SpellingInverter {
     }
     
     /// Convenience function for testing presence of edge from source (ignoring assignment)
-    func containsSourceEdge(to destination: (index: Int, offset: Tendency)) -> Bool {
+    func containsSourceEdge (to destination: (index: Int, offset: Tendency)) -> Bool {
         return [.up, .down].reduce(false) { accumulating, next in
             accumulating || containsSourceEdge(
                 from: .down,
@@ -263,7 +263,7 @@ extension SpellingInverter {
     }
     
     /// Convenience function for testing presence of edge from source (with assignments)
-    func containsSourceEdge(
+    func containsSourceEdge (
         from sourceTendency: Tendency,
         to destination: (index: Int, offset: Tendency, assignment: Tendency)
     ) -> Bool {
@@ -276,7 +276,7 @@ extension SpellingInverter {
     }
     
     /// Convenience function for testing presence of edge to sink (with assignments)
-    func containsSinkEdge(
+    func containsSinkEdge (
         from source: (index: Int, offset: Tendency, assignment: Tendency),
         to destinationTendency: Tendency
     ) -> Bool {
@@ -415,7 +415,7 @@ extension DirectedGraph where Node == PitchSpeller.AssignedNode {
 }
 
 /// - Returns: Index and assignment of all internal nodes of the `flowNetwork`.
-private func internalNodes(spellings: [Int: Pitch.Spelling]) -> [PitchSpeller.InternalAssignedNode] {
+private func internalNodes (spellings: [Int: Pitch.Spelling]) -> [PitchSpeller.InternalAssignedNode] {
     return spellings
         .map { offset, spelling in [.down,.up].map { index in node(offset, index, spelling) } }
         .reduce([], +)
@@ -424,7 +424,7 @@ private func internalNodes(spellings: [Int: Pitch.Spelling]) -> [PitchSpeller.In
 /// - Returns: The value of a node at the given offset (index of a `Pitch.Spelling` within `spellings`),
 /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
 /// the given `Pitch.Spelling`.)
-private func node(_ offset: Int, _ index: Tendency, _ pitchSpelling: Pitch.Spelling)
+private func node (_ offset: Int, _ index: Tendency, _ pitchSpelling: Pitch.Spelling)
     -> PitchSpeller.InternalAssignedNode
 {
     let pitchCategory = Pitch.Spelling.Category.category(for: pitchSpelling.pitchClass)!
-- 
2.17.2 (Apple Git-113)


From 3f9df8933186f774aef75622c93e3f59fb6ef435 Mon Sep 17 00:00:00 2001
From: Ben Wetherfield <bwetherfield@gmail.com>
Date: Mon, 27 May 2019 12:36:30 +0100
Subject: [PATCH 66/66] Derive edge weights from graphs with cyclic
 dependencies (#212)

* Add subGraph method for breaking up inputs to inverseSpeller

* Add more concise masking

* Add simple consistent example

* Rename subGraph to partition

* Check semitones are consistent

* Check tones are consistent

* Check minor thirds are consistent

* Check major thirds are consistent

* Check perfect fourths are consistent

* Remove by-hand enumeration

* Refactor enumeration to initializer

* Refactor dictionaries to arrays in tests

* Combine dyads in test to the point that does not yield cycles

* Implement Tarjans algorithm to find SCCs
\

* Add forced unwrapping to Tarjan

* Add function for grouping connected components of directed graph with cycles

* Add general weights generator

* Add function for generating weights from graphs with cycles

* Add non-terminating condition for cyclic graphs

* Fix whitespace

* Add generic findCycle function

* Add generic tarjan for testing

* Fix use of global state in tarjan recursion

* Pass simple Tarjan tests

* Remove non-generic Tarjan

* Clean up dead code

* Remove non-generic findCycle

* Change groupNodes to generic

* Remove test

* Remove print statements

* Rename generic type to more descriptive Node

* Rename large set of dyads test

* Rename SCC test

* Test logic works on simple example with cyclic dependencies

* Add if let nicety

* Fix up enumeration reducer

* Use optional type's automatic Equatable conformace

* Update linuxmain

* Update Structure package

* Refactor Structure Adjacency List data structure in

* Refactor tests

* Cull refactored functions

* Update linux main tests
---
 .../Wetherfield/SpellingInverter.swift        | 98 ++++++++++++-------
 1 file changed, 64 insertions(+), 34 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
index d07e834..34b4e0d 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/SpellingInverter.swift
@@ -32,6 +32,14 @@ extension SpellingInverter {
     
     // MARK: - Initializers
     
+    init(spellings: [Pitch.Spelling], parsimonyPivot: Pitch.Spelling = .d) {
+        let indexed: [Int: Pitch.Spelling] = spellings.enumerated().reduce(into: [:]) { indexedSpellings, indexedSpelling in
+            let (index, spelling) = indexedSpelling
+            indexedSpellings[index] = spelling
+        }
+        self.init(spellings: indexed, parsimonyPivot: parsimonyPivot)
+    }
+    
     init(spellings: [Int: Pitch.Spelling], parsimonyPivot: Pitch.Spelling = .d) {
         self.flowNetwork = DirectedGraph(internalNodes: internalNodes(spellings: spellings))
         self.pitchClass = { int in spellings[int]?.pitchClass }
@@ -74,7 +82,9 @@ extension SpellingInverter {
     /// Weights are parametrized by `Pitch.Class` and `Tendency` values.
     func generateWeights () -> [PitchedEdge: Double] {
         let pitchedDependencies = findDependencies()
-        precondition(!findCycle(pitchedDependencies))
+        if pitchedDependencies.containsCycle() {
+            return generateWeightsFromCycles(pitchedDependencies)
+        }
         func dependeciesReducer (
             _ weights: inout [PitchedEdge: Double],
             _ dependency: (key: PitchedEdge, value: Set<PitchedEdge>)
@@ -84,12 +94,49 @@ extension SpellingInverter {
                 _ weights: inout [PitchedEdge: Double],
                 _ dependency: (key: PitchedEdge, value: Set<PitchedEdge>)
             ) -> Double
+            {
+                let weight = dependency.value.reduce(1.0) { result, edge in
+                    if let edgeWeight = weights[edge] { return result + edgeWeight }
+                    return (
+                        result +
+                        recursiveReducer(&weights, (key: edge, value: pitchedDependencies.adjacencies[edge]!))
+                    )
+                }
+                weights[dependency.key] = weight
+                return weight
+            }
+            let _ = recursiveReducer(&weights, dependency)
+        }
+        return pitchedDependencies.adjacencies.reduce(into: [:], dependeciesReducer)
+    }
+    
+    func generateWeightsFromCycles (_ dependencies: AdjacencyList<PitchedEdge>)
+        -> [PitchedEdge: Double] {
+            let directedAcyclicGraph = dependencies.DAGify()
+            let groupedWeights: [Set<PitchedEdge>: Double] = generateWeights(from: directedAcyclicGraph)
+            return groupedWeights.reduce(into: [PitchedEdge: Double]()) { runningWeights, pair in
+                pair.key.forEach { pitchedEdge in
+                    runningWeights[pitchedEdge] = pair.value
+                }
+            }
+    }
+    
+    func generateWeights<Node> (from dependencies: AdjacencyList<Node>) -> [Node: Double] {
+        func dependeciesReducer (
+            _ weights: inout [Node: Double],
+            _ dependency: (key: Node, value: Set<Node>)
+            )
+        {
+            func recursiveReducer (
+                _ weights: inout [Node: Double],
+                _ dependency: (key: Node, value: Set<Node>)
+                ) -> Double
             {
                 let weight = dependency.value.reduce(1.0) { result, edge in
                     if weights[edge] != nil { return result + weights[edge]! }
                     return (
                         result +
-                        recursiveReducer(&weights, (key: edge, value: pitchedDependencies[edge]!))
+                            recursiveReducer(&weights, (key: edge, value: dependencies.adjacencies[edge]!))
                     )
                 }
                 weights[dependency.key] = weight
@@ -97,7 +144,7 @@ extension SpellingInverter {
             }
             let _ = recursiveReducer(&weights, dependency)
         }
-        return pitchedDependencies.reduce(into: [:], dependeciesReducer)
+        return dependencies.adjacencies.reduce(into: [:], dependeciesReducer)
     }
     
     /// - Returns: getter for the pitched version of a node index
@@ -126,7 +173,7 @@ extension SpellingInverter {
     
     /// - Returns: For each `Edge`, a `Set` of `Edge` values, the sum of whose weights the edge's weight
     /// must be greater than for the inverse spelling procedure to be valid.
-    func findDependencies () -> [PitchedEdge: Set<PitchedEdge>] {
+    func findDependencies () -> AdjacencyList<PitchedEdge> {
         var residualNetwork = flowNetwork
         var weightDependencies: [PitchedEdge: Set<PitchedEdge>] = flowNetwork.edges.lazy
             .map { .init(self.nodeMapper($0.a.unassigned), self.nodeMapper($0.b.unassigned)) }
@@ -152,7 +199,7 @@ extension SpellingInverter {
             residualNetwork.remove(cutEdge)
             residualNetwork.insertEdge(from: cutEdge.b, to: cutEdge.a)
         }
-        return weightDependencies
+        return AdjacencyList(weightDependencies)
     }
 }
 
@@ -160,41 +207,24 @@ extension SpellingInverter {
     
     // MARK: - Instance Methods
     
+    mutating func partition (_ indices: [Int: Int]) {
+        let adjacencyScheme = GraphScheme<FlowNode<Int>> { edge in
+            switch (edge.a, edge.b) {
+            case let (.internal(a), .internal(b)):
+                return indices[a] == indices[b]
+            default:
+                return true
+            }
+        }
+        mask(adjacencyScheme)
+    }
+    
     mutating func mask (_ adjacencyScheme: GraphScheme<FlowNode<Int>>) {
         let temp: GraphScheme<FlowNode<Cross<Int, Tendency>>>
             = adjacencyScheme.pullback(bind { cross in cross.a})
         let mask: GraphScheme<PitchSpeller.AssignedNode> = temp.pullback { node in node.index }
         flowNetwork.mask(mask)
     }
-
-    func findCycle (_ dependencies: [PitchedEdge: Set<PitchedEdge>]) -> Bool {
-
-        func reducer (_ result: Bool, _ keyValue: (key: PitchedEdge, value: Set<PitchedEdge>)) -> Bool {
-            
-            var graph = dependencies
-            var flag = false
-            
-            func depthFirstSearch (
-                _ visited: inout Set<PitchedEdge>,
-                _ keyValue: (key: PitchedEdge, value: Set<PitchedEdge>)
-            )
-            {
-                guard let first = graph[keyValue.key]?.first, flag == false else { return }
-                graph[keyValue.key]!.remove(first)
-                if !visited.contains(keyValue.key) && visited.contains(first) {
-                    flag = true
-                    return
-                }
-                visited.insert(keyValue.key)
-                depthFirstSearch(&visited, (first, graph[first]!))
-            }
-
-            let _ = dependencies.reduce(into: [], depthFirstSearch)
-            return flag
-        }
-
-        return dependencies.reduce(false, reducer)
-    }
 }
 
 extension SpellingInverter {
-- 
2.17.2 (Apple Git-113)

