From a13c88c51417a9dd957fbd1d6a0caeb317823c4e Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 27 Oct 2018 14:28:02 -0400
Subject: [PATCH 26/66] Flow network to graph on master (#141)

---
 .../Wetherfield/FlowNetwork.swift             | 50 ++++++++++++-------
 .../Wetherfield/Wetherfield.swift             |  2 +-
 2 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 1feb46c..21d83c1 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -11,13 +11,19 @@ import DataStructures
 /// - Each edge has a capacity for flow
 /// - A "source" node, which only emanates flow outward
 /// - A "sink" node, which only receives flow
-public struct FlowNetwork <Node: Hashable, Weight: Numeric & Comparable> {
-
-    // MARK: - Instance Properties
+public struct FlowNetwork<Node: Hashable, Weight: Numeric & Comparable>:
+    WeightedGraphProtocol,
+    DirectedGraphProtocol
+{
+    public var weights: [Edge : Weight]
+    public var nodes: Set<Node>
+    public var source: Node
+    public var sink: Node
+}
 
-    var directedGraph: WeightedDirectedGraph<Node,Weight>
-    var source: Node
-    var sink: Node
+extension FlowNetwork {
+    
+    public typealias Edge = OrderedPair<Node>
 }
 
 extension FlowNetwork {
@@ -26,16 +32,26 @@ extension FlowNetwork {
 
     /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
     init(_ directedGraph: WeightedDirectedGraph<Node,Weight>, source: Node, sink: Node) {
-        self.directedGraph = directedGraph
-        self.directedGraph.insert(source)
-        self.directedGraph.insert(sink)
+        self.nodes = directedGraph.nodes
+        self.weights = directedGraph.weights
         self.source = source
         self.sink = sink
     }
 }
 
-extension WeightedDirectedGraph where Weight: Comparable {
-    // TODO: Make throw
+extension FlowNetwork {
+
+    // MARK: - Instance Methods
+
+    func contains(_ node: Node) -> Bool {
+        return node == source || node == sink || nodes.contains(node)
+    }
+}
+
+extension FlowNetwork {
+
+    // MARK: - Mutating Methods
+
     mutating func reduceFlow(through edge: Edge, by amount: Weight) {
         updateEdge(edge) { weight in weight - amount }
     }
@@ -83,7 +99,7 @@ extension FlowNetwork {
     /// - Returns: All of the `Node` values contained herein which are neither the `source` nor
     /// the `sink`.
     public var internalNodes: [Node] {
-        return directedGraph.nodes.filter { $0 != source && $0 != sink }
+        return nodes.filter { $0 != source && $0 != sink }
     }
 
     /// - Returns: A minimum cut with nodes included on the `sink` side in case of a
@@ -101,7 +117,7 @@ extension FlowNetwork {
     var maximumFlowAndResidualNetwork: (flow: Weight, network: DirectedGraph<Node>) {
         // Make a copy of the directed representation of the network to be mutated by pushing flow
         // through it.
-        var residualNetwork = directedGraph
+        var residualNetwork = self
         // While an augmenting path (a path emanating directionally from the source node) can be
         // found, push flow through the path, mutating the residual network
         while let augmentingPath = residualNetwork.shortestUnweightedPath(from: source, to: sink) {
@@ -110,14 +126,14 @@ extension FlowNetwork {
         // Compares the edges in the mutated residual network against the original directed
         // graph.
         let flow: Weight = {
-            let sourceEdges = directedGraph.neighbors(of: source).lazy
+            let sourceEdges = neighbors(of: source).lazy
                 .map { OrderedPair(self.source, $0) }
                 .partition(residualNetwork.contains)
             let edgesPresent = sourceEdges.whereTrue.lazy
-                .map { edge in self.directedGraph.weight(edge)! - residualNetwork.weight(edge)! }
+                .map { edge in self.weight(edge)! - residualNetwork.weight(edge)! }
                 .reduce(0,+)
             let edgesAbsent = sourceEdges.whereFalse.lazy
-                .compactMap(directedGraph.weight)
+                .compactMap(weight)
                 .reduce(0,+)
             return edgesPresent + edgesAbsent
         }()
@@ -130,7 +146,7 @@ extension Sequence {
     func filterComplement (_ predicate: (Element) -> Bool) -> [Element] {
         return filter { !predicate($0) }
     }
-    
+
     func partition (_ predicate: (Element) -> Bool) -> (whereFalse: [Element], whereTrue: [Element]) {
         return (filterComplement(predicate), filter(predicate))
     }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index a92d5db..0907eb0 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -28,7 +28,7 @@ struct PitchSpeller {
             self.assignment = assignment
         }
     }
-    
+
     struct IndexedPitch: PitchSpellingNode {
         let index: Int
         let pitch: Pitch
-- 
2.17.2 (Apple Git-113)

