From fc424bd980bfc944857ad12ab663996ad9c8f653 Mon Sep 17 00:00:00 2001
From: bwetherfield <bwetherfield@gmail.com>
Date: Sat, 27 Oct 2018 14:40:33 -0400
Subject: [PATCH 29/66] Use Cross<Int,Tendency> as PitchSpellingNode.Index
 [based on (#135)] (into master) (#143)

---
 .../Wetherfield/Wetherfield.swift             | 38 +++++++++----------
 1 file changed, 17 insertions(+), 21 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 55116e3..8d91ead 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -9,46 +9,42 @@ import DataStructures
 import Pitch
 
 protocol PitchSpellingNode: Hashable {
-    associatedtype Index
-    
+    typealias Index = Cross<Int,Tendency>
     var index: Index { get }
 }
 
 struct PitchSpeller {
 
     struct UnassignedNode: PitchSpellingNode {
-        let index: Cross<Int, Tendency>
+        let index: Index
     }
 
     struct AssignedNode: PitchSpellingNode {
-        let index: Cross<Int, Tendency>
+        let index: Index
         let assignment: Tendency
-        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+        init(_ index: Index, _ assignment: Tendency) {
             self.index = index
             self.assignment = assignment
         }
     }
 
-    struct IndexedPitch: PitchSpellingNode {
-        let index: Int
-        let pitch: Pitch
-    }
-
     /// - Returns: The nodes for the `Pitch` at the given `index`.
-    private static func nodes(pitchAtIndex index: Int) -> (Cross<Int, Tendency>, Cross<Int, Tendency>) {
+    private static func nodes(pitchAtIndex index: Int)
+        -> (PitchSpellingNode.Index, PitchSpellingNode.Index)
+    {
         return (.init(index, .down), .init(index, .up))
     }
 
     /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
     /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
     /// the given `Pitch`.)
-    private static func node(_ offset: Int, _ index: Tendency) -> Cross<Int, Tendency> {
+    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
         return .init(offset, index)
     }
 
     /// - Returns: An array of nodes, each representing the index of the unassigned node in
     /// `pitchNodes`.
-    private static func internalNodes(pitches: [Int: Pitch]) -> [Cross<Int, Tendency>] {
+    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
         return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
     }
 
@@ -62,10 +58,10 @@ struct PitchSpeller {
 
     /// The nodes within the `FlowNetwork`. The values are the encodings of the indices of `Pitch`
     /// values in `pitches.
-    let pitchNodes: [Cross<Int, Tendency>]
+    let pitchNodes: [PitchSpellingNode.Index]
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
-    let flowNetwork: FlowNetwork<Cross<Int, Tendency>,Double>
+    var flowNetwork: FlowNetwork<PitchSpellingNode.Index,Double>
 
     // MARK: - Initializers
 
@@ -75,8 +71,8 @@ struct PitchSpeller {
         self.parsimonyPivot = parsimonyPivot
         self.pitchNodes = PitchSpeller.internalNodes(pitches: pitches)
         self.flowNetwork = FlowNetwork(
-            source: Cross<Int, Tendency>(-1, .down),
-            sink: Cross<Int, Tendency>(-1, .up),
+            source: PitchSpellingNode.Index(-1, .down),
+            sink: PitchSpellingNode.Index(-1, .up),
             internalNodes: pitchNodes
         )
     }
@@ -114,16 +110,16 @@ struct PitchSpeller {
     }
 
     /// - Returns: The `Pitch` value for the given `node` value.
-    private func pitch(node: Cross<Int, Tendency>) -> Pitch {
+    private func pitch(node: PitchSpellingNode.Index) -> Pitch {
         return pitches[node.a]!
     }
 }
 
-extension FlowNetwork where Node == Cross<Int, Tendency>, Weight == Double {
+extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-    init(source: Cross<Int, Tendency>, sink: Cross<Int, Tendency>, internalNodes: [Cross<Int, Tendency>]) {
-        let graph = WeightedDirectedGraph<Cross<Int, Tendency>,Double>(
+    init(source: PitchSpellingNode.Index, sink: PitchSpellingNode.Index, internalNodes: [PitchSpellingNode.Index]) {
+        let graph = WeightedDirectedGraph<PitchSpellingNode.Index,Double>(
             source: source,
             sink: sink,
             internalNodes: internalNodes
-- 
2.17.2 (Apple Git-113)

