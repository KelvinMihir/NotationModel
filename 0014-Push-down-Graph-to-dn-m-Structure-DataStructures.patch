From 2159971541e52ba3f6b018e8772046dbea985963 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sat, 29 Sep 2018 13:50:57 -0700
Subject: [PATCH 14/66] Push down Graph to dn-m/Structure/DataStructures

Push down Graph to dn-m/Structure/DataStructures
---
 .../Wetherfield/Data Structures/Cross.swift   |  29 --
 .../Data Structures/EdgeLike.swift            |  14 -
 .../Data Structures/FlowNetwork.swift         | 111 ------
 .../Wetherfield/Data Structures/Graph.swift   | 348 ------------------
 .../Data Structures/NodePair.swift            |  21 --
 .../Data Structures/OrderedPair.swift         |  34 --
 .../Wetherfield/Data Structures/Pair.swift    |  23 --
 .../Wetherfield/Data Structures/Queue.swift   |  45 ---
 .../Data Structures/SwappablePair.swift       |  14 -
 .../Data Structures/SymmetricPair.swift       |   8 -
 .../Data Structures/UnorderedPair.swift       |  45 ---
 .../Data Structures/Weighted.swift            |  17 -
 .../Wetherfield/FlowNetwork.swift             | 135 +++++++
 .../Wetherfield/Wetherfield.swift             |  25 +-
 14 files changed, 150 insertions(+), 719 deletions(-)
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift
 delete mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift
 create mode 100644 Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift
deleted file mode 100644
index 982a5df..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Cross.swift	
+++ /dev/null
@@ -1,29 +0,0 @@
-//
-//  Cross.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-/// - TODO: Move to `dn-m/Structure/DataStructures`
-struct Cross<T,U>: Pair {
-    
-    typealias A = T
-    typealias B = U
-    
-    let a: T
-    let b: U
-    
-    init(_ a: A, _ b: B) {
-        self.a = a
-        self.b = b
-    }
-    
-    init(_ pair: (A, B)) {
-        self.a = pair.0
-        self.b = pair.1
-    }
-}
-
-extension Cross: Equatable where T: Equatable, U: Equatable { }
-extension Cross: Hashable where T: Hashable, U: Hashable { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift
deleted file mode 100644
index fc345cb..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/EdgeLike.swift	
+++ /dev/null
@@ -1,14 +0,0 @@
-//
-//  EdgeLike.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-protocol EdgeLike: Weighted & NodePair {
-    init(_ nodes: Pair, _ weight: Weight)
-}
-
-extension EdgeLike where Pair: SwappablePair {
-    var reversed: Self { return Self(nodes.swapped, weight) }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift
deleted file mode 100644
index 1df2a5b..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/FlowNetwork.swift	
+++ /dev/null
@@ -1,111 +0,0 @@
-//
-//  FlowNetwork.swift
-//  PitchSpeller
-//
-//  Created by James Bean on 5/24/18.
-//
-
-// MARK: Type Aliases
-typealias DirectedGraph<Node: Hashable> = Graph<Double, DirectedOver<Node>>
-typealias UnweightedGraph<Node: Hashable> = Graph<WithoutWeights, DirectedOver<Node>>
-
-/// Directed Graph with several properties:
-/// - Each edge has a capacity for flow
-/// - A "source" node, which is only emanates flow outward
-/// - A "sink" node, which only receives flow
-public struct FlowNetwork <Node: Hashable> {
-    
-    typealias DirectedPath = DirectedGraph<Node>.Path
-    typealias DirectedEdge = DirectedGraph<Node>.Edge
-
-    /// - Returns: All of the `Node` values contained herein which are neither the `source` nor
-    /// the `sink`.
-    public var internalNodes: [Node] {
-        return directedGraph.nodes.filter { $0 != source && $0 != sink }
-    }
-    
-    /// - Returns: (0) The maximum flow of the network and (1) the residual network produced after
-    /// pushing all possible flow from source to sink (while satisfying flow constraints) - with
-    /// saturated edges flipped and all weights removed.
-    var solvedForMaximumFlow: (flow: Double, network: UnweightedGraph<Node>) {
-        var residualNetwork = directedGraph
-        
-        func findAugmentingPath () -> Bool {
-            guard let path = residualNetwork.shortestUnweightedPath(from: source, to: sink) else {
-                return false
-            }
-            pushFlow(through: path)
-            return true
-        }
-            
-        func pushFlow (through path: UnweightedGraph<Node>.Path) {
-            let minimumEdge = (path.adjacents.compactMap(residualNetwork.weight).min())!
-            path.adjacents.forEach { edge in
-                residualNetwork.updateEdge(edge, with: { capacity in capacity - minimumEdge })
-                if residualNetwork.weight(edge)! == 0.0 {
-                    residualNetwork.removeEdge(from: edge.a, to: edge.b)
-                }
-                if residualNetwork.contains(edge.swapped) {
-                    residualNetwork.updateEdge(edge.swapped, with: { capacity in capacity + minimumEdge })
-                }
-                else { residualNetwork.insertEdge(edge.swapped, minimumEdge) }
-            }
-        }
-        
-        func computeFlow () -> Double {
-            let sourceEdges = directedGraph.neighbors(of: source).lazy
-                .map { OrderedPair(self.source, $0) }
-                .partition(residualNetwork.contains)
-            let edgesPresent = sourceEdges.whereTrue.lazy
-                .map { self.directedGraph.weight($0)! - residualNetwork.weight($0)! }
-                .reduce(0.0, +)
-            let edgesAbsent = sourceEdges.whereFalse.lazy
-                .compactMap(directedGraph.weight)
-                .reduce(0.0, +)
-            return edgesPresent + edgesAbsent
-        }
-        
-        while findAugmentingPath() { continue }
-        return (computeFlow(), residualNetwork.unweighted)
-    }
-    
-    /// - Returns: A minimum cut with nodes included on the `sink` side in case of a
-    /// tiebreak (in- and out- edges saturated).
-    public var minimumCut: (Set<Node>, Set<Node>) {
-        return (sourceSideNodes, notSourceSideNodes)
-    }
-    
-    /// - Returns: Nodes in residual network reachable from the `source`
-    private var sourceSideNodes: Set<Node> {
-        return Set(solvedForMaximumFlow.network.breadthFirstSearch(from: source))
-    }
-    
-    /// - Returns: Nodes in residual network *not* reachable from the `source`
-    private var notSourceSideNodes: Set<Node> {
-        return solvedForMaximumFlow.network.nodes.subtracting(sourceSideNodes)
-    }
-
-    // TODO: Consider more (space-)efficient storage of Nodes.
-    internal var directedGraph: DirectedGraph<Node>
-    internal var source: Node
-    internal var sink: Node
-
-    // MARK: - Initializers
-    
-    /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
-    init(_ directedGraph: DirectedGraph<Node>, source: Node, sink: Node) {
-        self.directedGraph = directedGraph
-        self.source = source
-        self.sink = sink
-    }
-}
-
-extension Sequence {
-    func filterComplement (_ predicate: (Element) -> Bool) -> [Element] {
-        return filter { !predicate($0) }
-    }
-    
-    func partition (_ predicate: (Element) -> Bool) -> (whereFalse: [Element], whereTrue: [Element]) {
-        return (filterComplement(predicate), filter(predicate))
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift
deleted file mode 100644
index d6d5380..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Graph.swift	
+++ /dev/null
@@ -1,348 +0,0 @@
-//
-//  Graph.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/14/18.
-//
-
-// MARK: - Directedness Flags
-
-protocol Directedness { }
-protocol Directed: Directedness { }
-protocol Undirected: Directedness { }
-
-typealias DirectedOver = OrderedPair
-extension DirectedOver: Directed { }
-
-typealias UndirectedOver = UnorderedPair
-extension UndirectedOver: Undirected { }
-
-// MARK: - Weightedness Flags
-
-protocol Weightedness { }
-protocol Unweighted: Weightedness { }
-protocol AsWeight: Weightedness { }
-
-// Allows Double to be used as an edge weight
-extension Double: AsWeight { }
-enum WithoutWeights: Unweighted {
-    case unweighted
-}
-
-// Weightable, directable implementation of a Graph structure.
-struct Graph <Weight: Weightedness, Pair: SymmetricPair & Directedness & Hashable>
-    where Pair.A: Hashable
-{
-    // MARK: - Instance Properties
-     
-    var nodes: Set<Node>
-    var adjacents: [Pair: Weight]
-}
-
-extension Graph {
-
-    // MARK: - Type Aliases
-
-    typealias Node = Pair.A
-}
-
-extension Graph {
-
-    // MARK: - Nested Types
-
-    struct Edge {
-
-        // MARK: - Instance Properties
-
-        let nodes: Pair
-        let weight: Weight
-
-        // MARK: - Initializers
-
-        init (_ a: Graph.Node, _ b: Graph.Node, withWeight weight: Weight) {
-            self.nodes = Pair(a, b)
-            self.weight = weight
-        }
-
-        init (_ nodes: Pair, withWeight weight: Weight) {
-            self.nodes = nodes
-            self.weight = weight
-        }
-    }
-
-    struct Path {
-
-        // MARK: - Instance Properties
-
-        let nodes: [Node]
-        let weights: [Pair: Weight]
-
-        // MARK: - Initializers
-
-        init (_ nodes: [Node], _ weights: [Pair: Weight]) {
-            self.nodes = nodes
-            self.weights = weights
-        }
-    }
-}
-
-extension Graph {
-
-    // MARK: - Initializers
-
-    /// Creates a `Graph` without nodes.
-    init () {
-        nodes = []
-        adjacents = [:]
-    }
-
-    /// Creates a `Graph` with the given `nodes` and `adjacents`, describing how the given `nodes`
-    /// are connected.
-    init (_ nodes: Set<Node>, _ adjacents: [Pair: Weight]) {
-        self.nodes = nodes
-        self.adjacents = adjacents
-    }
-}
-
-extension Graph {
-
-    // MARK: - Computed Properties
-
-    /// - Returns: All of the `Edge` values contained herein.
-    ///
-    /// - Remark: Consider returning a `Set` instead of an `Array`, as order does not have
-    /// significance.
-    var edges: [Edge] {
-        return adjacents.map(Edge.init)
-    }
-}
-
-extension Graph {
-
-    // MARK: - Modifying a `Graph`
-
-    /// Inserts the given `node` into the `Graph`.
-    mutating func insertNode (_ node: Node) {
-        nodes.insert(node)
-    }
-
-    /// Connects the `source` node to the `destination` with the given `weight`.
-    ///
-    /// - Remark: We should consider only exposing this for weighted graphs.
-    mutating func insertEdge (from source: Node, to destination: Node, withWeight weight: Weight) {
-        adjacents[Pair(source, destination)] = weight
-    }
-
-    /// Inserts the given pair-value pair into the `Graph`.
-    mutating func insertEdge (_ pairAndWeight: (pair: Pair, weight: Weight)) {
-        insertEdge(pairAndWeight.pair, pairAndWeight.weight)
-    }
-
-    /// Insert an `Edge` between the given `pair` with the given `weight`.
-    ///
-    /// - Remark: We should consider only exposing this for weighted graphs.
-    mutating func insertEdge(_ pair: Pair, _ weight: Weight) {
-        insertEdge(from: pair.a, to: pair.b, withWeight: weight)
-    }
-
-    /// Updates the weight of the edge connecting the given `pair`.
-    ///
-    /// > If the nodes in the given `pair` do not exist, or are no connected, no action is taken.
-    mutating func updateEdge(_ pair: Pair, with transform: (Weight) -> Weight) {
-        guard let weight = weight(pair) else { return }
-        insertEdge(pair, transform(weight))
-    }
-
-    /// Inserts the given `path` into the `Graph`.
-    mutating func insertPath (_ path: Path) {
-        path.nodes.forEach { insertNode($0) }
-        path.weights.forEach { insertEdge($0) }
-    }
-
-    /// Removes the edge between the given `source` and `destination` nodes.
-    mutating func removeEdge (from source: Node, to destination: Node) {
-        adjacents[Pair(source, destination)] = nil
-    }
-}
-
-extension Graph {
-
-    // MARK: - Querying a `Graph`
-
-    /// - Returns: `true` if the graph contains this `node`, else `false`
-    func contains (_ node: Node) -> Bool {
-        return nodes.contains(node)
-    }
-
-    /// - Returns: `true` if `edge.nodes` are adjacent in the graph, else `false`
-    func contains (_ edge: Pair) -> Bool {
-        return adjacents.keys.contains(edge)
-    }
-
-    /// - Returns: Weight of the edge from `source` to `destination` if it exists, else nil
-    func weight (from source: Node, to destination: Node) -> Weight? {
-        return weight(Pair(source, destination))
-    }
-
-    /// - Returns: Weight of the edge containing this `pair` of nodes if it exists, else nil
-    func weight (_ pair: Pair) -> Weight? {
-        return adjacents[pair]
-    }
-
-    /// - Returns: Array of nodes adjacent to `source`
-    func neighbors (of source: Node) -> [Node] {
-        return nodes.filter { adjacents.keys.contains(Pair(source, $0)) }
-    }
-
-    /// - Returns: Array of nodes adjacent to `source` out of the supplied array of `nodes`.
-    func neighbors (of source: Node, from nodes: [Node]) -> [Node] {
-        return neighbors(of: source, from: Set(nodes))
-    }
-
-    /// - Returns: Array of nodes adjacent to `source` out of the supplied set of `nodes`.
-    func neighbors (of source: Node, from nodes: Set<Node>) -> [Node] {
-        return nodes.filter { adjacents.keys.contains(Pair(source, $0)) }
-    }
-
-    /// - Returns: Array of edges emanating from `source`
-    func edges (from source: Node) -> [Edge] {
-        return nodes.compactMap {
-            guard let weight = adjacents[Pair(source, $0)] else { return nil }
-            return Edge(source, $0, withWeight: weight)
-        }
-    }
-}
-
-extension Graph where Weight == WithoutWeights {
-    
-    // MARK: - Instance Methods
-    
-    mutating func insertEdge (from source: Node, to destination: Node) {
-        insertEdge(from: source, to: destination, withWeight: .unweighted)
-    }
-    
-    mutating func insertPath (_ nodes: [Graph.Node]) {
-        insertPath(Path(nodes))
-    }
-}
-
-extension Graph where Weight: AsWeight {
-    
-    // MARK: - Instance Methods
-    
-    static func unWeightedVersion (of weightedGraph: Graph) -> Graph<WithoutWeights, Pair> {
-        let adjacents: [Pair: WithoutWeights] = weightedGraph.adjacents.mapValues { _ in .unweighted }
-        return Graph<WithoutWeights, Pair>(weightedGraph.nodes, adjacents)
-    }
-    
-    var unweighted: Graph<WithoutWeights,Pair> {
-        return .init(nodes, adjacents.mapValues { _ in .unweighted })
-    }
-}
-
-extension Graph.Edge where Weight == WithoutWeights {
-    
-    // MARK: - Initializers
-    
-    init (_ a: Graph.Node, _ b: Graph.Node) {
-        self.nodes = Pair(a, b)
-        self.weight = .unweighted
-    }
-}
-
-extension Graph where Pair: SwappablePair {
-    
-    // MARK: - Instance Methods
-    
-    mutating func flipEdge (containing nodes: Pair) {
-        adjacents[nodes.swapped] = adjacents[nodes]
-        adjacents[nodes] = nil
-    }
-}
-
-extension Graph.Path where Weight == WithoutWeights {
-    
-    // MARK: - Instance properties
-    
-    var adjacents: Set<Pair> {
-        return Set(weights.keys)
-    }
-    
-    // MARK: - Initializers
-    
-    init (_ nodes: [Graph.Node]) {
-        let count = nodes.count
-        var weights: [Pair: Weight] = [:]
-        nodes.enumerated().forEach { index, currentNode in
-            if index <= count - 2 {
-                let nextNode = nodes[index + 1]
-                weights[Pair(currentNode, nextNode)] = .unweighted
-            }
-        }
-        self.init(nodes, weights)
-    }
-}
-
-extension Graph.Edge where Pair: Directed {
-    
-    // MARK: - Instance Properties
-    
-    var source: Graph.Node { return nodes.a }
-    var destination: Graph.Node { return nodes.b }
-}
-
-extension Graph {
-    
-    // MARK: = Typealiases
-    
-    typealias UnweightedPath = Graph<WithoutWeights, DirectedOver<Node>>.Path
-    
-    // MARK: - Instance Methods
-    
-    func shortestUnweightedPath (from source: Node, to destination: Node) -> UnweightedPath? {
-        
-        var breadcrumbs: [Node: Node] = [:]
-        
-        func backtrace () -> UnweightedPath {
-            var path = [destination]
-            var cursor = destination
-            while cursor != source {
-                path.insert(breadcrumbs[cursor]!, at: 0)
-                cursor = breadcrumbs[cursor]!
-            }
-            return UnweightedPath(path)
-        }
-        
-        if source == destination { return UnweightedPath([destination]) }
-        
-        var unvisited = nodes
-        var queue: Queue<Node> = []
-        
-        queue.push(source)
-        while !queue.isEmpty {
-            let node = queue.pop()
-            for neighbor in neighbors(of: node, from: unvisited) {
-                queue.push(neighbor)
-                unvisited.remove(neighbor)
-                breadcrumbs[neighbor] = node
-                if neighbor == destination { return backtrace() }
-            }
-        }
-        return nil
-    }
-    
-    internal func breadthFirstSearch(from source: Node) -> [Node] {
-        var visited: [Node] = []
-        var queue: Queue<Node> = []
-        queue.push(source)
-        visited.append(source)
-        while !queue.isEmpty {
-            let node = queue.pop()
-            for neighbor in neighbors(of: node) where !visited.contains(neighbor) {
-                queue.push(neighbor)
-                visited.append(neighbor)
-            }
-        }
-        return visited
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift
deleted file mode 100644
index 55b3f4f..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/NodePair.swift	
+++ /dev/null
@@ -1,21 +0,0 @@
-//
-//  NodePair.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-protocol NodePair {
-    
-    // MARK: - Associated Types
-    
-    associatedtype Pair: SymmetricPair
-    
-    // MARK: - Typealiases
-    
-    typealias Node = Pair.A
-    
-    // MARK: - Instance Properties
-    
-    var nodes: Pair { get }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift
deleted file mode 100644
index b42d5cd..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/OrderedPair.swift	
+++ /dev/null
@@ -1,34 +0,0 @@
-//
-//  OrderedPair.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-/// Pair of values for which the order matters.
-struct OrderedPair <T>: SwappablePair {
-
-    // MARK: - Instance Properties
-
-    let a: T
-    let b: T
-
-    // MARK: - Initializers
-
-    init(_ pair: (T, T)) {
-        self.a = pair.0
-        self.b = pair.1
-    }
-    
-    init(_ a: T, _ b: T) {
-        self.a = a
-        self.b = b
-    }
-}
-
-// MARK: - Equatable
-extension OrderedPair: Equatable where T: Equatable { }
-
-// MARK: - Hashable
-extension OrderedPair: Hashable where T: Hashable { }
-
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift
deleted file mode 100644
index 33172fd..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Pair.swift	
+++ /dev/null
@@ -1,23 +0,0 @@
-//
-//  Pairable.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-protocol Pair {
-    
-    // MARK: - Associated Types
-    
-    associatedtype A
-    associatedtype B
-    
-    // MARK: - Instance Properties
-    
-    var a: A { get }
-    var b: B { get }
-    
-    // MARK: - Initializers
-    
-    init(_ a: A, _ b: B)
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift
deleted file mode 100644
index 604a62d..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Queue.swift	
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-//  Queue.swift
-//  PitchSpeller
-//
-//  Created by James Bean on 5/29/18.
-//
-
-/// Queue.
-///
-/// - TODO: Move to dn-m/Structure/DataStructures
-public struct Queue <Element: Equatable> {
-
-    private var storage: [Element] = []
-
-    public var isEmpty: Bool {
-        return storage.isEmpty
-    }
-
-    public var count: Int {
-        return storage.count
-    }
-
-    public mutating func push(_ value: Element) {
-        storage.append(value)
-    }
-
-    public mutating func pop() -> Element {
-        return storage.remove(at: 0)
-    }
-
-    public func contains(_ value: Element) -> Bool {
-        if storage.index(of: value) != nil {
-            return true
-        }
-        return false
-    }
-}
-
-extension Queue: ExpressibleByArrayLiteral {
-
-    /// Create a `Queue` with an `ArrayLiteral`.
-    public init(arrayLiteral elements: Element...) {
-        self.storage = elements
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift
deleted file mode 100644
index aa409e7..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SwappablePair.swift	
+++ /dev/null
@@ -1,14 +0,0 @@
-//
-//  Swappable.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-protocol SwappablePair: SymmetricPair {
-    var swapped: Self { get }
-}
-
-extension SwappablePair {
-    var swapped: Self { return .init(b, a) }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift
deleted file mode 100644
index 61abe21..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/SymmetricPair.swift	
+++ /dev/null
@@ -1,8 +0,0 @@
-//
-//  Symmetric.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-protocol SymmetricPair: Pair where A == B { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift
deleted file mode 100644
index ac8584a..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/UnorderedPair.swift	
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-//  UnorderedPair.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 6/30/18.
-//
-
-struct UnorderedPair<T>: SymmetricPair {
-    
-    typealias A = T
-    
-    let a: T
-    let b: T
-    
-    init(_ pair: (T, T)) {
-        self.a = pair.0
-        self.b = pair.1
-    }
-    
-    init(_ a: T, _ b: T) {
-        self.a = a
-        self.b = b
-    }
-}
-
-extension UnorderedPair: Equatable where T: Equatable {
-
-    // MARK: - Equatable
-
-    /// - Returns: `true` if both values contained by the given `UnorderedPair` values are
-    /// equivalent, regardless of order. Otherwise, `false`.
-    static func == (_ lhs: UnorderedPair, _ rhs: UnorderedPair) -> Bool {
-        return (lhs.a == rhs.a && lhs.b == rhs.b) || (lhs.a == rhs.b && lhs.b == rhs.a)
-    }
-}
-
-extension UnorderedPair: Hashable where T: Hashable {
-
-    // MARK: - Hashable
-
-    /// Implements hashable requirement.
-    func hash(into hasher: inout Hasher) {
-        return Set([a,b]).hash(into: &hasher)
-    }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift
deleted file mode 100644
index 595772e..0000000
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Data Structures/Weighted.swift	
+++ /dev/null
@@ -1,17 +0,0 @@
-//
-//  Weighted.swift
-//  PitchSpeller
-//
-//  Created by Benjamin Wetherfield on 7/1/18.
-//
-
-protocol Weighted {
-    
-    // MARK: - Associated Types
-    
-    associatedtype Weight
-    
-    // MARK: - Instance Properties
-    
-    var weight: Weight { get set }
-}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
new file mode 100644
index 0000000..cf246c2
--- /dev/null
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -0,0 +1,135 @@
+//
+//  FlowNetwork.swift
+//  PitchSpeller
+//
+//  Created by James Bean on 5/24/18.
+//
+
+import DataStructures
+
+/// Directed graph with several properties:
+/// - Each edge has a capacity for flow
+/// - A "source" node, which is only emanates flow outward
+/// - A "sink" node, which only receives flow
+public struct FlowNetwork <Node: Hashable, Weight: Numeric & Comparable> {
+
+    // MARK: - Instance Properties
+
+    var directedGraph: WeightedDirectedGraph<Node,Weight>
+    var source: Node
+    var sink: Node
+}
+
+extension FlowNetwork {
+
+    // MARK: - Initializers
+
+    /// Create a `FlowNetwork` with the given `directedGraph` and the given `source` and `sink` nodes.
+    init(_ directedGraph: WeightedDirectedGraph<Node,Weight>, source: Node, sink: Node) {
+        self.directedGraph = directedGraph
+        self.source = source
+        self.sink = sink
+    }
+}
+
+extension WeightedDirectedGraph where Weight: Comparable {
+    // TODO: Make throw
+    mutating func reduceFlow(through edge: Edge, by amount: Weight) {
+        updateEdge(edge) { weight in weight - amount }
+    }
+
+    /// Removes the given edge if its weight is `0`. This happens after an edge, which has the
+    /// minimum flow of an augmenting path, is reduced by the minimum flow (which is its previous
+    /// value).
+    mutating func removeEdgeIfFlowless(_ edge: Edge) {
+        if weight(edge) == 0 {
+            removeEdge(edge)
+        }
+    }
+
+    /// Inserts an edge in the opposite direction of the given `edge` with the minimum flow
+    mutating func updateBackEdge(_ edge: Edge, by minimumFlow: Weight) {
+        let reversedEdge = edge.swapped
+        if contains(reversedEdge) {
+            updateEdge(reversedEdge) { capacity in capacity + minimumFlow }
+        } else {
+            insertEdge(reversedEdge, weight: minimumFlow)
+        }
+    }
+
+    /// Reduces the flow of the given `edge` by the given `minimumFlow`. If the new flow through
+    /// the `edge` is now `0`, removes the `edge` from the network. Updates the reverse of the given
+    /// `edge` by the given `minimumFlow`.
+    mutating func pushFlow(through edge: Edge, by minimumFlow: Weight) {
+        reduceFlow(through: edge, by: minimumFlow)
+        removeEdgeIfFlowless(edge)
+        updateBackEdge(edge, by: minimumFlow)
+    }
+
+    /// Pushes flow through the given `path` in this `graph`.
+    mutating func pushFlow(through path: [Node]) {
+        let edges = path.pairs.map(OrderedPair.init)
+        let minimumFlow = edges.compactMap(weight).min() ?? 0
+        edges.forEach { edge in pushFlow(through: edge, by: minimumFlow) }
+    }
+}
+
+extension FlowNetwork {
+
+    // MARK: - Computed Properties
+
+    /// - Returns: All of the `Node` values contained herein which are neither the `source` nor
+    /// the `sink`.
+    public var internalNodes: [Node] {
+        return directedGraph.nodes.filter { $0 != source && $0 != sink }
+    }
+
+    /// - Returns: A minimum cut with nodes included on the `sink` side in case of a
+    /// tiebreak (in- and out- edges saturated).
+    public var minimumCut: (Set<Node>, Set<Node>) {
+        let (_, residualNetwork) = maximumFlowAndResidualNetwork
+        let sourceSideNodes = Set(residualNetwork.breadthFirstSearch(from: source))
+        let notSourceSideNodes = residualNetwork.nodes.subtracting(sourceSideNodes)
+        return (sourceSideNodes, notSourceSideNodes)
+    }
+
+    /// - Returns: (0) The maximum flow of the network and (1) the residual network produced after
+    /// pushing all possible flow from source to sink (while satisfying flow constraints) - with
+    /// saturated edges flipped and all weights removed.
+    var maximumFlowAndResidualNetwork: (flow: Weight, network: DirectedGraph<Node>) {
+        // Make a copy of the directed representation of the network to be mutated by pushing flow
+        // through it.
+        var residualNetwork = directedGraph
+        // While an augmenting path (a path emanating directionally from the source node) can be
+        // found, push flow through the path, mutating the residual network
+        while let augmentingPath = residualNetwork.shortestUnweightedPath(from: source, to: sink) {
+            residualNetwork.pushFlow(through: augmentingPath)
+        }
+        // Compares the edges in the mutated residual network against the original directed
+        // graph.
+        let flow: Weight = {
+            let sourceEdges = directedGraph.neighbors(of: source).lazy
+                .map { OrderedPair(self.source, $0) }
+                .partition(residualNetwork.contains)
+            let edgesPresent = sourceEdges.whereTrue.lazy
+                .map { edge in self.directedGraph.weight(edge)! - residualNetwork.weight(edge)! }
+                .reduce(0,+)
+            let edgesAbsent = sourceEdges.whereFalse.lazy
+                .compactMap(directedGraph.weight)
+                .reduce(0,+)
+            return edgesPresent + edgesAbsent
+        }()
+        return (flow: flow, network: residualNetwork.unweighted())
+    }
+}
+
+extension Sequence {
+
+    func filterComplement (_ predicate: (Element) -> Bool) -> [Element] {
+        return filter { !predicate($0) }
+    }
+    
+    func partition (_ predicate: (Element) -> Bool) -> (whereFalse: [Element], whereTrue: [Element]) {
+        return (filterComplement(predicate), filter(predicate))
+    }
+}
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 3e46d38..c61a1d5 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -5,6 +5,7 @@
 //  Created by James Bean on 5/23/18.
 //
 
+import DataStructures
 import Pitch
 
 protocol PitchSpellingNode: Hashable {
@@ -58,7 +59,7 @@ struct PitchSpeller {
     let pitchNodes: [Int]
 
     /// The `FlowNetwork` which will be manipulated in order to spell the unspelled `pitches`.
-    let flowNetwork: FlowNetwork<Int>
+    let flowNetwork: FlowNetwork<Int,Double>
 
     // MARK: - Initializers
 
@@ -101,24 +102,28 @@ struct PitchSpeller {
     }
 }
 
-extension FlowNetwork where Node == Int {
+extension FlowNetwork where Node == Int, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
     init(source: Int, sink: Int, internalNodes: [Int]) {
-        let graph = DirectedGraph(source: source, sink: sink, internalNodes: internalNodes)
-        self.init(graph, source: -2, sink: -1)
+        let graph = WeightedDirectedGraph<Int,Double>(
+            source: source,
+            sink: sink,
+            internalNodes: internalNodes
+        )
+        self.init(graph, source: source, sink: sink)
     }
 }
 
-extension DirectedGraph where Pair.A == Int, Weight == Double {
+extension WeightedDirectedGraph {
     /// Create a `DirectedGraph` which is hooked up as necessary for the Wetherfield pitch-spelling process.
-    init (source: Int, sink: Int, internalNodes: [Int]) {
-        self.init(Set([source, sink] + internalNodes), [:])
+    init(source: Node, sink: Node, internalNodes: [Node]) {
+        self.init(Set([source,sink] + internalNodes))
         for node in internalNodes {
-            insertEdge(from: source, to: node, withWeight: 1)
-            insertEdge(from: node, to: sink, withWeight: 1)
+            insertEdge(from: source, to: node, weight: 1)
+            insertEdge(from: node, to: sink, weight: 1)
             for other in internalNodes.lazy.filter({ $0 != node }) {
-                insertEdge(from: node, to: other, withWeight: 1)
+                insertEdge(from: node, to: other, weight: 1)
             }
         }
     }
-- 
2.17.2 (Apple Git-113)

