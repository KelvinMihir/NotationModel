From 6bfc711603ed2240beb6162f66ced0718d845b64 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 00:03:05 -0500
Subject: [PATCH 42/66] [NFC] Reorganize PitchSpeller struct into extensions
 (#165)

---
 .../Wetherfield/Wetherfield.swift             | 180 ++++++++++--------
 1 file changed, 104 insertions(+), 76 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 603f704..013035c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -31,78 +31,6 @@ protocol PitchSpellingNode: Hashable {
 
 struct PitchSpeller {
 
-    struct UnassignedNode: PitchSpellingNode {
-        let index: Index
-    }
-
-    struct AssignedNode: PitchSpellingNode {
-        let index: Index
-        let assignment: Tendency
-        init(_ index: Index, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-    
-    struct InternalAssignedNode {
-        let index: Cross<Int, Tendency>
-        let assignment: Tendency
-        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-    
-    // For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
-    // be connected to `(8, .up)` in the spelling dependency model.
-    static let eightTendencyLink: [(Pitch.Class, Tendency)] = [
-        (00, .down),
-        (01, .up),
-        (03, .down),
-        (04, .up),
-        (05, .down),
-        (06, .up),
-        (07, .down),
-        (08, .up),
-        (09, .up),
-        (10, .down),
-        (11, .up)
-    ]
-    
-    // Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
-    static let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
-        PitchSpeller.eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
-    )
-    
-    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> = GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
-    
-    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
-        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-            return GraphScheme<Pitch.Class> { edge in
-                edge.contains(pitchClass)
-            }
-        }
-        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-            return GraphScheme<Pitch.Class> { edge in
-                !edge.contains(pitchClass)
-            }
-        }
-        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
-    }
-
-    /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
-    /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
-    /// the given `Pitch`.)
-    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
-        return .internal(.init(offset, index))
-    }
-
-    /// - Returns: An array of nodes, each representing the index of the unassigned node in
-    /// `pitchNodes`.
-    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
-        return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
-    }
-
     // MARK: - Instance Properties
 
     /// The unspelled `Pitch` values to be spelled.
@@ -117,6 +45,9 @@ struct PitchSpeller {
     
     /// Getter for pitch class (from Index)
     let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
+}
+
+extension PitchSpeller {
 
     // MARK: - Initializers
 
@@ -145,7 +76,7 @@ struct PitchSpeller {
             sink: .sink,
             internalNodes: pitchNodes
         )
-        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(PitchSpeller.eightLookup.contains)
+        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>>(eightLookup.contains)
         let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
             .init(getPitchClass(flowNode), flowNode.tendency)
         }
@@ -156,6 +87,53 @@ struct PitchSpeller {
         let connectedToEight = connectToEight * whereEdge(contains: true)(8)
         flowNetwork.mask(connectedToTwoNotEight + sameClass + connectedToEight)
     }
+}
+
+extension PitchSpeller {
+
+    // MARK: - Type Properties
+
+    static let connectSameTendencies: GraphScheme<PitchSpellingNode.Index>
+        = GraphScheme<Tendency> { edge in edge.a == edge.b }
+            .pullback { node in
+                switch node {
+                case .source: return .down
+                case .sink: return .up
+                case .internal(let index): return index.b
+                }
+    }
+
+    static func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
+        func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                edge.contains(pitchClass)
+            }
+        }
+        func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
+            return GraphScheme<Pitch.Class> { edge in
+                !edge.contains(pitchClass)
+            }
+        }
+        return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
+    }
+
+    /// - Returns: The value of a node at the given offset (index of a `Pitch` within `pitches`),
+    /// and an index (either `0` or `1`, which of the two nodes in the `FlowNetwork` that represent
+    /// the given `Pitch`.)
+    private static func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
+        return .internal(.init(offset, index))
+    }
+
+    /// - Returns: An array of nodes, each representing the index of the unassigned node in
+    /// `pitchNodes`.
+    private static func internalNodes(pitches: [Int: Pitch]) -> [PitchSpellingNode.Index] {
+        return pitches.keys.flatMap { offset in [.down,.up].map { index in node(offset, index) } }
+    }
+}
+
+extension PitchSpeller {
+
+    // MARK: - Instance Methods
 
     /// - Returns: An array of `SpelledPitch` values with the same indices as the original
     /// unspelled `Pitch` values.
@@ -172,8 +150,10 @@ struct PitchSpeller {
         return assignedNodes
             .compactMap { (assignedNode) -> InternalAssignedNode? in
                 switch assignedNode.index {
-                case .source, .sink: return nil
-                case .internal(let index): return InternalAssignedNode(index, assignedNode.assignment)
+                case .source, .sink:
+                    return nil
+                case .internal(let index):
+                    return InternalAssignedNode(index, assignedNode.assignment)
                 }
             }
             .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
@@ -193,7 +173,7 @@ struct PitchSpeller {
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
-    
+
     func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
         func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
             return PitchSpeller.adjacencyScheme(contains: true)(pitchClass).pullback(getPitchClass)
@@ -205,6 +185,54 @@ struct PitchSpeller {
     }
 }
 
+// For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
+// be connected to `(8, .up)` in the spelling dependency model.
+private let eightTendencyLink: [(Pitch.Class, Tendency)] = [
+    (00, .down),
+    (01, .up),
+    (03, .down),
+    (04, .up),
+    (05, .down),
+    (06, .up),
+    (07, .down),
+    (08, .up),
+    (09, .up),
+    (10, .down),
+    (11, .up)
+]
+
+// Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
+private let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
+    eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
+)
+
+extension PitchSpeller {
+
+    // MARK: - Nested Types
+
+    struct UnassignedNode: PitchSpellingNode {
+        let index: Index
+    }
+
+    struct AssignedNode: PitchSpellingNode {
+        let index: Index
+        let assignment: Tendency
+        init(_ index: Index, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+
+    struct InternalAssignedNode {
+        let index: Cross<Int, Tendency>
+        let assignment: Tendency
+        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+}
+
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-- 
2.17.2 (Apple Git-113)

