From 54db2ef3b709badd54bf3da01f16e414318f3e49 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Mon, 5 Nov 2018 17:21:15 -0500
Subject: [PATCH 43/66] [NFC] Refactor PitchSpeller.whereEdge(contains:) (#169)

---
 .../Wetherfield/Wetherfield.swift             | 73 ++++++++++---------
 1 file changed, 39 insertions(+), 34 deletions(-)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index 013035c..d6f5137 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -47,6 +47,33 @@ struct PitchSpeller {
     let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 }
 
+extension PitchSpeller {
+
+    // MARK: - Nested Types
+
+    struct UnassignedNode: PitchSpellingNode {
+        let index: Index
+    }
+
+    struct AssignedNode: PitchSpellingNode {
+        let index: Index
+        let assignment: Tendency
+        init(_ index: Index, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+
+    struct InternalAssignedNode {
+        let index: Cross<Int, Tendency>
+        let assignment: Tendency
+        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
+            self.index = index
+            self.assignment = assignment
+        }
+    }
+}
+
 extension PitchSpeller {
 
     // MARK: - Initializers
@@ -174,14 +201,14 @@ extension PitchSpeller {
         return try! pitch.spelled(with: spelling)
     }
 
+    /// FIXME: Consider implementing as:
+    /// `let whereEdge: (Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index>`
     func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-        func doesContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-            return PitchSpeller.adjacencyScheme(contains: true)(pitchClass).pullback(getPitchClass)
-        }
-        func doesNotContain (pitchClass: Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-            return PitchSpeller.adjacencyScheme(contains: false)(pitchClass).pullback(getPitchClass)
+        return { pitchClass in
+            return PitchSpeller
+                .adjacencyScheme(contains: contains)(pitchClass)
+                .pullback(self.getPitchClass)
         }
-        return contains ? doesContain : doesNotContain
     }
 }
 
@@ -206,37 +233,15 @@ private let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
     eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
 )
 
-extension PitchSpeller {
-
-    // MARK: - Nested Types
-
-    struct UnassignedNode: PitchSpellingNode {
-        let index: Index
-    }
-
-    struct AssignedNode: PitchSpellingNode {
-        let index: Index
-        let assignment: Tendency
-        init(_ index: Index, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-
-    struct InternalAssignedNode {
-        let index: Cross<Int, Tendency>
-        let assignment: Tendency
-        init(_ index: Cross<Int, Tendency>, _ assignment: Tendency) {
-            self.index = index
-            self.assignment = assignment
-        }
-    }
-}
-
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
     /// process.
-    init(source: PitchSpellingNode.Index, sink: PitchSpellingNode.Index, internalNodes: [PitchSpellingNode.Index]) {
+    init(
+        source: PitchSpellingNode.Index,
+        sink: PitchSpellingNode.Index,
+        internalNodes: [PitchSpellingNode.Index]
+    )
+    {
         let graph = WeightedDirectedGraph<PitchSpellingNode.Index,Double>(
             source: source,
             sink: sink,
-- 
2.17.2 (Apple Git-113)

