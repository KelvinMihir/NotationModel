From 6baf6901cc591169642f0878c19b7b7e4ad0e8e1 Mon Sep 17 00:00:00 2001
From: James Bean <jbean46@gmail.com>
Date: Sun, 11 Nov 2018 22:44:11 -0500
Subject: [PATCH 56/66] Add more dyad tests (#176)

---
 ...otocol.swift => DirectedGraphScheme.swift} |   2 +-
 .../Wetherfield/FlowNetwork.swift             |  11 +-
 .../Wetherfield/GraphScheme.swift             |   6 +-
 .../Wetherfield/Pitch.Spelling.Category.swift |   4 +-
 .../UnweightedGraphSchemeProtocol.swift       |  28 ++-
 .../WeightedGraphSchemeProtocol.swift         |  26 +-
 .../Wetherfield/Wetherfield.swift             | 222 ++++++++++++------
 7 files changed, 206 insertions(+), 93 deletions(-)
 rename Sources/SpelledPitch/PitchSpeller/Wetherfield/{DirectedGraphProtocol.swift => DirectedGraphScheme.swift} (87%)

diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphScheme.swift
similarity index 87%
rename from Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
rename to Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphScheme.swift
index 26c6784..ed440c3 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/DirectedGraphScheme.swift
@@ -17,7 +17,7 @@ struct DirectedGraphScheme <Node>: DirectedGraphSchemeProtocol, UnweightedGraphS
         self.contains = contains
     }
     
-    func contains(from start: Node, to end: Node) -> Bool {
+    func containsEdge(from start: Node, to end: Node) -> Bool {
         return contains(Edge(start, end))
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
index 64267bc..d94f7d2 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/FlowNetwork.swift
@@ -63,7 +63,7 @@ extension FlowNetwork {
     mutating func mask <Scheme: UnweightedGraphSchemeProtocol> (_ adjacencyScheme: Scheme) where
         Scheme.Node == Node
     {
-        for edge in edges where !adjacencyScheme.contains(from: edge.a, to: edge.b) {
+        for edge in edges where !adjacencyScheme.containsEdge(from: edge.a, to: edge.b) {
             remove(edge)
         }
     }
@@ -73,8 +73,11 @@ extension FlowNetwork {
         Scheme.Weight == Weight
     {
         for edge in edges {
-            guard let scalar = weightScheme.weight(from: edge.a, to: edge.b) else { remove(edge); return }
-            updateEdge(edge) { $0 * scalar }
+            if let scalar = weightScheme.weight(from: edge.a, to: edge.b) {
+                updateEdge(edge) { $0 * scalar }
+            } else {
+                remove(edge)
+            }
         }
     }
 }
@@ -191,3 +194,5 @@ extension Sequence {
         return (filterComplement(predicate), filter(predicate))
     }
 }
+
+extension FlowNetwork: Equatable where Node: Hashable, Weight: Hashable { }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
index 6813f19..bc5529b 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/GraphScheme.swift
@@ -16,8 +16,8 @@ struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeP
     init (_ contains: @escaping (Edge) -> Bool) {
         self.contains = contains
     }
-    
-    func contains(from start: Node, to end: Node) -> Bool {
+
+    func containsEdge(from start: Node, to end: Node) -> Bool {
         return contains(Edge(start, end))
     }
 }
@@ -25,6 +25,6 @@ struct GraphScheme <Node>: UndirectedGraphSchemeProtocol, UnweightedGraphSchemeP
 extension GraphScheme {
     
     var directed: DirectedGraphScheme<Node> {
-        return .init { edge in self.contains(from: edge.a, to: edge.b) }
+        return .init { edge in self.containsEdge(from: edge.a, to: edge.b) }
     }
 }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
index fe6ebd0..dc60079 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Pitch.Spelling.Category.swift
@@ -23,7 +23,7 @@ extension Pitch.Spelling {
         /// Category for pitch classes `0` and `5`.
         struct Zero: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .natural, .up: .sharp]
+                return [.down: .doubleFlat, .neutral: .natural, .up: .sharp]
             }
         }
 
@@ -44,7 +44,7 @@ extension Pitch.Spelling {
         /// Category for pitch classes `3`, and `10`.
         struct Three: PitchSpellingCategoryProtocol {
             static var modifiers: ModifierMap {
-                return [.down: .flat, .neutral: .flat, .up: .sharp]
+                return [.down: .doubleFlat, .neutral: .flat, .up: .sharp]
             }
         }
 
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
index 6a4feb4..1da832c 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/UnweightedGraphSchemeProtocol.swift
@@ -11,8 +11,8 @@ public protocol UnweightedGraphSchemeProtocol: GraphSchemeProtocol {
     var contains: (Edge) -> Bool { get }
     
     init (_ contains: @escaping (Edge) -> Bool)
-    
-    func contains (from start: Node, to end: Node) -> Bool
+
+    func containsEdge (from start: Node, to end: Node) -> Bool
 }
 
 extension UnweightedGraphSchemeProtocol {
@@ -22,15 +22,18 @@ extension UnweightedGraphSchemeProtocol {
     }
 }
 
+extension UnweightedGraphSchemeProtocol {
+    
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
+    }
+}
+
 extension UnweightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol {
     
     static func * (lhs: Self, rhs: Self) -> Self {
         return Self { edge in lhs.contains(edge) && rhs.contains(edge) }
     }
-    
-    static func + (lhs: Self, rhs: Self) -> Self {
-        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
-    }
 }
 
 extension UnweightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol {
@@ -39,7 +42,18 @@ extension UnweightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol
         Scheme: UnweightedGraphSchemeProtocol,
         Scheme.Node == Node
     {
-        return Self { edge in lhs.contains(edge) && rhs.contains(from: edge.a, to: edge.b) }
+        return Self { edge in lhs.contains(edge) && rhs.containsEdge(from: edge.a, to: edge.b) }
+    }
+    
+    static func * <Scheme> (lhs: Scheme, rhs: Self) -> Self where
+        Scheme: UnweightedGraphSchemeProtocol,
+        Scheme.Node == Node
+    {
+        return rhs * lhs
+    }
+    
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in lhs.contains(edge) || rhs.contains(edge) }
     }
 }
 
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
index 7cb7889..58de7d7 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/WeightedGraphSchemeProtocol.swift
@@ -35,6 +35,17 @@ extension WeightedGraphSchemeProtocol {
     }
 }
 
+extension WeightedGraphSchemeProtocol {
+    
+    /// - Returns: rhs weight function whenever the lhs is missing the edge in question.
+    /// This function is non-commutative.
+    static func + (lhs: Self, rhs: Self) -> Self {
+        return Self { edge in
+            lhs.weight(edge) ?? rhs.weight(edge)
+        }
+    }
+}
+
 extension WeightedGraphSchemeProtocol where Self: UndirectedGraphSchemeProtocol, Weight: Numeric {
     
     static func * (lhs: Self, rhs: Self) -> Self {
@@ -53,10 +64,11 @@ extension WeightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol, W
     Scheme.Weight == Weight
     {
         return Self { edge in
-            guard
-                let lweight = lhs.weight(edge),
-                let rweight = rhs.weight(from: edge.a, to: edge.b) else { return nil }
-            return lweight * rweight
+            lhs.weight(edge).flatMap { lweight in
+                rhs.weight(from: edge.a, to: edge.b).map { rweight in
+                    lweight * rweight
+                }
+            }
         }
     }
     
@@ -65,10 +77,8 @@ extension WeightedGraphSchemeProtocol where Self: DirectedGraphSchemeProtocol, W
         Scheme.Node == Node
     {
         return Self { edge in
-            if let lweight = lhs.weight(edge) {
-                return rhs.contains(from: edge.a, to: edge.b) ? lweight : nil
-            } else {
-                return nil
+            lhs.weight(edge).flatMap { weight in
+                rhs.containsEdge(from: edge.a, to: edge.b) ? weight : nil
             }
         }
     }
diff --git a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
index e2948a3..616aa5e 100644
--- a/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
+++ b/Sources/SpelledPitch/PitchSpeller/Wetherfield/Wetherfield.swift
@@ -14,6 +14,16 @@ enum FlowNode<Index>: Hashable where Index: Hashable {
     case sink
 }
 
+func bind <S: Hashable, A: Hashable> (_ f: @escaping (S) -> A) -> (FlowNode<S>) -> FlowNode<A> {
+    return { flowNodeS in
+        switch flowNodeS {
+        case .internal(let index): return .internal(f(index))
+        case .source: return .source
+        case .sink: return .sink
+        }
+    }
+}
+
 extension FlowNode where Index == Cross<Int,Tendency> {
     var tendency: Tendency {
         switch self {
@@ -24,6 +34,33 @@ extension FlowNode where Index == Cross<Int,Tendency> {
     }
 }
 
+extension FlowNode where Index: Pair, Index.A == Int {
+    var int: Int? {
+        switch self {
+        case .internal(let index): return index.a
+        default: return nil
+        }
+    }
+}
+
+extension FlowNode where Index: Pair, Index.A == Pitch.Class {
+    var pitchClass: Pitch.Class? {
+        switch self {
+        case .internal(let index): return index.a
+        case .source, .sink: return nil
+        }
+    }
+}
+
+extension FlowNode where Index: Pair, Index.B == Tendency {
+    var tendency: Tendency? {
+        switch self {
+        case .internal(let index): return index.b
+        default: return nil
+        }
+    }
+}
+
 protocol PitchSpellingNode: Hashable {
     typealias Index = FlowNode<Cross<Int,Tendency>>
     var index: Index { get }
@@ -38,9 +75,6 @@ struct PitchSpeller {
 
     /// The unspelled `Pitch` values to be spelled.
     let pitch: (PitchSpellingNode.Index) -> Pitch?
-
-    /// Getter for pitch class (from Index)
-    let getPitchClass: (PitchSpellingNode.Index) -> Pitch.Class
 }
 
 extension PitchSpeller {
@@ -89,26 +123,28 @@ extension PitchSpeller {
                 return pitches[cross.a]
             }
         }
-        let getPitchClass: (FlowNode<Cross<Int,Tendency>>) -> Pitch.Class = { flowNode in
-            switch flowNode {
-            case .source, .sink:
-                return parsimonyPivot.pitchClass
-            case .internal(let cross):
-                return pitches[cross.a]!.class
-            }
+        
+        let internalPitchClassTendency = { (cross: Cross<Int, Tendency>) in
+            Cross(pitches[cross.a]!.class, cross.b)
         }
-        self.getPitchClass = getPitchClass
-
-        let specificToEight = GraphScheme<Cross<Pitch.Class, Tendency>> (eightLookup.contains)
-        let connectToEight: GraphScheme<PitchSpellingNode.Index> = specificToEight.pullback { flowNode in
-            .init(getPitchClass(flowNode), flowNode.tendency)
-        }
-        let connectedToTwoNotEight = connectSameTendencies * whereEdge(contains: false)(8) * whereEdge(contains: true)(2)
-        let sameClass = connectSameTendencies * GraphScheme<Pitch.Class> { edge in
-            edge.a == edge.b }
-            .pullback(getPitchClass)
-        let connectedToEight = connectToEight * whereEdge(contains: true)(8)
-        flowNetwork.mask(connectedToTwoNotEight + sameClass + connectedToEight)
+        let pitchClassTendencyGetter = bind(internalPitchClassTendency)
+        
+        let specificSourceEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            sourceEdges.pullback(pitchClassTendencyGetter)
+        let specificInternalEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            internalEdges.pullback(pitchClassTendencyGetter)
+        let specificSinkEdges: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            sinkEdges.pullback(pitchClassTendencyGetter)
+        
+        // All the connections that rely on pitch class specific information
+        let connections: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            (connectDifferentInts * specificInternalEdges) + specificSourceEdges + specificSinkEdges
+        
+        // Combination of pitch class specific information and connections within each `Int` index
+        // regardless of pitch class.
+        let maskArgument: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+            connections + bigMAssignment
+        flowNetwork.mask(maskArgument)
     }
 }
 
@@ -140,10 +176,11 @@ extension PitchSpeller {
             .reduce(into: [Int: (InternalAssignedNode, InternalAssignedNode)]()) { pairs, node in
                 if !pairs.keys.contains(node.index.a) {
                     pairs[node.index.a] = (node, node)
-                }
-                switch node.index.b {
-                case .up: pairs[node.index.a]!.0 = node
-                case .down: pairs[node.index.a]!.1 = node
+                } else {
+                    switch node.index.b {
+                    case .up: pairs[node.index.a]!.0 = node
+                    case .down: pairs[node.index.a]!.1 = node
+                    }
                 }
             }.mapValues(spellPitch)
     }
@@ -158,14 +195,6 @@ extension PitchSpeller {
         let spelling = Pitch.Spelling(pitchClass: pitch.class, tendencies: tendencies)!
         return try! pitch.spelled(with: spelling)
     }
-
-    /// FIXME: Consider implementing as:
-    /// `let whereEdge: (Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index>`
-    func whereEdge (contains: Bool) -> (Pitch.Class) -> GraphScheme<PitchSpellingNode.Index> {
-        return { pitchClass in
-            adjacencyScheme(contains: contains)(pitchClass).pullback(self.getPitchClass)
-        }
-    }
 }
 
 /// - Returns: An array of nodes, each representing the index of the unassigned node in
@@ -181,43 +210,98 @@ private func node(_ offset: Int, _ index: Tendency) -> PitchSpellingNode.Index {
     return .internal(.init(offset, index))
 }
 
-private func adjacencyScheme (contains: Bool) -> (Pitch.Class) -> GraphScheme<Pitch.Class> {
-    func pitchClassAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-        return GraphScheme<Pitch.Class> { edge in
-            edge.contains(pitchClass)
-        }
-    }
-    func pitchClassNonAdjacencyScheme (pitchClass: Pitch.Class) -> GraphScheme<Pitch.Class> {
-        return GraphScheme<Pitch.Class> { edge in
-            !edge.contains(pitchClass)
-        }
-    }
-    return contains ? pitchClassAdjacencyScheme : pitchClassNonAdjacencyScheme
-}
-
-private let connectSameTendencies: GraphScheme<PitchSpellingNode.Index> =
-    GraphScheme<Tendency> { edge in edge.a == edge.b }.pullback { node in node.tendency }
-
-// For each `Pitch.Class` `n`, denotes which of `(n, .up)` and `(n, .down)` should
-// be connected to `(8, .up)` in the spelling dependency model.
-private let eightTendencyLink: [(Pitch.Class, Tendency)] = [
-    (00, .down),
-    (01, .up),
-    (03, .down),
-    (04, .up),
-    (05, .down),
-    (06, .up),
-    (07, .down),
-    (08, .up),
-    (09, .up),
-    (10, .down),
-    (11, .up)
+private let connectUpToDown: DirectedGraphScheme<PitchSpellingNode.Index> =
+    DirectedGraphScheme<Tendency> { edge in
+        edge.a == .up && edge.b == .down
+        }.pullback { node in node.tendency }
+
+private let bigMAdjacency: DirectedGraphScheme<PitchSpellingNode.Index> =
+    connectSameInts * connectUpToDown
+
+private let bigMAssignment: WeightedDirectedGraphScheme<PitchSpellingNode.Index, Double> =
+    Double.infinity * bigMAdjacency
+
+private let connectSameInts: GraphScheme<PitchSpellingNode.Index> =
+    GraphScheme<Int?> { edge in edge.a == edge.b && edge.a != nil }.pullback { node in node.int }
+
+private let connectDifferentInts: GraphScheme<PitchSpellingNode.Index> =
+    GraphScheme<Int?> { edge in !(edge.a == edge.b && edge.a != nil) }.pullback { node in node.int }
+
+private let sourceEdges =
+    WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> { edge in
+        (edge.a == .source && edge.b.tendency == .down) ?
+            edge.b.pitchClass.flatMap { index in sourceEdgeLookup[index] } : nil
+}
+
+private let sourceEdgeLookup: [Pitch.Class: Double] = [
+    00: 2,
+    01: 3,
+    02: 3,
+    03: 1,
+    04: 3,
+    05: 2,
+    06: 3,
+    07: 3,
+
+    09: 3,
+    10: 1,
+    11: 3,
 ]
 
-// Maps `eightTendencyLink` to a `Set` of `Edge` values (to check for membership)
-private let eightLookup = Set<UnorderedPair<Cross<Pitch.Class, Tendency>>> (
-    eightTendencyLink.lazy.map(Cross.init).map { UnorderedPair($0, .init(8, .up)) }
-)
+private let sinkEdges =
+    WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> { edge in
+        (edge.b == .sink && edge.a.tendency == .up) ?
+            edge.a.pitchClass.flatMap { index in sinkEdgeLookup[index] } : nil
+}
+
+private let sinkEdgeLookup: [Pitch.Class: Double] = [
+    00: 3,
+    01: 1,
+    02: 2,
+    03: 3,
+    04: 3,
+    05: 3,
+    06: 1,
+    07: 3,
+    
+    09: 3,
+    10: 3,
+    11: 2,
+]
+
+private let internalEdges: WeightedDirectedGraphScheme<FlowNode<Cross<Pitch.Class, Tendency>>, Double> =
+        WeightedGraphScheme { edge in
+            switch (edge.a, edge.b) {
+            case (.internal(let source), .internal(let destination)):
+                return internalEdgeLookup[.init(source, destination)]
+            default: return nil
+            }
+}.directed
+
+private let internalEdgeLookup: [UnorderedPair<Cross<Pitch.Class, Tendency>>: Double] = [
+    
+    // Replacement for eightTendencyLink
+    .init(.init(00, .down), .init(08,   .up)): 1,
+    .init(.init(01,   .up), .init(08,   .up)): 1,
+    .init(.init(03, .down), .init(08,   .up)): 1,
+    .init(.init(04,   .up), .init(08,   .up)): 1,
+    .init(.init(05, .down), .init(08,   .up)): 1,
+    .init(.init(06,   .up), .init(08,   .up)): 1,
+    .init(.init(07, .down), .init(08,   .up)): 1,
+    .init(.init(08,   .up), .init(08,   .up)): 1,
+    .init(.init(09,   .up), .init(08,   .up)): 1,
+    .init(.init(10, .down), .init(08,   .up)): 1,
+    .init(.init(11,   .up), .init(08,   .up)): 1,
+
+    .init(.init(00, .down), .init(01,   .up)): 1.5,
+    .init(.init(00,   .up), .init(01, .down)): 0.5,
+    
+    .init(.init(01, .down), .init(03,   .up)): 1,
+    .init(.init(01,   .up), .init(03, .down)): 1,
+    
+    .init(.init(01, .down), .init(05,   .up)): 0.5,
+    .init(.init(01,   .up), .init(05, .down)): 1.5,
+]
 
 extension FlowNetwork where Node == PitchSpellingNode.Index, Weight == Double {
     /// Create a `FlowNetwork` which is hooked up as neccesary for the Wetherfield pitch-spelling
-- 
2.17.2 (Apple Git-113)

